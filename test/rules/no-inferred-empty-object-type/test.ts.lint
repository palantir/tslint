let s: string;
let n: number;
let o: Object;
let l: { a: number, b: string };
let t: [number, string];
let p: Wrapper<string>;
let f: () => void;
type EmptyFunc = () => void;
let voidFunc: () => void;
let stringFunc: () => string;
function WrapperFunc<T>(x?: T): T {
	return x;
}
function CurriedFunc<T>(h?: () => T): () => T {
	return h;
}
function MultiParamFunction<T, U>(x?: T, y?: U): T {
	return x;
}
class Wrapper<T> {
	val: T;
}
class MultiParamsClass<U, T> {
	val1: T;
	val2: U;
}

/* Bad */
WrapperFunc();
~~~~~~~~~~~~~  [fn]
CurriedFunc();
~~~~~~~~~~~~~  [fn]
MultiParamFunction();
~~~~~~~~~~~~~~~~~~~~  [fn]
new Wrapper();
~~~~~~~~~~~~~  [new]
new MultiParamsClass();
~~~~~~~~~~~~~~~~~~~~~~  [new]

/* Good */
WrapperFunc<Object>();
WrapperFunc<string>();
WrapperFunc<number>();
WrapperFunc(s);
WrapperFunc(n);
WrapperFunc(o);
WrapperFunc(l);
WrapperFunc(t);
WrapperFunc(p);
WrapperFunc(f);
WrapperFunc<() => {}>();
WrapperFunc({"foo-bar": {}});
WrapperFunc(new Wrapper("foo"));
WrapperFunc(new Wrapper<{}>());

WrapperFunc<() => void>();
WrapperFunc<{ a: number }>();
WrapperFunc<{ [x: number]: string }>();
WrapperFunc<{ [x: string]: string }>();
WrapperFunc<{ (): string }>();

{
    let wrap: Wrapper<string> = new Wrapper();
    let take = <T>(param: T) => {};
    take<any>(new Wrapper());
              ~~~~~~~~~~~~~ [new]
    take<{}>(new Wrapper());
             ~~~~~~~~~~~~~ [new]
    take<Object>(new Wrapper());
                 ~~~~~~~~~~~~~ [new]
    take<Wrapper<any>>(new Wrapper());
    take<Wrapper<string>>(new Wrapper());
}

CurriedFunc(voidFunc);
CurriedFunc(stringFunc);

MultiParamFunction<string, {}>();
MultiParamFunction<{}, number>();
MultiParamFunction<string, number>();
MultiParamFunction<{ a: number }, string>();
MultiParamFunction<() => {}, () => void>();
MultiParamFunction<() => void, () => {}>();
MultiParamFunction<() => void, () => void>();
MultiParamFunction<{ [x: number]: string }, () => void>();
MultiParamFunction<{ [x: string]: string }, number>();

new Wrapper<string>();
new Wrapper<() => void>();
new Wrapper<() => {}>();
new Wrapper<{ a: number }>();
new Wrapper<{ [x: number]: string }>();
new Wrapper<{ [x: string]: string }>();

new MultiParamsClass<string, {}>();
new MultiParamsClass<{}, number>();
new MultiParamsClass<string, number>();
new MultiParamsClass<{ a: number }, string>();
new MultiParamsClass<() => {}, () => void>();
new MultiParamsClass<() => void, () => {}>();
new MultiParamsClass<() => void, () => void>();
new MultiParamsClass<{ [x: number]: string }, () => void>();
new MultiParamsClass<{ [x: string]: string }, number>();

// don't crash with stack overflow
import {expect} from "chai";
expect(1).to.eq(1);

{
    const wrapper = <L, A>(l: L) => ({ l });
    const x = wrapper(1); // The second generic, A, is inferred as an empty object
              ~~~~~~~~~~  [fn]
}
{
    const wrapper = <L, A>(l: A): L => ({ l });
    const x = wrapper(1);
              ~~~~~~~~~~  [fn]
}
{
    const wrapper = <L, A>(l: L): [L, A] => ({ l } as any);
    const x = wrapper(1);
              ~~~~~~~~~~  [fn]
}
{
    let fn = <T>(obj?: T, cb?: (obj: T) => void) => {};
    fn();
    ~~~~ [fn]
}

{
    // found in our code
    abstract class Base<T> {}
    class Child extends Base<{}> {}
    let foo = new Child(); // quickinfo shows 'constructor Child<{}>(): Child' - but this is not an inferred type parameter
}

{
    interface I {
        new<T>(obj?: T, cb?: (obj: T) => void): any;
    }
    let C: I = null as any;
    new C();
    ~~~~~~~ [new]
}

{
    let demap = <T>(map: Map<string, T>): {[key: string]: T} {}
    demap(null as any);
    ~~~~~~~~~~~~~~~~~~ [fn]
}

[fn]: Explicit type parameter needs to be provided to the function call
[new]: Explicit type parameter needs to be provided to the constructor
