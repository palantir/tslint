declare module TypeScript {
    var DiagnosticCode: {
        error_TS_0_1: string;
        warning_TS_0_1: string;
        Unrecognized_escape_sequence: string;
        Unexpected_character_0: string;
        Missing_close_quote_character: string;
        Identifier_expected: string;
        _0_keyword_expected: string;
        _0_expected: string;
        Identifier_expected_0_is_a_keyword: string;
        Automatic_semicolon_insertion_not_allowed: string;
        Unexpected_token_0_expected: string;
        Trailing_separator_not_allowed: string;
        AsteriskSlash_expected: string;
        public_or_private_modifier_must_precede_static: string;
        Unexpected_token: string;
        Catch_clause_parameter_cannot_have_a_type_annotation: string;
        Rest_parameter_must_be_last_in_list: string;
        Parameter_cannot_have_question_mark_and_initializer: string;
        Required_parameter_cannot_follow_optional_parameter: string;
        Index_signatures_cannot_have_rest_parameters: string;
        Index_signature_parameter_cannot_have_accessibility_modifiers: string;
        Index_signature_parameter_cannot_have_a_question_mark: string;
        Index_signature_parameter_cannot_have_an_initializer: string;
        Index_signature_must_have_a_type_annotation: string;
        Index_signature_parameter_must_have_a_type_annotation: string;
        Index_signature_parameter_type_must_be_string_or_number: string;
        extends_clause_already_seen: string;
        extends_clause_must_precede_implements_clause: string;
        Classes_can_only_extend_a_single_class: string;
        implements_clause_already_seen: string;
        Accessibility_modifier_already_seen: string;
        _0_modifier_must_precede_1_modifier: string;
        _0_modifier_already_seen: string;
        _0_modifier_cannot_appear_on_a_class_element: string;
        Interface_declaration_cannot_have_implements_clause: string;
        super_invocation_cannot_have_type_arguments: string;
        Only_ambient_modules_can_use_quoted_names: string;
        Statements_are_not_allowed_in_ambient_contexts: string;
        Implementations_are_not_allowed_in_ambient_contexts: string;
        declare_modifier_not_allowed_for_code_already_in_an_ambient_context: string;
        Initializers_are_not_allowed_in_ambient_contexts: string;
        Parameter_property_declarations_can_only_be_used_in_constructors: string;
        Function_implementation_expected: string;
        Constructor_implementation_expected: string;
        Function_overload_name_must_be_0: string;
        _0_modifier_cannot_appear_on_a_module_element: string;
        declare_modifier_cannot_appear_on_an_interface_declaration: string;
        declare_modifier_required_for_top_level_element: string;
        Rest_parameter_cannot_be_optional: string;
        Rest_parameter_cannot_have_an_initializer: string;
        set_accessor_must_have_one_and_only_one_parameter: string;
        set_accessor_parameter_cannot_have_accessibility_modifier: string;
        set_accessor_parameter_cannot_be_optional: string;
        set_accessor_parameter_cannot_have_an_initializer: string;
        set_accessor_cannot_have_rest_parameter: string;
        get_accessor_cannot_have_parameters: string;
        Modifiers_cannot_appear_here: string;
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: string;
        Class_name_cannot_be_0: string;
        Interface_name_cannot_be_0: string;
        Enum_name_cannot_be_0: string;
        Module_name_cannot_be_0: string;
        Enum_member_must_have_initializer: string;
        Export_assignment_cannot_be_used_in_internal_modules: string;
        Export_assignment_not_allowed_in_module_with_exported_element: string;
        Module_cannot_have_multiple_export_assignments: string;
        Ambient_enum_elements_can_only_have_integer_literal_initializers: string;
        module_class_interface_enum_import_or_statement: string;
        constructor_function_accessor_or_variable: string;
        statement: string;
        case_or_default_clause: string;
        identifier: string;
        call_construct_index_property_or_function_signature: string;
        expression: string;
        type_name: string;
        property_or_accessor: string;
        parameter: string;
        type: string;
        type_parameter: string;
        declare_modifier_not_allowed_on_import_declaration: string;
        Function_overload_must_be_static: string;
        Function_overload_must_not_be_static: string;
        Parameter_property_declarations_cannot_be_used_in_an_ambient_context: string;
        Parameter_property_declarations_cannot_be_used_in_a_constructor_overload: string;
        Duplicate_identifier_0: string;
        The_name_0_does_not_exist_in_the_current_scope: string;
        The_name_0_does_not_refer_to_a_value: string;
        super_can_only_be_used_inside_a_class_instance_method: string;
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: string;
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: string;
        Value_of_type_0_is_not_callable: string;
        Value_of_type_0_is_not_newable: string;
        Value_of_type_0_is_not_indexable_by_type_1: string;
        Operator_0_cannot_be_applied_to_types_1_and_2: string;
        Operator_0_cannot_be_applied_to_types_1_and_2_3: string;
        Cannot_convert_0_to_1: string;
        Cannot_convert_0_to_1_NL_2: string;
        Expected_var_class_interface_or_module: string;
        Operator_0_cannot_be_applied_to_type_1: string;
        Getter_0_already_declared: string;
        Setter_0_already_declared: string;
        Accessors_cannot_have_type_parameters: string;
        Exported_class_0_extends_private_class_1: string;
        Exported_class_0_implements_private_interface_1: string;
        Exported_interface_0_extends_private_interface_1: string;
        Exported_class_0_extends_class_from_inaccessible_module_1: string;
        Exported_class_0_implements_interface_from_inaccessible_module_1: string;
        Exported_interface_0_extends_interface_from_inaccessible_module_1: string;
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: string;
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: string;
        Property_0_of_exported_interface_has_or_is_using_private_type_1: string;
        Exported_variable_0_has_or_is_using_private_type_1: string;
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: string;
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: string;
        Property_0_of_exported_interface_is_using_inaccessible_module_1: string;
        Exported_variable_0_is_using_inaccessible_module_1: string;
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: string;
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: string;
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: string;
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: string;
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: string;
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: string;
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: string;
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: string;
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: string;
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: string;
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: string;
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: string;
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: string;
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: string;
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: string;
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: string;
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: string;
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: string;
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: string;
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: string;
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: string;
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: string;
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: string;
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: string;
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: string;
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: string;
        Return_type_of_exported_function_has_or_is_using_private_type_0: string;
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: string;
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: string;
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: string;
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: string;
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: string;
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: string;
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: string;
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: string;
        Return_type_of_exported_function_is_using_inaccessible_module_0: string;
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: string;
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: string;
        Multiple_constructor_implementations_are_not_allowed: string;
        Unable_to_resolve_external_module_0: string;
        Module_cannot_be_aliased_to_a_non_module_type: string;
        A_class_may_only_extend_another_class: string;
        A_class_may_only_implement_another_class_or_interface: string;
        An_interface_may_only_extend_another_class_or_interface: string;
        An_interface_cannot_implement_another_type: string;
        Unable_to_resolve_type: string;
        Unable_to_resolve_type_of_0: string;
        Unable_to_resolve_type_parameter_constraint: string;
        Type_parameter_constraint_cannot_be_a_primitive_type: string;
        Supplied_parameters_do_not_match_any_signature_of_call_target: string;
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: string;
        Invalid_new_expression: string;
        Call_signatures_used_in_a_new_expression_must_have_a_void_return_type: string;
        Could_not_select_overload_for_new_expression: string;
        Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2: string;
        Could_not_select_overload_for_call_expression: string;
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: string;
        Calls_to_super_are_only_valid_inside_a_class: string;
        Generic_type_0_requires_1_type_argument_s: string;
        Type_of_conditional_expression_cannot_be_determined_Best_common_type_could_not_be_found_between_0_and_1: string;
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: string;
        Could_not_find_enclosing_symbol_for_dotted_name_0: string;
        The_property_0_does_not_exist_on_value_of_type_1: string;
        Could_not_find_symbol_0: string;
        get_and_set_accessor_must_have_the_same_type: string;
        this_cannot_be_referenced_in_current_location: string;
        Static_methods_cannot_reference_class_type_parameters: string;
        Class_0_is_recursively_referenced_as_a_base_type_of_itself: string;
        Interface_0_is_recursively_referenced_as_a_base_type_of_itself: string;
        super_property_access_is_permitted_only_in_a_constructor_instance_member_function_or_instance_member_accessor_of_a_derived_class: string;
        super_cannot_be_referenced_in_non_derived_classes: string;
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: string;
        Constructors_for_derived_classes_must_contain_a_super_call: string;
        Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors: string;
        _0_1_is_inaccessible: string;
        this_cannot_be_referenced_within_module_bodies: string;
        Invalid_expression_types_not_known_to_support_the_addition_operator: string;
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: string;
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: string;
        The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type: string;
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: string;
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: string;
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: string;
        The_left_hand_side_of_an_in_expression_must_be_of_types_string_or_any: string;
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: string;
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: string;
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_a_subtype_of_the_Function_interface_type: string;
        Setters_cannot_return_a_value: string;
        Tried_to_query_type_of_uninitialized_module_0: string;
        Tried_to_set_variable_type_to_uninitialized_module_type_0: string;
        Function_0_declared_a_non_void_return_type_but_has_no_return_expression: string;
        Getters_must_return_a_value: string;
        Getter_and_setter_accessors_do_not_agree_in_visibility: string;
        Invalid_left_hand_side_of_assignment_expression: string;
        Function_declared_a_non_void_return_type_but_has_no_return_expression: string;
        Cannot_resolve_return_type_reference: string;
        Constructors_cannot_have_a_return_type_of_void: string;
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: string;
        All_symbols_within_a_with_block_will_be_resolved_to_any: string;
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: string;
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: string;
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: string;
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: string;
        this_cannot_be_referenced_in_static_initializers_in_a_class_body: string;
        Class_0_cannot_extend_class_1_NL_2: string;
        Interface_0_cannot_extend_class_1_NL_2: string;
        Interface_0_cannot_extend_interface_1_NL_2: string;
        Duplicate_overload_signature_for_0: string;
        Duplicate_constructor_overload_signature: string;
        Duplicate_overload_call_signature: string;
        Duplicate_overload_construct_signature: string;
        Overload_signature_is_not_compatible_with_function_definition: string;
        Overload_signature_is_not_compatible_with_function_definition_NL_0: string;
        Overload_signatures_must_all_be_public_or_private: string;
        Overload_signatures_must_all_be_exported_or_local: string;
        Overload_signatures_must_all_be_ambient_or_non_ambient: string;
        Overload_signatures_must_all_be_optional_or_required: string;
        Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature: string;
        this_cannot_be_referenced_in_constructor_arguments: string;
        Static_member_cannot_be_accessed_off_an_instance_variable: string;
        Instance_member_cannot_be_accessed_off_a_class: string;
        Untyped_function_calls_may_not_accept_type_arguments: string;
        Non_generic_functions_may_not_accept_type_arguments: string;
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: string;
        Rest_parameters_must_be_array_types: string;
        Overload_signature_implementation_cannot_use_specialized_type: string;
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: string;
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: string;
        Only_public_instance_methods_of_the_base_class_are_accessible_via_the_super_keyword: string;
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1: string;
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1_NL_2: string;
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0: string;
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0_NL_1: string;
        All_named_properties_must_be_subtypes_of_string_indexer_type_0: string;
        All_named_properties_must_be_subtypes_of_string_indexer_type_0_NL_1: string;
        Generic_type_references_must_include_all_type_arguments: string;
        Default_arguments_are_not_allowed_in_an_overload_parameter: string;
        Overloads_cannot_differ_only_by_return_type: string;
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: string;
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: string;
        Could_not_find_symbol_0_in_module_1: string;
        Unable_to_resolve_module_reference_0: string;
        Could_not_find_module_0_in_module_1: string;
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: string;
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: string;
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: string;
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: string;
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: string;
        Type_reference_0_in_extends_clause_doesn_t_reference_constructor_function_for_1: string;
        Internal_module_reference_0_in_import_declaration_doesn_t_reference_module_instance_for_1: string;
        Type_0_is_missing_property_1_from_type_2: string;
        Types_of_property_0_of_types_1_and_2_are_incompatible: string;
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: string;
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: string;
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: string;
        Types_0_and_1_define_property_2_as_private: string;
        Call_signatures_of_types_0_and_1_are_incompatible: string;
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: string;
        Type_0_requires_a_call_signature_but_type_1_lacks_one: string;
        Construct_signatures_of_types_0_and_1_are_incompatible: string;
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: string;
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: string;
        Index_signatures_of_types_0_and_1_are_incompatible: string;
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: string;
        Call_signature_expects_0_or_fewer_parameters: string;
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: string;
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: string;
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: string;
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: string;
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: string;
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: string;
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: string;
        Type_reference_cannot_refer_to_container_0: string;
        Type_reference_must_refer_to_type: string;
        Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element: string;
        _0_overload_s: string;
        Current_host_does_not_support_0_option: string;
        ECMAScript_target_version_0_not_supported_Using_default_1_code_generation: string;
        Module_code_generation_0_not_supported: string;
        Could_not_find_file_0: string;
        A_file_cannot_have_a_reference_to_itself: string;
        Cannot_resolve_referenced_file_0: string;
        Cannot_find_the_common_subdirectory_path_for_the_input_files: string;
        Emit_Error_0: string;
        Cannot_read_file_0_1: string;
        Unsupported_file_encoding: string;
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: string;
        Unsupported_locale_0: string;
        Execution_Failed_NL: string;
        Should_not_emit_a_type_query: string;
        Should_not_emit_a_type_reference: string;
        Invalid_call_to_up: string;
        Invalid_call_to_down: string;
        Base64_value_0_finished_with_a_continuation_bit: string;
        Key_was_already_in_table: string;
        Unknown_option_0: string;
        Expected_0_arguments_to_message_got_1_instead: string;
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: string;
        Invalid_argument_0_1: string;
        Invalid_argument_0: string;
        Argument_out_of_range_0: string;
        Argument_null_0: string;
        Operation_not_implemented_properly_by_subclass: string;
        Not_yet_implemented: string;
        Invalid_operation_0: string;
        Invalid_operation: string;
        Could_not_delete_file_0: string;
        Could_not_create_directory_0: string;
        Error_while_executing_file_0: string;
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: string;
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: string;
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: string;
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: string;
        Concatenate_and_emit_output_to_single_file: string;
        Generates_corresponding_0_file: string;
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: string;
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: string;
        Watch_input_files: string;
        Redirect_output_structure_to_the_directory: string;
        Do_not_emit_comments_to_output: string;
        Skip_resolution_and_preprocessing: string;
        Specify_ECMAScript_target_version_0_default_or_1: string;
        Specify_module_code_generation_0_or_1: string;
        Print_this_message: string;
        Print_the_compiler_s_version_0: string;
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: string;
        Specify_locale_for_errors_and_messages_For_example_0_or_1: string;
        Syntax_0: string;
        options: string;
        file: string;
        Examples: string;
        Options: string;
        Insert_command_line_options_and_files_from_a_file: string;
        Version_0: string;
        Use_the_0_flag_to_see_options: string;
        NL_Recompiling_0: string;
        STRING: string;
        KIND: string;
        FILE: string;
        VERSION: string;
        LOCATION: string;
        DIRECTORY: string;
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: string;
        Looking_up_path_for_identifier_token_did_not_result_in_an_identifer: string;
        Unknown_rule: string;
        Invalid_line_number_0: string;
        Warn_on_expressions_and_declarations_with_an_implied_any_type: string;
        Variable_0_implicitly_has_an_any_type: string;
        Parameter_0_of_1_implicitly_has_an_any_type: string;
        Parameter_0_of_function_type_implicitly_has_an_any_type: string;
        Member_0_of_object_type_implicitly_has_an_any_type: string;
        New_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: string;
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: string;
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: string;
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: string;
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: string;
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: string;
        Array_Literal_implicitly_has_an_any_type_from_widening: string;
    };
}
declare module TypeScript {
    enum DiagnosticCategory {
        Warning,
        Error,
        Message,
        NoPrefix,
    }
}
declare module TypeScript {
    var diagnosticInformationMap: {
        "error TS{0}: {1}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "warning TS{0}: {1}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unrecognized escape sequence.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unexpected character {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Missing close quote character.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Identifier expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}' keyword expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}' expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Identifier expected; '{0}' is a keyword.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Automatic semicolon insertion not allowed.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unexpected token; '{0}' expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Trailing separator not allowed.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'*/' expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'public' or 'private' modifier must precede 'static'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unexpected token.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Catch clause parameter cannot have a type annotation.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Rest parameter must be last in list.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter cannot have question mark and initializer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Required parameter cannot follow optional parameter.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signatures cannot have rest parameters.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signature parameter cannot have accessibility modifiers.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signature parameter cannot have a question mark.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signature parameter cannot have an initializer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signature must have a type annotation.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signature parameter must have a type annotation.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signature parameter type must be 'string' or 'number'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'extends' clause already seen.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'extends' clause must precede 'implements' clause.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Classes can only extend a single class.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'implements' clause already seen.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Accessibility modifier already seen.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}' modifier must precede '{1}' modifier.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}' modifier already seen.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}' modifier cannot appear on a class element.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Interface declaration cannot have 'implements' clause.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'super' invocation cannot have type arguments.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Only ambient modules can use quoted names.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Statements are not allowed in ambient contexts.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Implementations are not allowed in ambient contexts.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'declare' modifier not allowed for code already in an ambient context.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Initializers are not allowed in ambient contexts.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter property declarations can only be used in constructors.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function implementation expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Constructor implementation expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function overload name must be '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}' modifier cannot appear on a module element.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'declare' modifier cannot appear on an interface declaration.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'declare' modifier required for top level element.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Rest parameter cannot be optional.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Rest parameter cannot have an initializer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'set' accessor must have one and only one parameter.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'set' accessor parameter cannot have accessibility modifier.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'set' accessor parameter cannot be optional.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'set' accessor parameter cannot have an initializer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'set' accessor cannot have rest parameter.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'get' accessor cannot have parameters.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Modifiers cannot appear here.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Accessors are only available when targeting ECMAScript 5 and higher.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class name cannot be '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Interface name cannot be '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Enum name cannot be '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Module name cannot be '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Enum member must have initializer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Export assignment cannot be used in internal modules.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Export assignment not allowed in module with exported element.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Module cannot have multiple export assignments.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Ambient enum elements can only have integer literal initializers.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "module, class, interface, enum, import or statement": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "constructor, function, accessor or variable": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "statement": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "case or default clause": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "identifier": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "call, construct, index, property or function signature": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "expression": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "type name": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "property or accessor": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "parameter": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "type": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "type parameter": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'declare' modifier not allowed on import declaration.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function overload must be static": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function overload must not be static": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter property declarations cannot be used in an ambient context.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter property declarations cannot be used in a constructor overload.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Duplicate identifier '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The name '{0}' does not exist in the current scope.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The name '{0}' does not refer to a value.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'super' can only be used inside a class instance method.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The left-hand side of an assignment expression must be a variable, property or indexer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Value of type '{0}' is not callable.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Value of type '{0}' is not newable.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Value of type '{0}' is not indexable by type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot convert '{0}' to '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot convert '{0}' to '{1}':{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Expected var, class, interface, or module.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Operator '{0}' cannot be applied to type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Getter '{0}' already declared.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Setter '{0}' already declared.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Accessors cannot have type parameters.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported class '{0}' extends private class '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported class '{0}' implements private interface '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported interface '{0}' extends private interface '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported class '{0}' extends class from inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported class '{0}' implements interface from inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported interface '{0}' extends interface from inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Public static property '{0}' of exported class has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Public property '{0}' of exported class has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Property '{0}' of exported interface has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported variable '{0}' has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Public static property '{0}' of exported class is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Public property '{0}' of exported class is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Property '{0}' of exported interface is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported variable '{0}' is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of exported function has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of exported function is using inaccessible module {1}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public static property getter from exported class has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public property getter from exported class has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of call signature from exported interface has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of index signature from exported interface has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public static method from exported class has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public method from exported class has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of method from exported interface has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of exported function has or is using private type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public static property getter from exported class is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public property getter from exported class is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of call signature from exported interface is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of index signature from exported interface is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public static method from exported class is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of public method from exported class is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of method from exported interface is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Return type of exported function is using inaccessible module {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "A parameter list must follow a generic type argument list. '(' expected.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Multiple constructor implementations are not allowed.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unable to resolve external module '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Module cannot be aliased to a non-module type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "A class may only extend another class.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "A class may only implement another class or interface.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "An interface may only extend another class or interface.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "An interface cannot implement another type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unable to resolve type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unable to resolve type of '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unable to resolve type parameter constraint.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type parameter constraint cannot be a primitive type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Supplied parameters do not match any signature of call target.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Supplied parameters do not match any signature of call target:{NL}{0}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid 'new' expression.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Call signatures used in a 'new' expression must have a 'void' return type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not select overload for 'new' expression.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not select overload for 'call' expression.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot invoke an expression whose type lacks a call signature.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Calls to 'super' are only valid inside a class.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Generic type '{0}' requires {1} type argument(s).": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type of conditional expression cannot be determined. Best common type could not be found between '{0}' and '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not find enclosing symbol for dotted name '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The property '{0}' does not exist on value of type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not find symbol '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'get' and 'set' accessor must have the same type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'this' cannot be referenced in current location.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Static methods cannot reference class type parameters.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class '{0}' is recursively referenced as a base type of itself.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Interface '{0}' is recursively referenced as a base type of itself.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'super' property access is permitted only in a constructor, instance member function, or instance member accessor of a derived class.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'super' cannot be referenced in non-derived classes.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Constructors for derived classes must contain a 'super' call.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Super calls are not permitted outside constructors or in local functions inside constructors.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}.{1}' is inaccessible.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'this' cannot be referenced within module bodies.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid '+' expression - types not known to support the addition operator.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Variable declarations of a 'for' statement cannot use a type annotation.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The left-hand side of an 'in' expression must be of types 'string' or 'any'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The right-hand side of an 'instanceof' expression must be of type 'any' or a subtype of the 'Function' interface type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Setters cannot return a value.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Tried to query type of uninitialized module '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Tried to set variable type to uninitialized module type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function '{0}' declared a non-void return type, but has no return expression.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Getters must return a value.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Getter and setter accessors do not agree in visibility.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid left-hand side of assignment expression.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function declared a non-void return type, but has no return expression.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot resolve return type reference.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Constructors cannot have a return type of 'void'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "All symbols within a with block will be resolved to 'any'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Import declarations in an internal module cannot reference an external module.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "The operand of an increment or decrement operator must be a variable, property or indexer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'this' cannot be referenced in static initializers in a class body.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Duplicate overload signature for '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Duplicate constructor overload signature.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Duplicate overload call signature.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Duplicate overload construct signature.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overload signature is not compatible with function definition.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overload signature is not compatible with function definition:{NL}{0}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overload signatures must all be public or private.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overload signatures must all be exported or local.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overload signatures must all be ambient or non-ambient.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overload signatures must all be optional or required.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Specialized overload signature is not subtype of any non-specialized signature.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'this' cannot be referenced in constructor arguments.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Static member cannot be accessed off an instance variable.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Instance member cannot be accessed off a class.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Untyped function calls may not accept type arguments.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Non-generic functions may not accept type arguments.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "A generic type may not reference itself with a wrapped form of its own type parameters.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Rest parameters must be array types.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overload signature implementation cannot use specialized type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Export assignments may only be used at the top-level of external modules.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Only public instance methods of the base class are accessible via the 'super' keyword.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "All numerically named properties must be subtypes of numeric indexer type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "All named properties must be subtypes of string indexer type '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "All named properties must be subtypes of string indexer type '{0}':{NL}{1}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Generic type references must include all type arguments.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Default arguments are not allowed in an overload parameter.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Overloads cannot differ only by return type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function expression declared a non-void return type, but has no return expression.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not find symbol '{0}' in module '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unable to resolve module reference '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not find module '{0}' in module '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type reference '{0}' in extends clause doesn't reference constructor function for '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Internal module reference '{0}' in import declaration doesn't reference module instance for '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type '{0}' is missing property '{1}' from type '{2}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Types '{0}' and '{1}' define property '{2}' as private.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Call signatures of types '{0}' and '{1}' are incompatible.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Construct signatures of types '{0}' and '{1}' are incompatible.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signatures of types '{0}' and '{1}' are incompatible.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Call signature expects {0} or fewer parameters.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type reference cannot refer to container '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Type reference must refer to type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Enums with multiple declarations must provide an initializer for the first enum element.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        " (+ {0} overload(s))": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Current host does not support '{0}' option.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "ECMAScript target version '{0}' not supported.  Using default '{1}' code generation.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Module code generation '{0}' not supported.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not find file: '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "A file cannot have a reference to itself.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot resolve referenced file: '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot find the common subdirectory path for the input files.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Emit Error: {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot read file '{0}': {1}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unsupported file encoding.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unsupported locale: '{0}'.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Execution Failed.{NL}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Should not emit a type query": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Should not emit a type reference": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid call to 'up'": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid call to 'down'": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Base64 value '{0}' finished with a continuation bit": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Key was already in table": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unknown option '{0}'": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Expected {0} arguments to message, got {1} instead": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Expected the message '{0}' to have {1} arguments, but it had {2}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid argument: {0}. {1}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid argument: {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Argument out of range: {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Argument null: {0}.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Operation not implemented properly by subclass.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Not yet implemented.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid operation: {0}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid operation.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not delete file '{0}'": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Could not create directory '{0}'": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Error while executing file '{0}': ": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Cannot compile external modules unless the '--module' flag is provided.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Option mapRoot cannot be specified without specifying sourcemap option.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Option sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Concatenate and emit output to single file": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Generates corresponding {0} file": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Specifies the location where debugger should locate map files instead of generated locations.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Watch input files": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Redirect output structure to the directory": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Do not emit comments to output": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Skip resolution and preprocessing": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Specify ECMAScript target version: \"{0}\" (default), or \"{1}\"": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Specify module code generation: \"{0}\" or \"{1}\"": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Print this message": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Print the compiler's version: {0}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Allow use of deprecated \"{0}\" keyword when referencing an external module": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Specify locale for errors and messages. For example '{0}' or '{1}'": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Syntax:   {0}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "options": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "file": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Examples:": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Options:": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Insert command line options and files from a file.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Version {0}": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Use the '{0}' flag to see options": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "{NL}Recompiling ({0}):": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "STRING": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "KIND": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "FILE": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "VERSION": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "LOCATION": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "DIRECTORY": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "This version of the Javascript runtime does not support the '{0}' function.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Looking up path for identifier token did not result in an identifer.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Unknown rule": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Invalid line number ({0})": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Warn on expressions and declarations with an implied 'any' type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Variable '{0}' implicitly has an 'any' type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of function type implicitly has an 'any' type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Member '{0}' of object type implicitly has an 'any' type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "\"New\" expression, which lacks a constructor signature, implicitly has an 'any' type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": number;
            "category": DiagnosticCategory;
        };
        "Array Literal implicitly has an 'any' type from widening.": {
            "code": number;
            "category": DiagnosticCategory;
        };
    };
}
declare module TypeScript {
    class ArrayUtilities {
        static isArray(value: any): boolean;
        static sequenceEquals(array1: any[], array2: any[], equals: (v1: any, v2: any) => boolean): boolean;
        static contains(array: any[], value: any): boolean;
        static groupBy(array: any[], func: (v: any) => string): any;
        static min(array: any[], func: (v: any) => number): number;
        static max(array: any[], func: (v: any) => number): number;
        static last<T>(array: T[]): T;
        static firstOrDefault<T>(array: T[], func: (v: T) => boolean): T;
        static sum<T>(array: T[], func: (v: T) => number): number;
        static whereNotNull<T>(array: T[]): T[];
        static select<T, S>(values: T[], func: (v: T) => S): S[];
        static where<T>(values: T[], func: (v: T) => boolean): T[];
        static any<T>(array: T[], func: (v: T) => boolean): boolean;
        static all<T>(array: T[], func: (v: T) => boolean): boolean;
        static binarySearch(array: number[], value: number): number;
        static createArray<T>(length: number, defaultValue: any): T[];
        static grow<T>(array: T[], length: number, defaultValue: T): void;
        static copy<T>(sourceArray: T[], sourceIndex: number, destinationArray: T[], destinationIndex: number, length: number): void;
    }
}
declare module TypeScript {
    enum Constants {
        Max31BitInteger,
        Min31BitInteger,
    }
}
declare module TypeScript {
    class Debug {
        static assert(expression: boolean, message?: string): void;
    }
}
declare module TypeScript {
    interface DiagnosticInfo {
        category: TypeScript.DiagnosticCategory;
        message: string;
        code: number;
    }
}
declare module TypeScript {
    class Errors {
        static argument(argument: string, message?: string): Error;
        static argumentOutOfRange(argument: string): Error;
        static argumentNull(argument: string): Error;
        static abstract(): Error;
        static notYetImplemented(): Error;
        static invalidOperation(message?: string): Error;
    }
}
declare module TypeScript {
    class Hash {
        private static FNV_BASE;
        private static FNV_PRIME;
        private static computeFnv1aCharArrayHashCode(text, start, len);
        static computeSimple31BitCharArrayHashCode(key: number[], start: number, len: number): number;
        static computeSimple31BitStringHashCode(key: string): number;
        static computeMurmur2StringHashCode(key: string, seed: number): number;
        private static primes;
        static getPrime(min: number): number;
        static expandPrime(oldSize: number): number;
        static combine(value: number, currentHash: number): number;
    }
}
declare module TypeScript.Collections {
    var DefaultHashTableCapacity: number;
    class HashTable<TKey, TValue> {
        private hash;
        private entries;
        private count;
        constructor(capacity: number, hash: (k: TKey) => number);
        public set(key: TKey, value: TValue): void;
        public add(key: TKey, value: TValue): void;
        public containsKey(key: TKey): boolean;
        public get(key: TKey): TValue;
        private computeHashCode(key);
        private addOrSet(key, value, throwOnExistingEntry);
        private findEntry(key, hashCode);
        private addEntry(key, value, hashCode);
        private grow();
    }
    function createHashTable<TKey, TValue>(capacity?: number, hash?: (k: TKey) => number): HashTable<TKey, TValue>;
    function identityHashCode(value: any): number;
}
declare module TypeScript {
    var LocalizedDiagnosticMessages: any;
    function newLine(): string;
    class Diagnostic {
        private _fileName;
        private _start;
        private _length;
        private _diagnosticKey;
        private _arguments;
        constructor(fileName: string, start: number, length: number, diagnosticKey: string, arguments?: any[]);
        public toJSON(key: any): any;
        public fileName(): string;
        public start(): number;
        public length(): number;
        public diagnosticKey(): string;
        public arguments(): any[];
        public text(): string;
        public message(): string;
        public additionalLocations(): Location[];
        static equals(diagnostic1: Diagnostic, diagnostic2: Diagnostic): boolean;
    }
    function getDiagnosticInfoFromKey(diagnosticKey: string): DiagnosticInfo;
    function getLocalizedText(diagnosticKey: string, args: any[]): string;
    function getDiagnosticMessage(diagnosticKey: string, args: any[]): string;
}
declare class Enumerator {
    public atEnd(): boolean;
    public moveNext(): boolean;
    public item(): any;
    constructor(o: any);
}
declare module process {
    var argv: string[];
    var platform: string;
    function on(event: string, handler: (arg: any) => void): void;
    module stdout {
        function write(str: string): any;
        function on(event: string, action: () => void): void;
    }
    module stderr {
        function write(str: string): any;
        function on(event: string, action: () => void): void;
    }
    module mainModule {
        var filename: string;
    }
    function exit(exitCode?: number): any;
}
declare module TypeScript {
    var nodeMakeDirectoryTime: number;
    var nodeCreateBufferTime: number;
    var nodeWriteFileSyncTime: number;
}
declare enum ByteOrderMark {
    None,
    Utf8,
    Utf16BigEndian,
    Utf16LittleEndian,
}
declare class FileInformation {
    public contents: string;
    public byteOrderMark: ByteOrderMark;
    constructor(contents: string, byteOrderMark: ByteOrderMark);
}
interface IEnvironment {
    readFile(path: string): FileInformation;
    writeFile(path: string, contents: string, writeByteOrderMark: boolean): void;
    deleteFile(path: string): void;
    fileExists(path: string): boolean;
    directoryExists(path: string): boolean;
    listFiles(path: string, re?: RegExp, options?: {
        recursive?: boolean;
    }): string[];
    arguments: string[];
    standardOut: ITextWriter;
    currentDirectory(): string;
    newLine: string;
}
declare var Environment: IEnvironment;
declare module TypeScript {
    class IntegerUtilities {
        static integerDivide(numerator: number, denominator: number): number;
        static integerMultiplyLow32Bits(n1: number, n2: number): number;
        static integerMultiplyHigh32Bits(n1: number, n2: number): number;
    }
}
declare module TypeScript {
    class MathPrototype {
        static max(a: number, b: number): number;
        static min(a: number, b: number): number;
    }
}
declare module TypeScript.Collections {
    var DefaultStringTableCapacity: number;
    class StringTable {
        private entries;
        private count;
        constructor(capacity: number);
        public addCharArray(key: number[], start: number, len: number): string;
        private findCharArrayEntry(key, start, len, hashCode);
        private addEntry(text, hashCode);
        private grow();
        private static textCharArrayEquals(text, array, start, length);
    }
    var DefaultStringTable: StringTable;
}
declare module TypeScript {
    class StringUtilities {
        static isString(value: any): boolean;
        static fromCharCodeArray(array: number[]): string;
        static endsWith(string: string, value: string): boolean;
        static startsWith(string: string, value: string): boolean;
        static copyTo(source: string, sourceIndex: number, destination: number[], destinationIndex: number, count: number): void;
        static repeat(value: string, count: number): string;
        static stringEquals(val1: string, val2: string): boolean;
    }
}
declare var global: any;
declare module TypeScript {
    class Timer {
        public startTime: number;
        public time: number;
        public start(): void;
        public end(): void;
    }
}
declare module TypeScript {
    enum CharacterCodes {
        nullCharacter,
        maxAsciiCharacter,
        lineFeed,
        carriageReturn,
        lineSeparator,
        paragraphSeparator,
        nextLine,
        space,
        nonBreakingSpace,
        enQuad,
        emQuad,
        enSpace,
        emSpace,
        threePerEmSpace,
        fourPerEmSpace,
        sixPerEmSpace,
        figureSpace,
        punctuationSpace,
        thinSpace,
        hairSpace,
        zeroWidthSpace,
        narrowNoBreakSpace,
        ideographicSpace,
        _,
        $,
        _0,
        _9,
        a,
        b,
        c,
        d,
        e,
        f,
        g,
        h,
        i,
        k,
        l,
        m,
        n,
        o,
        p,
        q,
        r,
        s,
        t,
        u,
        v,
        w,
        x,
        y,
        z,
        A,
        E,
        F,
        X,
        Z,
        ampersand,
        asterisk,
        at,
        backslash,
        bar,
        caret,
        closeBrace,
        closeBracket,
        closeParen,
        colon,
        comma,
        dot,
        doubleQuote,
        equals,
        exclamation,
        greaterThan,
        lessThan,
        minus,
        openBrace,
        openBracket,
        openParen,
        percent,
        plus,
        question,
        semicolon,
        singleQuote,
        slash,
        tilde,
        backspace,
        formFeed,
        byteOrderMark,
        tab,
        verticalTab,
    }
}
declare module TypeScript {
    interface ILineAndCharacter {
        line: number;
        character: number;
    }
}
declare module TypeScript {
    interface IScriptSnapshot {
        getText(start: number, end: number): string;
        getLength(): number;
        getLineStartPositions(): number[];
        getTextChangeRangeSinceVersion(scriptVersion: number): TypeScript.TextChangeRange;
    }
    module ScriptSnapshot {
        function fromString(text: string): IScriptSnapshot;
    }
}
declare module TypeScript {
    interface ISimpleText {
        length(): number;
        copyTo(sourceIndex: number, destination: number[], destinationIndex: number, count: number): void;
        substr(start: number, length: number, intern: boolean): string;
        subText(span: TypeScript.TextSpan): ISimpleText;
        charCodeAt(index: number): number;
        lineMap(): TypeScript.LineMap;
    }
    interface IText extends ISimpleText {
        lineCount(): number;
        lines(): TypeScript.ITextLine[];
        charCodeAt(position: number): number;
        getLineFromLineNumber(lineNumber: number): TypeScript.ITextLine;
        getLineFromPosition(position: number): TypeScript.ITextLine;
        getLineNumberFromPosition(position: number): number;
        getLinePosition(position: number): TypeScript.LineAndCharacter;
        toString(span?: TypeScript.TextSpan): string;
    }
}
declare module TypeScript {
    interface ITextLine {
        start(): number;
        end(): number;
        endIncludingLineBreak(): number;
        extent(): TypeScript.TextSpan;
        extentIncludingLineBreak(): TypeScript.TextSpan;
        toString(): string;
        lineNumber(): number;
    }
}
declare module TypeScript {
    class LineMap {
        private _lineStarts;
        private length;
        static empty: LineMap;
        constructor(_lineStarts: number[], length: number);
        public toJSON(key: any): {
            lineStarts: number[];
            length: number;
        };
        public equals(other: LineMap): boolean;
        public lineStarts(): number[];
        public lineCount(): number;
        public getPosition(line: number, character: number): number;
        public getLineNumberFromPosition(position: number): number;
        public getLineStartPosition(lineNumber: number): number;
        public fillLineAndCharacterFromPosition(position: number, lineAndCharacter: TypeScript.ILineAndCharacter): void;
        public getLineAndCharacterFromPosition(position: number): TypeScript.LineAndCharacter;
        static fromSimpleText(text: TypeScript.ISimpleText): LineMap;
        static fromScriptSnapshot(scriptSnapshot: TypeScript.IScriptSnapshot): LineMap;
        static fromString(text: string): LineMap;
    }
}
declare module TypeScript {
    class LineAndCharacter {
        private _line;
        private _character;
        constructor(line: number, character: number);
        public line(): number;
        public character(): number;
    }
}
declare module TypeScript.TextFactory {
    function createText(value: string): TypeScript.IText;
}
declare module TypeScript.SimpleText {
    function fromString(value: string): TypeScript.ISimpleText;
    function fromScriptSnapshot(scriptSnapshot: TypeScript.IScriptSnapshot): TypeScript.ISimpleText;
}
declare module TypeScript.TextUtilities {
    function parseLineStarts(text: TypeScript.ISimpleText): number[];
    function getLengthOfLineBreakSlow(text: TypeScript.ISimpleText, index: number, c: number): number;
    function getLengthOfLineBreak(text: TypeScript.ISimpleText, index: number): number;
    function isAnyLineBreakCharacter(c: number): boolean;
}
declare module TypeScript {
    class TextSpan {
        private _start;
        private _length;
        constructor(start: number, length: number);
        public start(): number;
        public length(): number;
        public end(): number;
        public isEmpty(): boolean;
        public containsPosition(position: number): boolean;
        public containsTextSpan(span: TextSpan): boolean;
        public overlapsWith(span: TextSpan): boolean;
        public overlap(span: TextSpan): TextSpan;
        public intersectsWithTextSpan(span: TextSpan): boolean;
        public intersectsWith(start: number, length: number): boolean;
        public intersectsWithPosition(position: number): boolean;
        public intersection(span: TextSpan): TextSpan;
        static fromBounds(start: number, end: number): TextSpan;
    }
}
declare module TypeScript {
    class TextChangeRange {
        static unchanged: TextChangeRange;
        private _span;
        private _newLength;
        constructor(span: TypeScript.TextSpan, newLength: number);
        public span(): TypeScript.TextSpan;
        public newLength(): number;
        public newSpan(): TypeScript.TextSpan;
        public isUnchanged(): boolean;
        static collapseChangesFromSingleVersion(changes: TextChangeRange[]): TextChangeRange;
        static collapseChangesAcrossMultipleVersions(changes: TextChangeRange[]): TextChangeRange;
    }
}
declare module TypeScript {
    class CharacterInfo {
        static isDecimalDigit(c: number): boolean;
        static isHexDigit(c: number): boolean;
        static hexValue(c: number): number;
        static isWhitespace(ch: number): boolean;
        static isLineTerminator(ch: number): boolean;
    }
}
declare module TypeScript {
    enum SyntaxConstants {
        TriviaNewLineMask,
        TriviaCommentMask,
        TriviaFullWidthShift,
        NodeDataComputed,
        NodeIncrementallyUnusableMask,
        NodeParsedInStrictModeMask,
        NodeFullWidthShift,
    }
}
declare class FormattingOptions {
    public useTabs: boolean;
    public spacesPerTab: number;
    public indentSpaces: number;
    public newLineCharacter: string;
    constructor(useTabs: boolean, spacesPerTab: number, indentSpaces: number, newLineCharacter: string);
    static defaultOptions: FormattingOptions;
}
declare module TypeScript.Indentation {
    function columnForEndOfToken(token: TypeScript.ISyntaxToken, syntaxInformationMap: TypeScript.SyntaxInformationMap, options: FormattingOptions): number;
    function columnForStartOfToken(token: TypeScript.ISyntaxToken, syntaxInformationMap: TypeScript.SyntaxInformationMap, options: FormattingOptions): number;
    function columnForStartOfFirstTokenInLineContainingToken(token: TypeScript.ISyntaxToken, syntaxInformationMap: TypeScript.SyntaxInformationMap, options: FormattingOptions): number;
    function columnForPositionInString(input: string, position: number, options: FormattingOptions): number;
    function indentationString(column: number, options: FormattingOptions): string;
    function indentationTrivia(column: number, options: FormattingOptions): TypeScript.ISyntaxTrivia;
    function firstNonWhitespacePosition(value: string): number;
}
declare module TypeScript {
    enum LanguageVersion {
        EcmaScript3,
        EcmaScript5,
    }
}
declare module TypeScript {
    class ParseOptions {
        private _languageVersion;
        private _allowAutomaticSemicolonInsertion;
        constructor(languageVersion: TypeScript.LanguageVersion, allowAutomaticSemicolonInsertion: boolean);
        public toJSON(key: any): {
            allowAutomaticSemicolonInsertion: boolean;
        };
        public languageVersion(): TypeScript.LanguageVersion;
        public allowAutomaticSemicolonInsertion(): boolean;
    }
}
declare module TypeScript {
    class PositionedElement {
        private _parent;
        private _element;
        private _fullStart;
        constructor(parent: PositionedElement, element: TypeScript.ISyntaxElement, fullStart: number);
        static create(parent: PositionedElement, element: TypeScript.ISyntaxElement, fullStart: number): PositionedElement;
        public parent(): PositionedElement;
        public parentElement(): TypeScript.ISyntaxElement;
        public element(): TypeScript.ISyntaxElement;
        public kind(): TypeScript.SyntaxKind;
        public childIndex(child: TypeScript.ISyntaxElement): number;
        public childCount(): number;
        public childAt(index: number): PositionedElement;
        public childStart(child: TypeScript.ISyntaxElement): number;
        public childEnd(child: TypeScript.ISyntaxElement): number;
        public childStartAt(index: number): number;
        public childEndAt(index: number): number;
        public getPositionedChild(child: TypeScript.ISyntaxElement): PositionedElement;
        public fullStart(): number;
        public fullEnd(): number;
        public fullWidth(): number;
        public start(): number;
        public end(): number;
        public root(): PositionedNode;
        public containingNode(): PositionedNode;
    }
    class PositionedNodeOrToken extends PositionedElement {
        constructor(parent: PositionedElement, nodeOrToken: TypeScript.ISyntaxNodeOrToken, fullStart: number);
        public nodeOrToken(): TypeScript.ISyntaxNodeOrToken;
    }
    class PositionedNode extends PositionedNodeOrToken {
        constructor(parent: PositionedElement, node: TypeScript.SyntaxNode, fullStart: number);
        public node(): TypeScript.SyntaxNode;
    }
    class PositionedToken extends PositionedNodeOrToken {
        constructor(parent: PositionedElement, token: TypeScript.ISyntaxToken, fullStart: number);
        public token(): TypeScript.ISyntaxToken;
        public previousToken(includeSkippedTokens?: boolean): PositionedToken;
        public nextToken(includeSkippedTokens?: boolean): PositionedToken;
    }
    class PositionedList extends PositionedElement {
        constructor(parent: PositionedElement, list: TypeScript.ISyntaxList, fullStart: number);
        public list(): TypeScript.ISyntaxList;
    }
    class PositionedSeparatedList extends PositionedElement {
        constructor(parent: PositionedElement, list: TypeScript.ISeparatedSyntaxList, fullStart: number);
        public list(): TypeScript.ISeparatedSyntaxList;
    }
    class PositionedSkippedToken extends PositionedToken {
        private _parentToken;
        constructor(parentToken: PositionedToken, token: TypeScript.ISyntaxToken, fullStart: number);
        public parentToken(): PositionedToken;
        public previousToken(includeSkippedTokens?: boolean): PositionedToken;
        public nextToken(includeSkippedTokens?: boolean): PositionedToken;
    }
}
declare module TypeScript {
    enum SyntaxKind {
        None,
        List,
        SeparatedList,
        TriviaList,
        WhitespaceTrivia,
        NewLineTrivia,
        MultiLineCommentTrivia,
        SingleLineCommentTrivia,
        SkippedTokenTrivia,
        ErrorToken,
        EndOfFileToken,
        IdentifierName,
        RegularExpressionLiteral,
        NumericLiteral,
        StringLiteral,
        BreakKeyword,
        CaseKeyword,
        CatchKeyword,
        ContinueKeyword,
        DebuggerKeyword,
        DefaultKeyword,
        DeleteKeyword,
        DoKeyword,
        ElseKeyword,
        FalseKeyword,
        FinallyKeyword,
        ForKeyword,
        FunctionKeyword,
        IfKeyword,
        InKeyword,
        InstanceOfKeyword,
        NewKeyword,
        NullKeyword,
        ReturnKeyword,
        SwitchKeyword,
        ThisKeyword,
        ThrowKeyword,
        TrueKeyword,
        TryKeyword,
        TypeOfKeyword,
        VarKeyword,
        VoidKeyword,
        WhileKeyword,
        WithKeyword,
        ClassKeyword,
        ConstKeyword,
        EnumKeyword,
        ExportKeyword,
        ExtendsKeyword,
        ImportKeyword,
        SuperKeyword,
        ImplementsKeyword,
        InterfaceKeyword,
        LetKeyword,
        PackageKeyword,
        PrivateKeyword,
        ProtectedKeyword,
        PublicKeyword,
        StaticKeyword,
        YieldKeyword,
        AnyKeyword,
        BooleanKeyword,
        ConstructorKeyword,
        DeclareKeyword,
        GetKeyword,
        ModuleKeyword,
        RequireKeyword,
        NumberKeyword,
        SetKeyword,
        StringKeyword,
        OpenBraceToken,
        CloseBraceToken,
        OpenParenToken,
        CloseParenToken,
        OpenBracketToken,
        CloseBracketToken,
        DotToken,
        DotDotDotToken,
        SemicolonToken,
        CommaToken,
        LessThanToken,
        GreaterThanToken,
        LessThanEqualsToken,
        GreaterThanEqualsToken,
        EqualsEqualsToken,
        EqualsGreaterThanToken,
        ExclamationEqualsToken,
        EqualsEqualsEqualsToken,
        ExclamationEqualsEqualsToken,
        PlusToken,
        MinusToken,
        AsteriskToken,
        PercentToken,
        PlusPlusToken,
        MinusMinusToken,
        LessThanLessThanToken,
        GreaterThanGreaterThanToken,
        GreaterThanGreaterThanGreaterThanToken,
        AmpersandToken,
        BarToken,
        CaretToken,
        ExclamationToken,
        TildeToken,
        AmpersandAmpersandToken,
        BarBarToken,
        QuestionToken,
        ColonToken,
        EqualsToken,
        PlusEqualsToken,
        MinusEqualsToken,
        AsteriskEqualsToken,
        PercentEqualsToken,
        LessThanLessThanEqualsToken,
        GreaterThanGreaterThanEqualsToken,
        GreaterThanGreaterThanGreaterThanEqualsToken,
        AmpersandEqualsToken,
        BarEqualsToken,
        CaretEqualsToken,
        SlashToken,
        SlashEqualsToken,
        SourceUnit,
        QualifiedName,
        ObjectType,
        FunctionType,
        ArrayType,
        ConstructorType,
        GenericType,
        TypeQuery,
        InterfaceDeclaration,
        FunctionDeclaration,
        ModuleDeclaration,
        ClassDeclaration,
        EnumDeclaration,
        ImportDeclaration,
        ExportAssignment,
        MemberFunctionDeclaration,
        MemberVariableDeclaration,
        ConstructorDeclaration,
        GetMemberAccessorDeclaration,
        SetMemberAccessorDeclaration,
        PropertySignature,
        CallSignature,
        ConstructSignature,
        IndexSignature,
        MethodSignature,
        Block,
        IfStatement,
        VariableStatement,
        ExpressionStatement,
        ReturnStatement,
        SwitchStatement,
        BreakStatement,
        ContinueStatement,
        ForStatement,
        ForInStatement,
        EmptyStatement,
        ThrowStatement,
        WhileStatement,
        TryStatement,
        LabeledStatement,
        DoStatement,
        DebuggerStatement,
        WithStatement,
        PlusExpression,
        NegateExpression,
        BitwiseNotExpression,
        LogicalNotExpression,
        PreIncrementExpression,
        PreDecrementExpression,
        DeleteExpression,
        TypeOfExpression,
        VoidExpression,
        CommaExpression,
        AssignmentExpression,
        AddAssignmentExpression,
        SubtractAssignmentExpression,
        MultiplyAssignmentExpression,
        DivideAssignmentExpression,
        ModuloAssignmentExpression,
        AndAssignmentExpression,
        ExclusiveOrAssignmentExpression,
        OrAssignmentExpression,
        LeftShiftAssignmentExpression,
        SignedRightShiftAssignmentExpression,
        UnsignedRightShiftAssignmentExpression,
        ConditionalExpression,
        LogicalOrExpression,
        LogicalAndExpression,
        BitwiseOrExpression,
        BitwiseExclusiveOrExpression,
        BitwiseAndExpression,
        EqualsWithTypeConversionExpression,
        NotEqualsWithTypeConversionExpression,
        EqualsExpression,
        NotEqualsExpression,
        LessThanExpression,
        GreaterThanExpression,
        LessThanOrEqualExpression,
        GreaterThanOrEqualExpression,
        InstanceOfExpression,
        InExpression,
        LeftShiftExpression,
        SignedRightShiftExpression,
        UnsignedRightShiftExpression,
        MultiplyExpression,
        DivideExpression,
        ModuloExpression,
        AddExpression,
        SubtractExpression,
        PostIncrementExpression,
        PostDecrementExpression,
        MemberAccessExpression,
        InvocationExpression,
        ArrayLiteralExpression,
        ObjectLiteralExpression,
        ObjectCreationExpression,
        ParenthesizedExpression,
        ParenthesizedArrowFunctionExpression,
        SimpleArrowFunctionExpression,
        CastExpression,
        ElementAccessExpression,
        FunctionExpression,
        OmittedExpression,
        VariableDeclaration,
        VariableDeclarator,
        ArgumentList,
        ParameterList,
        TypeArgumentList,
        TypeParameterList,
        HeritageClause,
        EqualsValueClause,
        CaseSwitchClause,
        DefaultSwitchClause,
        ElseClause,
        CatchClause,
        FinallyClause,
        TypeParameter,
        Constraint,
        SimplePropertyAssignment,
        GetAccessorPropertyAssignment,
        SetAccessorPropertyAssignment,
        FunctionPropertyAssignment,
        Parameter,
        EnumElement,
        TypeAnnotation,
        ExternalModuleReference,
        ModuleNameModuleReference,
        FirstStandardKeyword,
        LastStandardKeyword,
        FirstFutureReservedKeyword,
        LastFutureReservedKeyword,
        FirstFutureReservedStrictKeyword,
        LastFutureReservedStrictKeyword,
        FirstTypeScriptKeyword,
        LastTypeScriptKeyword,
        FirstKeyword,
        LastKeyword,
        FirstToken,
        LastToken,
        FirstPunctuation,
        LastPunctuation,
        FirstFixedWidth,
        LastFixedWidth,
    }
}
declare module TypeScript.SyntaxFacts {
    function getTokenKind(text: string): TypeScript.SyntaxKind;
    function getText(kind: TypeScript.SyntaxKind): string;
    function isTokenKind(kind: TypeScript.SyntaxKind): boolean;
    function isAnyKeyword(kind: TypeScript.SyntaxKind): boolean;
    function isStandardKeyword(kind: TypeScript.SyntaxKind): boolean;
    function isFutureReservedKeyword(kind: TypeScript.SyntaxKind): boolean;
    function isFutureReservedStrictKeyword(kind: TypeScript.SyntaxKind): boolean;
    function isAnyPunctuation(kind: TypeScript.SyntaxKind): boolean;
    function isPrefixUnaryExpressionOperatorToken(tokenKind: TypeScript.SyntaxKind): boolean;
    function isBinaryExpressionOperatorToken(tokenKind: TypeScript.SyntaxKind): boolean;
    function getPrefixUnaryExpressionFromOperatorToken(tokenKind: TypeScript.SyntaxKind): TypeScript.SyntaxKind;
    function getPostfixUnaryExpressionFromOperatorToken(tokenKind: TypeScript.SyntaxKind): TypeScript.SyntaxKind;
    function getBinaryExpressionFromOperatorToken(tokenKind: TypeScript.SyntaxKind): TypeScript.SyntaxKind;
    function isAnyDivideToken(kind: TypeScript.SyntaxKind): boolean;
    function isAnyDivideOrRegularExpressionToken(kind: TypeScript.SyntaxKind): boolean;
    function isParserGenerated(kind: TypeScript.SyntaxKind): boolean;
    function isAnyBinaryExpression(kind: TypeScript.SyntaxKind): boolean;
}
declare module TypeScript {
    class Scanner implements TypeScript.ISlidingWindowSource {
        private slidingWindow;
        private fileName;
        private text;
        private _languageVersion;
        constructor(fileName: string, text: TypeScript.ISimpleText, languageVersion: TypeScript.LanguageVersion, window?: number[]);
        public languageVersion(): TypeScript.LanguageVersion;
        public fetchMoreItems(argument: any, sourceIndex: number, window: number[], destinationIndex: number, spaceAvailable: number): number;
        private currentCharCode();
        public absoluteIndex(): number;
        public setAbsoluteIndex(index: number): void;
        public scan(diagnostics: TypeScript.Diagnostic[], allowRegularExpression: boolean): TypeScript.ISyntaxToken;
        private createToken(fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo);
        private static triviaWindow;
        static scanTrivia(text: TypeScript.ISimpleText, start: number, length: number, isTrailing: boolean): TypeScript.ISyntaxTriviaList;
        private scanTrivia(isTrailing);
        private scanTriviaInfo(diagnostics, isTrailing);
        private isNewLineCharacter(ch);
        private scanWhitespaceTrivia();
        private scanSingleLineCommentTrivia();
        private scanSingleLineCommentTriviaLength();
        private scanMultiLineCommentTrivia();
        private scanMultiLineCommentTriviaLength(diagnostics);
        private scanLineTerminatorSequenceTrivia(ch);
        private scanLineTerminatorSequenceLength(ch);
        private scanSyntaxToken(diagnostics, allowRegularExpression);
        private isIdentifierStart(interpretedChar);
        private isIdentifierPart(interpretedChar);
        private tryFastScanIdentifierOrKeyword(firstCharacter);
        private slowScanIdentifier(diagnostics);
        private scanNumericLiteral();
        private scanDecimalNumericLiteral();
        private scanHexNumericLiteral();
        private isHexNumericLiteral();
        private advanceAndSetTokenKind(kind);
        private scanLessThanToken();
        private scanBarToken();
        private scanCaretToken();
        private scanAmpersandToken();
        private scanPercentToken();
        private scanMinusToken();
        private scanPlusToken();
        private scanAsteriskToken();
        private scanEqualsToken();
        private isDotPrefixedNumericLiteral();
        private scanDotToken();
        private scanSlashToken(allowRegularExpression);
        private tryScanRegularExpressionToken();
        private scanExclamationToken();
        private scanDefaultCharacter(character, diagnostics);
        private getErrorMessageText(text);
        private skipEscapeSequence(diagnostics);
        private scanStringLiteral(diagnostics);
        private isUnicodeOrHexEscape(character);
        private isUnicodeEscape(character);
        private isHexEscape(character);
        private peekCharOrUnicodeOrHexEscape();
        private peekCharOrUnicodeEscape();
        private peekUnicodeOrHexEscape();
        private scanCharOrUnicodeEscape(errors);
        private scanCharOrUnicodeOrHexEscape(errors);
        private scanUnicodeOrHexEscape(errors);
        public substring(start: number, end: number, intern: boolean): string;
        private createIllegalEscapeDiagnostic(start, end);
        static isValidIdentifier(text: TypeScript.ISimpleText, languageVersion: TypeScript.LanguageVersion): boolean;
    }
}
declare module TypeScript {
    class ScannerUtilities {
        static identifierKind(array: number[], startIndex: number, length: number): TypeScript.SyntaxKind;
    }
}
declare module TypeScript {
    interface ISeparatedSyntaxList extends TypeScript.ISyntaxElement {
        childAt(index: number): TypeScript.ISyntaxNodeOrToken;
        toArray(): TypeScript.ISyntaxNodeOrToken[];
        toNonSeparatorArray(): TypeScript.ISyntaxNodeOrToken[];
        separatorCount(): number;
        separatorAt(index: number): TypeScript.ISyntaxToken;
        nonSeparatorCount(): number;
        nonSeparatorAt(index: number): TypeScript.ISyntaxNodeOrToken;
        insertChildrenInto(array: TypeScript.ISyntaxElement[], index: number): void;
    }
}
declare module TypeScript.Syntax {
    var emptySeparatedList: TypeScript.ISeparatedSyntaxList;
    function separatedList(nodes: TypeScript.ISyntaxNodeOrToken[]): TypeScript.ISeparatedSyntaxList;
}
declare module TypeScript {
    interface ISlidingWindowSource {
        fetchMoreItems(argument: any, sourceIndex: number, window: any[], destinationIndex: number, spaceAvailable: number): number;
    }
    class SlidingWindow {
        private source;
        public window: any[];
        private defaultValue;
        private sourceLength;
        private windowCount;
        public windowAbsoluteStartIndex: number;
        private currentRelativeItemIndex;
        private _pinCount;
        private firstPinnedAbsoluteIndex;
        constructor(source: ISlidingWindowSource, window: any[], defaultValue: any, sourceLength?: number);
        private windowAbsoluteEndIndex();
        private addMoreItemsToWindow(argument);
        private tryShiftOrGrowWindow();
        public absoluteIndex(): number;
        public isAtEndOfSource(): boolean;
        public getAndPinAbsoluteIndex(): number;
        public releaseAndUnpinAbsoluteIndex(absoluteIndex: number): void;
        public rewindToPinnedIndex(absoluteIndex: number): void;
        public currentItem(argument: any): any;
        public peekItemN(n: number): any;
        public moveToNextItem(): void;
        public disgardAllItemsFromCurrentIndexOnwards(): void;
        public setAbsoluteIndex(absoluteIndex: number): void;
        public pinCount(): number;
    }
}
declare module TypeScript {
}
declare module TypeScript.Syntax {
    function emptySourceUnit(): TypeScript.SourceUnitSyntax;
    function getStandaloneExpression(positionedToken: TypeScript.PositionedToken): TypeScript.PositionedNodeOrToken;
    function isInModuleOrTypeContext(positionedToken: TypeScript.PositionedToken): boolean;
    function isInTypeOnlyContext(positionedToken: TypeScript.PositionedToken): boolean;
    function childOffset(parent: TypeScript.ISyntaxElement, child: TypeScript.ISyntaxElement): number;
    function childOffsetAt(parent: TypeScript.ISyntaxElement, index: number): number;
    function childIndex(parent: TypeScript.ISyntaxElement, child: TypeScript.ISyntaxElement): number;
    function nodeStructuralEquals(node1: TypeScript.SyntaxNode, node2: TypeScript.SyntaxNode): boolean;
    function nodeOrTokenStructuralEquals(node1: TypeScript.ISyntaxNodeOrToken, node2: TypeScript.ISyntaxNodeOrToken): boolean;
    function tokenStructuralEquals(token1: TypeScript.ISyntaxToken, token2: TypeScript.ISyntaxToken): boolean;
    function triviaListStructuralEquals(triviaList1: TypeScript.ISyntaxTriviaList, triviaList2: TypeScript.ISyntaxTriviaList): boolean;
    function triviaStructuralEquals(trivia1: TypeScript.ISyntaxTrivia, trivia2: TypeScript.ISyntaxTrivia): boolean;
    function listStructuralEquals(list1: TypeScript.ISyntaxList, list2: TypeScript.ISyntaxList): boolean;
    function separatedListStructuralEquals(list1: TypeScript.ISeparatedSyntaxList, list2: TypeScript.ISeparatedSyntaxList): boolean;
    function elementStructuralEquals(element1: TypeScript.ISyntaxElement, element2: TypeScript.ISyntaxElement): boolean;
    function identifierName(text: string, info?: TypeScript.ITokenInfo): TypeScript.ISyntaxToken;
    function trueExpression(): TypeScript.IUnaryExpressionSyntax;
    function falseExpression(): TypeScript.IUnaryExpressionSyntax;
    function numericLiteralExpression(text: string): TypeScript.IUnaryExpressionSyntax;
    function stringLiteralExpression(text: string): TypeScript.IUnaryExpressionSyntax;
    function isSuperInvocationExpression(node: TypeScript.IExpressionSyntax): boolean;
    function isSuperInvocationExpressionStatement(node: TypeScript.SyntaxNode): boolean;
    function isSuperMemberAccessExpression(node: TypeScript.IExpressionSyntax): boolean;
    function isSuperMemberAccessInvocationExpression(node: TypeScript.SyntaxNode): boolean;
    function assignmentExpression(left: TypeScript.IExpressionSyntax, token: TypeScript.ISyntaxToken, right: TypeScript.IExpressionSyntax): TypeScript.BinaryExpressionSyntax;
    function nodeHasSkippedOrMissingTokens(node: TypeScript.SyntaxNode): boolean;
    function isUnterminatedStringLiteral(token: TypeScript.ISyntaxToken): boolean;
    function isUnterminatedMultilineCommentTrivia(trivia: TypeScript.ISyntaxTrivia): boolean;
    function isEntirelyInsideCommentTrivia(trivia: TypeScript.ISyntaxTrivia, fullStart: number, position: number): boolean;
    function isEntirelyInsideComment(sourceUnit: TypeScript.SourceUnitSyntax, position: number): boolean;
    function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit: TypeScript.SourceUnitSyntax, position: number): boolean;
    function findSkippedTokenInLeadingTriviaList(positionedToken: TypeScript.PositionedToken, position: number): TypeScript.PositionedSkippedToken;
    function findSkippedTokenInTrailingTriviaList(positionedToken: TypeScript.PositionedToken, position: number): TypeScript.PositionedSkippedToken;
    function findSkippedTokenInPositionedToken(positionedToken: TypeScript.PositionedToken, position: number): TypeScript.PositionedSkippedToken;
    function findSkippedTokenOnLeft(positionedToken: TypeScript.PositionedToken, position: number): TypeScript.PositionedSkippedToken;
    function getAncestorOfKind(positionedToken: TypeScript.PositionedElement, kind: TypeScript.SyntaxKind): TypeScript.PositionedElement;
    function hasAncestorOfKind(positionedToken: TypeScript.PositionedElement, kind: TypeScript.SyntaxKind): boolean;
    function isIntegerLiteral(expression: TypeScript.IExpressionSyntax): boolean;
    function isHexInteger(text: string): boolean;
}
declare module TypeScript {
    interface ISyntaxElement {
        kind(): TypeScript.SyntaxKind;
        isNode(): boolean;
        isToken(): boolean;
        isList(): boolean;
        isSeparatedList(): boolean;
        childCount(): number;
        childAt(index: number): ISyntaxElement;
        isTypeScriptSpecific(): boolean;
        isIncrementallyUnusable(): boolean;
        fullWidth(): number;
        width(): number;
        fullText(): string;
        leadingTrivia(): TypeScript.ISyntaxTriviaList;
        trailingTrivia(): TypeScript.ISyntaxTriviaList;
        leadingTriviaWidth(): number;
        trailingTriviaWidth(): number;
        firstToken(): TypeScript.ISyntaxToken;
        lastToken(): TypeScript.ISyntaxToken;
        collectTextElements(elements: string[]): void;
    }
    interface ISyntaxNode extends TypeScript.ISyntaxNodeOrToken {
    }
    interface IModuleReferenceSyntax extends ISyntaxNode {
    }
    interface IModuleElementSyntax extends ISyntaxNode {
    }
    interface IStatementSyntax extends IModuleElementSyntax {
    }
    interface ITypeMemberSyntax extends ISyntaxNode {
    }
    interface IClassElementSyntax extends ISyntaxNode {
    }
    interface IMemberDeclarationSyntax extends IClassElementSyntax {
    }
    interface ISwitchClauseSyntax extends ISyntaxNode {
    }
    interface IExpressionSyntax extends TypeScript.ISyntaxNodeOrToken {
    }
    interface IUnaryExpressionSyntax extends IExpressionSyntax {
    }
    interface ITypeSyntax extends IUnaryExpressionSyntax {
    }
    interface INameSyntax extends ITypeSyntax {
    }
}
declare module TypeScript.Syntax {
    interface IFactory {
        sourceUnit(moduleElements: TypeScript.ISyntaxList, endOfFileToken: TypeScript.ISyntaxToken): TypeScript.SourceUnitSyntax;
        externalModuleReference(requireKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, stringLiteral: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ExternalModuleReferenceSyntax;
        moduleNameModuleReference(moduleName: TypeScript.INameSyntax): TypeScript.ModuleNameModuleReferenceSyntax;
        importDeclaration(modifiers: TypeScript.ISyntaxList, importKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, moduleReference: TypeScript.ModuleReferenceSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ImportDeclarationSyntax;
        exportAssignment(exportKeyword: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ExportAssignmentSyntax;
        classDeclaration(modifiers: TypeScript.ISyntaxList, classKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, openBraceToken: TypeScript.ISyntaxToken, classElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ClassDeclarationSyntax;
        interfaceDeclaration(modifiers: TypeScript.ISyntaxList, interfaceKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, body: TypeScript.ObjectTypeSyntax): TypeScript.InterfaceDeclarationSyntax;
        heritageClause(extendsOrImplementsKeyword: TypeScript.ISyntaxToken, typeNames: TypeScript.ISeparatedSyntaxList): TypeScript.HeritageClauseSyntax;
        moduleDeclaration(modifiers: TypeScript.ISyntaxList, moduleKeyword: TypeScript.ISyntaxToken, moduleName: TypeScript.INameSyntax, stringLiteral: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, moduleElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ModuleDeclarationSyntax;
        functionDeclaration(modifiers: TypeScript.ISyntaxList, functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.FunctionDeclarationSyntax;
        variableStatement(modifiers: TypeScript.ISyntaxList, variableDeclaration: TypeScript.VariableDeclarationSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.VariableStatementSyntax;
        variableDeclaration(varKeyword: TypeScript.ISyntaxToken, variableDeclarators: TypeScript.ISeparatedSyntaxList): TypeScript.VariableDeclarationSyntax;
        variableDeclarator(identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.VariableDeclaratorSyntax;
        equalsValueClause(equalsToken: TypeScript.ISyntaxToken, value: TypeScript.IExpressionSyntax): TypeScript.EqualsValueClauseSyntax;
        prefixUnaryExpression(kind: TypeScript.SyntaxKind, operatorToken: TypeScript.ISyntaxToken, operand: TypeScript.IUnaryExpressionSyntax): TypeScript.PrefixUnaryExpressionSyntax;
        arrayLiteralExpression(openBracketToken: TypeScript.ISyntaxToken, expressions: TypeScript.ISeparatedSyntaxList, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ArrayLiteralExpressionSyntax;
        omittedExpression(): TypeScript.OmittedExpressionSyntax;
        parenthesizedExpression(openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ParenthesizedExpressionSyntax;
        simpleArrowFunctionExpression(identifier: TypeScript.ISyntaxToken, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): TypeScript.SimpleArrowFunctionExpressionSyntax;
        parenthesizedArrowFunctionExpression(callSignature: TypeScript.CallSignatureSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): TypeScript.ParenthesizedArrowFunctionExpressionSyntax;
        qualifiedName(left: TypeScript.INameSyntax, dotToken: TypeScript.ISyntaxToken, right: TypeScript.ISyntaxToken): TypeScript.QualifiedNameSyntax;
        typeArgumentList(lessThanToken: TypeScript.ISyntaxToken, typeArguments: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeScript.TypeArgumentListSyntax;
        constructorType(newKeyword: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.ConstructorTypeSyntax;
        functionType(typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.FunctionTypeSyntax;
        objectType(openBraceToken: TypeScript.ISyntaxToken, typeMembers: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ObjectTypeSyntax;
        arrayType(type: TypeScript.ITypeSyntax, openBracketToken: TypeScript.ISyntaxToken, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ArrayTypeSyntax;
        genericType(name: TypeScript.INameSyntax, typeArgumentList: TypeScript.TypeArgumentListSyntax): TypeScript.GenericTypeSyntax;
        typeQuery(typeOfKeyword: TypeScript.ISyntaxToken, name: TypeScript.INameSyntax): TypeScript.TypeQuerySyntax;
        typeAnnotation(colonToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.TypeAnnotationSyntax;
        block(openBraceToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.BlockSyntax;
        parameter(dotDotDotToken: TypeScript.ISyntaxToken, publicOrPrivateKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.ParameterSyntax;
        memberAccessExpression(expression: TypeScript.IExpressionSyntax, dotToken: TypeScript.ISyntaxToken, name: TypeScript.ISyntaxToken): TypeScript.MemberAccessExpressionSyntax;
        postfixUnaryExpression(kind: TypeScript.SyntaxKind, operand: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken): TypeScript.PostfixUnaryExpressionSyntax;
        elementAccessExpression(expression: TypeScript.IExpressionSyntax, openBracketToken: TypeScript.ISyntaxToken, argumentExpression: TypeScript.IExpressionSyntax, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ElementAccessExpressionSyntax;
        invocationExpression(expression: TypeScript.IExpressionSyntax, argumentList: TypeScript.ArgumentListSyntax): TypeScript.InvocationExpressionSyntax;
        argumentList(typeArgumentList: TypeScript.TypeArgumentListSyntax, openParenToken: TypeScript.ISyntaxToken, arguments: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ArgumentListSyntax;
        binaryExpression(kind: TypeScript.SyntaxKind, left: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken, right: TypeScript.IExpressionSyntax): TypeScript.BinaryExpressionSyntax;
        conditionalExpression(condition: TypeScript.IExpressionSyntax, questionToken: TypeScript.ISyntaxToken, whenTrue: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, whenFalse: TypeScript.IExpressionSyntax): TypeScript.ConditionalExpressionSyntax;
        constructSignature(newKeyword: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax): TypeScript.ConstructSignatureSyntax;
        methodSignature(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax): TypeScript.MethodSignatureSyntax;
        indexSignature(openBracketToken: TypeScript.ISyntaxToken, parameter: TypeScript.ParameterSyntax, closeBracketToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.IndexSignatureSyntax;
        propertySignature(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.PropertySignatureSyntax;
        callSignature(typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.CallSignatureSyntax;
        parameterList(openParenToken: TypeScript.ISyntaxToken, parameters: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ParameterListSyntax;
        typeParameterList(lessThanToken: TypeScript.ISyntaxToken, typeParameters: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeScript.TypeParameterListSyntax;
        typeParameter(identifier: TypeScript.ISyntaxToken, constraint: TypeScript.ConstraintSyntax): TypeScript.TypeParameterSyntax;
        constraint(extendsKeyword: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.ConstraintSyntax;
        elseClause(elseKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ElseClauseSyntax;
        ifStatement(ifKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, elseClause: TypeScript.ElseClauseSyntax): TypeScript.IfStatementSyntax;
        expressionStatement(expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ExpressionStatementSyntax;
        constructorDeclaration(constructorKeyword: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ConstructorDeclarationSyntax;
        memberFunctionDeclaration(modifiers: TypeScript.ISyntaxList, propertyName: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.MemberFunctionDeclarationSyntax;
        getMemberAccessorDeclaration(modifiers: TypeScript.ISyntaxList, getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, typeAnnotation: TypeScript.TypeAnnotationSyntax, block: TypeScript.BlockSyntax): TypeScript.GetMemberAccessorDeclarationSyntax;
        setMemberAccessorDeclaration(modifiers: TypeScript.ISyntaxList, setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, block: TypeScript.BlockSyntax): TypeScript.SetMemberAccessorDeclarationSyntax;
        memberVariableDeclaration(modifiers: TypeScript.ISyntaxList, variableDeclarator: TypeScript.VariableDeclaratorSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.MemberVariableDeclarationSyntax;
        throwStatement(throwKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ThrowStatementSyntax;
        returnStatement(returnKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ReturnStatementSyntax;
        objectCreationExpression(newKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, argumentList: TypeScript.ArgumentListSyntax): TypeScript.ObjectCreationExpressionSyntax;
        switchStatement(switchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, switchClauses: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.SwitchStatementSyntax;
        caseSwitchClause(caseKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): TypeScript.CaseSwitchClauseSyntax;
        defaultSwitchClause(defaultKeyword: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): TypeScript.DefaultSwitchClauseSyntax;
        breakStatement(breakKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.BreakStatementSyntax;
        continueStatement(continueKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ContinueStatementSyntax;
        forStatement(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: TypeScript.VariableDeclarationSyntax, initializer: TypeScript.IExpressionSyntax, firstSemicolonToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, secondSemicolonToken: TypeScript.ISyntaxToken, incrementor: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ForStatementSyntax;
        forInStatement(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: TypeScript.VariableDeclarationSyntax, left: TypeScript.IExpressionSyntax, inKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ForInStatementSyntax;
        whileStatement(whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.WhileStatementSyntax;
        withStatement(withKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.WithStatementSyntax;
        enumDeclaration(modifiers: TypeScript.ISyntaxList, enumKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, enumElements: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.EnumDeclarationSyntax;
        enumElement(propertyName: TypeScript.ISyntaxToken, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.EnumElementSyntax;
        castExpression(lessThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, greaterThanToken: TypeScript.ISyntaxToken, expression: TypeScript.IUnaryExpressionSyntax): TypeScript.CastExpressionSyntax;
        objectLiteralExpression(openBraceToken: TypeScript.ISyntaxToken, propertyAssignments: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ObjectLiteralExpressionSyntax;
        simplePropertyAssignment(propertyName: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.SimplePropertyAssignmentSyntax;
        functionPropertyAssignment(propertyName: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax): TypeScript.FunctionPropertyAssignmentSyntax;
        getAccessorPropertyAssignment(getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, block: TypeScript.BlockSyntax): TypeScript.GetAccessorPropertyAssignmentSyntax;
        setAccessorPropertyAssignment(setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, parameter: TypeScript.ParameterSyntax, closeParenToken: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.SetAccessorPropertyAssignmentSyntax;
        functionExpression(functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax): TypeScript.FunctionExpressionSyntax;
        emptyStatement(semicolonToken: TypeScript.ISyntaxToken): TypeScript.EmptyStatementSyntax;
        tryStatement(tryKeyword: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax, catchClause: TypeScript.CatchClauseSyntax, finallyClause: TypeScript.FinallyClauseSyntax): TypeScript.TryStatementSyntax;
        catchClause(catchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, closeParenToken: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.CatchClauseSyntax;
        finallyClause(finallyKeyword: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.FinallyClauseSyntax;
        labeledStatement(identifier: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.LabeledStatementSyntax;
        doStatement(doKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.DoStatementSyntax;
        typeOfExpression(typeOfKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.TypeOfExpressionSyntax;
        deleteExpression(deleteKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.DeleteExpressionSyntax;
        voidExpression(voidKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.VoidExpressionSyntax;
        debuggerStatement(debuggerKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.DebuggerStatementSyntax;
    }
    class NormalModeFactory implements IFactory {
        public sourceUnit(moduleElements: TypeScript.ISyntaxList, endOfFileToken: TypeScript.ISyntaxToken): TypeScript.SourceUnitSyntax;
        public externalModuleReference(requireKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, stringLiteral: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ExternalModuleReferenceSyntax;
        public moduleNameModuleReference(moduleName: TypeScript.INameSyntax): TypeScript.ModuleNameModuleReferenceSyntax;
        public importDeclaration(modifiers: TypeScript.ISyntaxList, importKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, moduleReference: TypeScript.ModuleReferenceSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ImportDeclarationSyntax;
        public exportAssignment(exportKeyword: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ExportAssignmentSyntax;
        public classDeclaration(modifiers: TypeScript.ISyntaxList, classKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, openBraceToken: TypeScript.ISyntaxToken, classElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ClassDeclarationSyntax;
        public interfaceDeclaration(modifiers: TypeScript.ISyntaxList, interfaceKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, body: TypeScript.ObjectTypeSyntax): TypeScript.InterfaceDeclarationSyntax;
        public heritageClause(extendsOrImplementsKeyword: TypeScript.ISyntaxToken, typeNames: TypeScript.ISeparatedSyntaxList): TypeScript.HeritageClauseSyntax;
        public moduleDeclaration(modifiers: TypeScript.ISyntaxList, moduleKeyword: TypeScript.ISyntaxToken, moduleName: TypeScript.INameSyntax, stringLiteral: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, moduleElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ModuleDeclarationSyntax;
        public functionDeclaration(modifiers: TypeScript.ISyntaxList, functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.FunctionDeclarationSyntax;
        public variableStatement(modifiers: TypeScript.ISyntaxList, variableDeclaration: TypeScript.VariableDeclarationSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.VariableStatementSyntax;
        public variableDeclaration(varKeyword: TypeScript.ISyntaxToken, variableDeclarators: TypeScript.ISeparatedSyntaxList): TypeScript.VariableDeclarationSyntax;
        public variableDeclarator(identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.VariableDeclaratorSyntax;
        public equalsValueClause(equalsToken: TypeScript.ISyntaxToken, value: TypeScript.IExpressionSyntax): TypeScript.EqualsValueClauseSyntax;
        public prefixUnaryExpression(kind: TypeScript.SyntaxKind, operatorToken: TypeScript.ISyntaxToken, operand: TypeScript.IUnaryExpressionSyntax): TypeScript.PrefixUnaryExpressionSyntax;
        public arrayLiteralExpression(openBracketToken: TypeScript.ISyntaxToken, expressions: TypeScript.ISeparatedSyntaxList, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ArrayLiteralExpressionSyntax;
        public omittedExpression(): TypeScript.OmittedExpressionSyntax;
        public parenthesizedExpression(openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ParenthesizedExpressionSyntax;
        public simpleArrowFunctionExpression(identifier: TypeScript.ISyntaxToken, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): TypeScript.SimpleArrowFunctionExpressionSyntax;
        public parenthesizedArrowFunctionExpression(callSignature: TypeScript.CallSignatureSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): TypeScript.ParenthesizedArrowFunctionExpressionSyntax;
        public qualifiedName(left: TypeScript.INameSyntax, dotToken: TypeScript.ISyntaxToken, right: TypeScript.ISyntaxToken): TypeScript.QualifiedNameSyntax;
        public typeArgumentList(lessThanToken: TypeScript.ISyntaxToken, typeArguments: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeScript.TypeArgumentListSyntax;
        public constructorType(newKeyword: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.ConstructorTypeSyntax;
        public functionType(typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.FunctionTypeSyntax;
        public objectType(openBraceToken: TypeScript.ISyntaxToken, typeMembers: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ObjectTypeSyntax;
        public arrayType(type: TypeScript.ITypeSyntax, openBracketToken: TypeScript.ISyntaxToken, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ArrayTypeSyntax;
        public genericType(name: TypeScript.INameSyntax, typeArgumentList: TypeScript.TypeArgumentListSyntax): TypeScript.GenericTypeSyntax;
        public typeQuery(typeOfKeyword: TypeScript.ISyntaxToken, name: TypeScript.INameSyntax): TypeScript.TypeQuerySyntax;
        public typeAnnotation(colonToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.TypeAnnotationSyntax;
        public block(openBraceToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.BlockSyntax;
        public parameter(dotDotDotToken: TypeScript.ISyntaxToken, publicOrPrivateKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.ParameterSyntax;
        public memberAccessExpression(expression: TypeScript.IExpressionSyntax, dotToken: TypeScript.ISyntaxToken, name: TypeScript.ISyntaxToken): TypeScript.MemberAccessExpressionSyntax;
        public postfixUnaryExpression(kind: TypeScript.SyntaxKind, operand: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken): TypeScript.PostfixUnaryExpressionSyntax;
        public elementAccessExpression(expression: TypeScript.IExpressionSyntax, openBracketToken: TypeScript.ISyntaxToken, argumentExpression: TypeScript.IExpressionSyntax, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ElementAccessExpressionSyntax;
        public invocationExpression(expression: TypeScript.IExpressionSyntax, argumentList: TypeScript.ArgumentListSyntax): TypeScript.InvocationExpressionSyntax;
        public argumentList(typeArgumentList: TypeScript.TypeArgumentListSyntax, openParenToken: TypeScript.ISyntaxToken, _arguments: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ArgumentListSyntax;
        public binaryExpression(kind: TypeScript.SyntaxKind, left: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken, right: TypeScript.IExpressionSyntax): TypeScript.BinaryExpressionSyntax;
        public conditionalExpression(condition: TypeScript.IExpressionSyntax, questionToken: TypeScript.ISyntaxToken, whenTrue: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, whenFalse: TypeScript.IExpressionSyntax): TypeScript.ConditionalExpressionSyntax;
        public constructSignature(newKeyword: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax): TypeScript.ConstructSignatureSyntax;
        public methodSignature(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax): TypeScript.MethodSignatureSyntax;
        public indexSignature(openBracketToken: TypeScript.ISyntaxToken, parameter: TypeScript.ParameterSyntax, closeBracketToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.IndexSignatureSyntax;
        public propertySignature(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.PropertySignatureSyntax;
        public callSignature(typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.CallSignatureSyntax;
        public parameterList(openParenToken: TypeScript.ISyntaxToken, parameters: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ParameterListSyntax;
        public typeParameterList(lessThanToken: TypeScript.ISyntaxToken, typeParameters: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeScript.TypeParameterListSyntax;
        public typeParameter(identifier: TypeScript.ISyntaxToken, constraint: TypeScript.ConstraintSyntax): TypeScript.TypeParameterSyntax;
        public constraint(extendsKeyword: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.ConstraintSyntax;
        public elseClause(elseKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ElseClauseSyntax;
        public ifStatement(ifKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, elseClause: TypeScript.ElseClauseSyntax): TypeScript.IfStatementSyntax;
        public expressionStatement(expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ExpressionStatementSyntax;
        public constructorDeclaration(constructorKeyword: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ConstructorDeclarationSyntax;
        public memberFunctionDeclaration(modifiers: TypeScript.ISyntaxList, propertyName: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.MemberFunctionDeclarationSyntax;
        public getMemberAccessorDeclaration(modifiers: TypeScript.ISyntaxList, getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, typeAnnotation: TypeScript.TypeAnnotationSyntax, block: TypeScript.BlockSyntax): TypeScript.GetMemberAccessorDeclarationSyntax;
        public setMemberAccessorDeclaration(modifiers: TypeScript.ISyntaxList, setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, block: TypeScript.BlockSyntax): TypeScript.SetMemberAccessorDeclarationSyntax;
        public memberVariableDeclaration(modifiers: TypeScript.ISyntaxList, variableDeclarator: TypeScript.VariableDeclaratorSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.MemberVariableDeclarationSyntax;
        public throwStatement(throwKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ThrowStatementSyntax;
        public returnStatement(returnKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ReturnStatementSyntax;
        public objectCreationExpression(newKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, argumentList: TypeScript.ArgumentListSyntax): TypeScript.ObjectCreationExpressionSyntax;
        public switchStatement(switchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, switchClauses: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.SwitchStatementSyntax;
        public caseSwitchClause(caseKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): TypeScript.CaseSwitchClauseSyntax;
        public defaultSwitchClause(defaultKeyword: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): TypeScript.DefaultSwitchClauseSyntax;
        public breakStatement(breakKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.BreakStatementSyntax;
        public continueStatement(continueKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ContinueStatementSyntax;
        public forStatement(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: TypeScript.VariableDeclarationSyntax, initializer: TypeScript.IExpressionSyntax, firstSemicolonToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, secondSemicolonToken: TypeScript.ISyntaxToken, incrementor: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ForStatementSyntax;
        public forInStatement(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: TypeScript.VariableDeclarationSyntax, left: TypeScript.IExpressionSyntax, inKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ForInStatementSyntax;
        public whileStatement(whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.WhileStatementSyntax;
        public withStatement(withKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.WithStatementSyntax;
        public enumDeclaration(modifiers: TypeScript.ISyntaxList, enumKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, enumElements: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.EnumDeclarationSyntax;
        public enumElement(propertyName: TypeScript.ISyntaxToken, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.EnumElementSyntax;
        public castExpression(lessThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, greaterThanToken: TypeScript.ISyntaxToken, expression: TypeScript.IUnaryExpressionSyntax): TypeScript.CastExpressionSyntax;
        public objectLiteralExpression(openBraceToken: TypeScript.ISyntaxToken, propertyAssignments: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ObjectLiteralExpressionSyntax;
        public simplePropertyAssignment(propertyName: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.SimplePropertyAssignmentSyntax;
        public functionPropertyAssignment(propertyName: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax): TypeScript.FunctionPropertyAssignmentSyntax;
        public getAccessorPropertyAssignment(getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, block: TypeScript.BlockSyntax): TypeScript.GetAccessorPropertyAssignmentSyntax;
        public setAccessorPropertyAssignment(setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, parameter: TypeScript.ParameterSyntax, closeParenToken: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.SetAccessorPropertyAssignmentSyntax;
        public functionExpression(functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax): TypeScript.FunctionExpressionSyntax;
        public emptyStatement(semicolonToken: TypeScript.ISyntaxToken): TypeScript.EmptyStatementSyntax;
        public tryStatement(tryKeyword: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax, catchClause: TypeScript.CatchClauseSyntax, finallyClause: TypeScript.FinallyClauseSyntax): TypeScript.TryStatementSyntax;
        public catchClause(catchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, closeParenToken: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.CatchClauseSyntax;
        public finallyClause(finallyKeyword: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.FinallyClauseSyntax;
        public labeledStatement(identifier: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.LabeledStatementSyntax;
        public doStatement(doKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.DoStatementSyntax;
        public typeOfExpression(typeOfKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.TypeOfExpressionSyntax;
        public deleteExpression(deleteKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.DeleteExpressionSyntax;
        public voidExpression(voidKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.VoidExpressionSyntax;
        public debuggerStatement(debuggerKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.DebuggerStatementSyntax;
    }
    class StrictModeFactory implements IFactory {
        public sourceUnit(moduleElements: TypeScript.ISyntaxList, endOfFileToken: TypeScript.ISyntaxToken): TypeScript.SourceUnitSyntax;
        public externalModuleReference(requireKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, stringLiteral: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ExternalModuleReferenceSyntax;
        public moduleNameModuleReference(moduleName: TypeScript.INameSyntax): TypeScript.ModuleNameModuleReferenceSyntax;
        public importDeclaration(modifiers: TypeScript.ISyntaxList, importKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, moduleReference: TypeScript.ModuleReferenceSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ImportDeclarationSyntax;
        public exportAssignment(exportKeyword: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ExportAssignmentSyntax;
        public classDeclaration(modifiers: TypeScript.ISyntaxList, classKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, openBraceToken: TypeScript.ISyntaxToken, classElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ClassDeclarationSyntax;
        public interfaceDeclaration(modifiers: TypeScript.ISyntaxList, interfaceKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, body: TypeScript.ObjectTypeSyntax): TypeScript.InterfaceDeclarationSyntax;
        public heritageClause(extendsOrImplementsKeyword: TypeScript.ISyntaxToken, typeNames: TypeScript.ISeparatedSyntaxList): TypeScript.HeritageClauseSyntax;
        public moduleDeclaration(modifiers: TypeScript.ISyntaxList, moduleKeyword: TypeScript.ISyntaxToken, moduleName: TypeScript.INameSyntax, stringLiteral: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, moduleElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ModuleDeclarationSyntax;
        public functionDeclaration(modifiers: TypeScript.ISyntaxList, functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.FunctionDeclarationSyntax;
        public variableStatement(modifiers: TypeScript.ISyntaxList, variableDeclaration: TypeScript.VariableDeclarationSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.VariableStatementSyntax;
        public variableDeclaration(varKeyword: TypeScript.ISyntaxToken, variableDeclarators: TypeScript.ISeparatedSyntaxList): TypeScript.VariableDeclarationSyntax;
        public variableDeclarator(identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.VariableDeclaratorSyntax;
        public equalsValueClause(equalsToken: TypeScript.ISyntaxToken, value: TypeScript.IExpressionSyntax): TypeScript.EqualsValueClauseSyntax;
        public prefixUnaryExpression(kind: TypeScript.SyntaxKind, operatorToken: TypeScript.ISyntaxToken, operand: TypeScript.IUnaryExpressionSyntax): TypeScript.PrefixUnaryExpressionSyntax;
        public arrayLiteralExpression(openBracketToken: TypeScript.ISyntaxToken, expressions: TypeScript.ISeparatedSyntaxList, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ArrayLiteralExpressionSyntax;
        public omittedExpression(): TypeScript.OmittedExpressionSyntax;
        public parenthesizedExpression(openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ParenthesizedExpressionSyntax;
        public simpleArrowFunctionExpression(identifier: TypeScript.ISyntaxToken, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): TypeScript.SimpleArrowFunctionExpressionSyntax;
        public parenthesizedArrowFunctionExpression(callSignature: TypeScript.CallSignatureSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): TypeScript.ParenthesizedArrowFunctionExpressionSyntax;
        public qualifiedName(left: TypeScript.INameSyntax, dotToken: TypeScript.ISyntaxToken, right: TypeScript.ISyntaxToken): TypeScript.QualifiedNameSyntax;
        public typeArgumentList(lessThanToken: TypeScript.ISyntaxToken, typeArguments: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeScript.TypeArgumentListSyntax;
        public constructorType(newKeyword: TypeScript.ISyntaxToken, typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.ConstructorTypeSyntax;
        public functionType(typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.FunctionTypeSyntax;
        public objectType(openBraceToken: TypeScript.ISyntaxToken, typeMembers: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ObjectTypeSyntax;
        public arrayType(type: TypeScript.ITypeSyntax, openBracketToken: TypeScript.ISyntaxToken, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ArrayTypeSyntax;
        public genericType(name: TypeScript.INameSyntax, typeArgumentList: TypeScript.TypeArgumentListSyntax): TypeScript.GenericTypeSyntax;
        public typeQuery(typeOfKeyword: TypeScript.ISyntaxToken, name: TypeScript.INameSyntax): TypeScript.TypeQuerySyntax;
        public typeAnnotation(colonToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.TypeAnnotationSyntax;
        public block(openBraceToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.BlockSyntax;
        public parameter(dotDotDotToken: TypeScript.ISyntaxToken, publicOrPrivateKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.ParameterSyntax;
        public memberAccessExpression(expression: TypeScript.IExpressionSyntax, dotToken: TypeScript.ISyntaxToken, name: TypeScript.ISyntaxToken): TypeScript.MemberAccessExpressionSyntax;
        public postfixUnaryExpression(kind: TypeScript.SyntaxKind, operand: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken): TypeScript.PostfixUnaryExpressionSyntax;
        public elementAccessExpression(expression: TypeScript.IExpressionSyntax, openBracketToken: TypeScript.ISyntaxToken, argumentExpression: TypeScript.IExpressionSyntax, closeBracketToken: TypeScript.ISyntaxToken): TypeScript.ElementAccessExpressionSyntax;
        public invocationExpression(expression: TypeScript.IExpressionSyntax, argumentList: TypeScript.ArgumentListSyntax): TypeScript.InvocationExpressionSyntax;
        public argumentList(typeArgumentList: TypeScript.TypeArgumentListSyntax, openParenToken: TypeScript.ISyntaxToken, _arguments: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ArgumentListSyntax;
        public binaryExpression(kind: TypeScript.SyntaxKind, left: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken, right: TypeScript.IExpressionSyntax): TypeScript.BinaryExpressionSyntax;
        public conditionalExpression(condition: TypeScript.IExpressionSyntax, questionToken: TypeScript.ISyntaxToken, whenTrue: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, whenFalse: TypeScript.IExpressionSyntax): TypeScript.ConditionalExpressionSyntax;
        public constructSignature(newKeyword: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax): TypeScript.ConstructSignatureSyntax;
        public methodSignature(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax): TypeScript.MethodSignatureSyntax;
        public indexSignature(openBracketToken: TypeScript.ISyntaxToken, parameter: TypeScript.ParameterSyntax, closeBracketToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.IndexSignatureSyntax;
        public propertySignature(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.PropertySignatureSyntax;
        public callSignature(typeParameterList: TypeScript.TypeParameterListSyntax, parameterList: TypeScript.ParameterListSyntax, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.CallSignatureSyntax;
        public parameterList(openParenToken: TypeScript.ISyntaxToken, parameters: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): TypeScript.ParameterListSyntax;
        public typeParameterList(lessThanToken: TypeScript.ISyntaxToken, typeParameters: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeScript.TypeParameterListSyntax;
        public typeParameter(identifier: TypeScript.ISyntaxToken, constraint: TypeScript.ConstraintSyntax): TypeScript.TypeParameterSyntax;
        public constraint(extendsKeyword: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeScript.ConstraintSyntax;
        public elseClause(elseKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ElseClauseSyntax;
        public ifStatement(ifKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, elseClause: TypeScript.ElseClauseSyntax): TypeScript.IfStatementSyntax;
        public expressionStatement(expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ExpressionStatementSyntax;
        public constructorDeclaration(constructorKeyword: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ConstructorDeclarationSyntax;
        public memberFunctionDeclaration(modifiers: TypeScript.ISyntaxList, propertyName: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.MemberFunctionDeclarationSyntax;
        public getMemberAccessorDeclaration(modifiers: TypeScript.ISyntaxList, getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, typeAnnotation: TypeScript.TypeAnnotationSyntax, block: TypeScript.BlockSyntax): TypeScript.GetMemberAccessorDeclarationSyntax;
        public setMemberAccessorDeclaration(modifiers: TypeScript.ISyntaxList, setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: TypeScript.ParameterListSyntax, block: TypeScript.BlockSyntax): TypeScript.SetMemberAccessorDeclarationSyntax;
        public memberVariableDeclaration(modifiers: TypeScript.ISyntaxList, variableDeclarator: TypeScript.VariableDeclaratorSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.MemberVariableDeclarationSyntax;
        public throwStatement(throwKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ThrowStatementSyntax;
        public returnStatement(returnKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ReturnStatementSyntax;
        public objectCreationExpression(newKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, argumentList: TypeScript.ArgumentListSyntax): TypeScript.ObjectCreationExpressionSyntax;
        public switchStatement(switchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, switchClauses: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.SwitchStatementSyntax;
        public caseSwitchClause(caseKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): TypeScript.CaseSwitchClauseSyntax;
        public defaultSwitchClause(defaultKeyword: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): TypeScript.DefaultSwitchClauseSyntax;
        public breakStatement(breakKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.BreakStatementSyntax;
        public continueStatement(continueKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.ContinueStatementSyntax;
        public forStatement(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: TypeScript.VariableDeclarationSyntax, initializer: TypeScript.IExpressionSyntax, firstSemicolonToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, secondSemicolonToken: TypeScript.ISyntaxToken, incrementor: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ForStatementSyntax;
        public forInStatement(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: TypeScript.VariableDeclarationSyntax, left: TypeScript.IExpressionSyntax, inKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.ForInStatementSyntax;
        public whileStatement(whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.WhileStatementSyntax;
        public withStatement(withKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.WithStatementSyntax;
        public enumDeclaration(modifiers: TypeScript.ISyntaxList, enumKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, enumElements: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.EnumDeclarationSyntax;
        public enumElement(propertyName: TypeScript.ISyntaxToken, equalsValueClause: TypeScript.EqualsValueClauseSyntax): TypeScript.EnumElementSyntax;
        public castExpression(lessThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, greaterThanToken: TypeScript.ISyntaxToken, expression: TypeScript.IUnaryExpressionSyntax): TypeScript.CastExpressionSyntax;
        public objectLiteralExpression(openBraceToken: TypeScript.ISyntaxToken, propertyAssignments: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): TypeScript.ObjectLiteralExpressionSyntax;
        public simplePropertyAssignment(propertyName: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.SimplePropertyAssignmentSyntax;
        public functionPropertyAssignment(propertyName: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax): TypeScript.FunctionPropertyAssignmentSyntax;
        public getAccessorPropertyAssignment(getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, block: TypeScript.BlockSyntax): TypeScript.GetAccessorPropertyAssignmentSyntax;
        public setAccessorPropertyAssignment(setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, parameter: TypeScript.ParameterSyntax, closeParenToken: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.SetAccessorPropertyAssignmentSyntax;
        public functionExpression(functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: TypeScript.CallSignatureSyntax, block: TypeScript.BlockSyntax): TypeScript.FunctionExpressionSyntax;
        public emptyStatement(semicolonToken: TypeScript.ISyntaxToken): TypeScript.EmptyStatementSyntax;
        public tryStatement(tryKeyword: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax, catchClause: TypeScript.CatchClauseSyntax, finallyClause: TypeScript.FinallyClauseSyntax): TypeScript.TryStatementSyntax;
        public catchClause(catchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeScript.TypeAnnotationSyntax, closeParenToken: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.CatchClauseSyntax;
        public finallyClause(finallyKeyword: TypeScript.ISyntaxToken, block: TypeScript.BlockSyntax): TypeScript.FinallyClauseSyntax;
        public labeledStatement(identifier: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): TypeScript.LabeledStatementSyntax;
        public doStatement(doKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.DoStatementSyntax;
        public typeOfExpression(typeOfKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.TypeOfExpressionSyntax;
        public deleteExpression(deleteKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.DeleteExpressionSyntax;
        public voidExpression(voidKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeScript.VoidExpressionSyntax;
        public debuggerStatement(debuggerKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): TypeScript.DebuggerStatementSyntax;
    }
    var normalModeFactory: IFactory;
    var strictModeFactory: IFactory;
}
declare module TypeScript.SyntaxFacts {
    function isDirectivePrologueElement(node: TypeScript.ISyntaxNodeOrToken): boolean;
    function isUseStrictDirective(node: TypeScript.ISyntaxNodeOrToken): boolean;
    function isIdentifierNameOrAnyKeyword(token: TypeScript.ISyntaxToken): boolean;
}
declare module TypeScript {
    interface ISyntaxList extends TypeScript.ISyntaxElement {
        childAt(index: number): TypeScript.ISyntaxNodeOrToken;
        toArray(): TypeScript.ISyntaxNodeOrToken[];
        insertChildrenInto(array: TypeScript.ISyntaxElement[], index: number): void;
    }
}
declare module TypeScript.Syntax {
    class EmptySyntaxList implements TypeScript.ISyntaxList {
        public kind(): TypeScript.SyntaxKind;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public toJSON(key: any): any[];
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxNodeOrToken;
        public toArray(): TypeScript.ISyntaxNodeOrToken[];
        public collectTextElements(elements: string[]): void;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public fullWidth(): number;
        public width(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public leadingTriviaWidth(): number;
        public trailingTriviaWidth(): number;
        public fullText(): string;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public findTokenInternal(parent: TypeScript.PositionedElement, position: number, fullStart: number): TypeScript.PositionedToken;
        public insertChildrenInto(array: TypeScript.ISyntaxElement[], index: number): void;
    }
    var emptyList: TypeScript.ISyntaxList;
    function list(nodes: TypeScript.ISyntaxNodeOrToken[]): TypeScript.ISyntaxList;
}
declare module TypeScript {
    class SyntaxNode implements TypeScript.ISyntaxNodeOrToken {
        private _data;
        constructor(parsedInStrictMode: boolean);
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public insertChildrenInto(array: TypeScript.ISyntaxElement[], index: number): void;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public toJSON(key: any): any;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public fullText(): string;
        public collectTextElements(elements: string[]): void;
        public replaceToken(token1: TypeScript.ISyntaxToken, token2: TypeScript.ISyntaxToken): SyntaxNode;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SyntaxNode;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SyntaxNode;
        public hasLeadingTrivia(): boolean;
        public hasTrailingTrivia(): boolean;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public parsedInStrictMode(): boolean;
        public fullWidth(): number;
        private computeData();
        private data();
        public findToken(position: number, includeSkippedTokens?: boolean): TypeScript.PositionedToken;
        private tryGetEndOfFileAt(position);
        private findTokenInternal(parent, position, fullStart);
        public findTokenOnLeft(position: number, includeSkippedTokens?: boolean): TypeScript.PositionedToken;
        public findCompleteTokenOnLeft(position: number, includeSkippedTokens?: boolean): TypeScript.PositionedToken;
        public isModuleElement(): boolean;
        public isClassElement(): boolean;
        public isTypeMember(): boolean;
        public isStatement(): boolean;
        public isSwitchClause(): boolean;
        public structuralEquals(node: SyntaxNode): boolean;
        public width(): number;
        public leadingTriviaWidth(): number;
        public trailingTriviaWidth(): number;
    }
}
declare module TypeScript {
    interface ISyntaxNodeOrToken extends TypeScript.ISyntaxElement {
        withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): ISyntaxNodeOrToken;
        withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): ISyntaxNodeOrToken;
        accept(visitor: TypeScript.ISyntaxVisitor): any;
    }
}
declare module TypeScript {
    class SourceUnitSyntax extends TypeScript.SyntaxNode {
        public moduleElements: TypeScript.ISyntaxList;
        public endOfFileToken: TypeScript.ISyntaxToken;
        constructor(moduleElements: TypeScript.ISyntaxList, endOfFileToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(moduleElements: TypeScript.ISyntaxList, endOfFileToken: TypeScript.ISyntaxToken): SourceUnitSyntax;
        static create(endOfFileToken: TypeScript.ISyntaxToken): SourceUnitSyntax;
        static create1(endOfFileToken: TypeScript.ISyntaxToken): SourceUnitSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SourceUnitSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SourceUnitSyntax;
        public withModuleElements(moduleElements: TypeScript.ISyntaxList): SourceUnitSyntax;
        public withModuleElement(moduleElement: TypeScript.IModuleElementSyntax): SourceUnitSyntax;
        public withEndOfFileToken(endOfFileToken: TypeScript.ISyntaxToken): SourceUnitSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ModuleReferenceSyntax extends TypeScript.SyntaxNode implements TypeScript.IModuleReferenceSyntax {
        constructor(parsedInStrictMode: boolean);
        public isModuleReference(): boolean;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ModuleReferenceSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ModuleReferenceSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ExternalModuleReferenceSyntax extends ModuleReferenceSyntax {
        public requireKeyword: TypeScript.ISyntaxToken;
        public openParenToken: TypeScript.ISyntaxToken;
        public stringLiteral: TypeScript.ISyntaxToken;
        public closeParenToken: TypeScript.ISyntaxToken;
        constructor(requireKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, stringLiteral: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(requireKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, stringLiteral: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken): ExternalModuleReferenceSyntax;
        static create1(stringLiteral: TypeScript.ISyntaxToken): ExternalModuleReferenceSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ExternalModuleReferenceSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ExternalModuleReferenceSyntax;
        public withRequireKeyword(requireKeyword: TypeScript.ISyntaxToken): ExternalModuleReferenceSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): ExternalModuleReferenceSyntax;
        public withStringLiteral(stringLiteral: TypeScript.ISyntaxToken): ExternalModuleReferenceSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): ExternalModuleReferenceSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ModuleNameModuleReferenceSyntax extends ModuleReferenceSyntax {
        public moduleName: TypeScript.INameSyntax;
        constructor(moduleName: TypeScript.INameSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(moduleName: TypeScript.INameSyntax): ModuleNameModuleReferenceSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ModuleNameModuleReferenceSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ModuleNameModuleReferenceSyntax;
        public withModuleName(moduleName: TypeScript.INameSyntax): ModuleNameModuleReferenceSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ImportDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IModuleElementSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public importKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public equalsToken: TypeScript.ISyntaxToken;
        public moduleReference: ModuleReferenceSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, importKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isModuleElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, importKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: TypeScript.ISyntaxToken): ImportDeclarationSyntax;
        static create(importKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, moduleReference: ModuleReferenceSyntax, semicolonToken: TypeScript.ISyntaxToken): ImportDeclarationSyntax;
        static create1(identifier: TypeScript.ISyntaxToken, moduleReference: ModuleReferenceSyntax): ImportDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ImportDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ImportDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): ImportDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): ImportDeclarationSyntax;
        public withImportKeyword(importKeyword: TypeScript.ISyntaxToken): ImportDeclarationSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): ImportDeclarationSyntax;
        public withEqualsToken(equalsToken: TypeScript.ISyntaxToken): ImportDeclarationSyntax;
        public withModuleReference(moduleReference: ModuleReferenceSyntax): ImportDeclarationSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): ImportDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ExportAssignmentSyntax extends TypeScript.SyntaxNode implements TypeScript.IModuleElementSyntax {
        public exportKeyword: TypeScript.ISyntaxToken;
        public equalsToken: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(exportKeyword: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isModuleElement(): boolean;
        public update(exportKeyword: TypeScript.ISyntaxToken, equalsToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): ExportAssignmentSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): ExportAssignmentSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ExportAssignmentSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ExportAssignmentSyntax;
        public withExportKeyword(exportKeyword: TypeScript.ISyntaxToken): ExportAssignmentSyntax;
        public withEqualsToken(equalsToken: TypeScript.ISyntaxToken): ExportAssignmentSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): ExportAssignmentSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): ExportAssignmentSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ClassDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IModuleElementSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public classKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public typeParameterList: TypeParameterListSyntax;
        public heritageClauses: TypeScript.ISyntaxList;
        public openBraceToken: TypeScript.ISyntaxToken;
        public classElements: TypeScript.ISyntaxList;
        public closeBraceToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, classKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, openBraceToken: TypeScript.ISyntaxToken, classElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isModuleElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, classKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, openBraceToken: TypeScript.ISyntaxToken, classElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        static create(classKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, closeBraceToken: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ClassDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ClassDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): ClassDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        public withClassKeyword(classKeyword: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        public withTypeParameterList(typeParameterList: TypeParameterListSyntax): ClassDeclarationSyntax;
        public withHeritageClauses(heritageClauses: TypeScript.ISyntaxList): ClassDeclarationSyntax;
        public withHeritageClause(heritageClause: HeritageClauseSyntax): ClassDeclarationSyntax;
        public withOpenBraceToken(openBraceToken: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        public withClassElements(classElements: TypeScript.ISyntaxList): ClassDeclarationSyntax;
        public withClassElement(classElement: TypeScript.IClassElementSyntax): ClassDeclarationSyntax;
        public withCloseBraceToken(closeBraceToken: TypeScript.ISyntaxToken): ClassDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class InterfaceDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IModuleElementSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public interfaceKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public typeParameterList: TypeParameterListSyntax;
        public heritageClauses: TypeScript.ISyntaxList;
        public body: ObjectTypeSyntax;
        constructor(modifiers: TypeScript.ISyntaxList, interfaceKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, body: ObjectTypeSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isModuleElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, interfaceKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeParameterList: TypeParameterListSyntax, heritageClauses: TypeScript.ISyntaxList, body: ObjectTypeSyntax): InterfaceDeclarationSyntax;
        static create(interfaceKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, body: ObjectTypeSyntax): InterfaceDeclarationSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): InterfaceDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): InterfaceDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): InterfaceDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): InterfaceDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): InterfaceDeclarationSyntax;
        public withInterfaceKeyword(interfaceKeyword: TypeScript.ISyntaxToken): InterfaceDeclarationSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): InterfaceDeclarationSyntax;
        public withTypeParameterList(typeParameterList: TypeParameterListSyntax): InterfaceDeclarationSyntax;
        public withHeritageClauses(heritageClauses: TypeScript.ISyntaxList): InterfaceDeclarationSyntax;
        public withHeritageClause(heritageClause: HeritageClauseSyntax): InterfaceDeclarationSyntax;
        public withBody(body: ObjectTypeSyntax): InterfaceDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class HeritageClauseSyntax extends TypeScript.SyntaxNode {
        public extendsOrImplementsKeyword: TypeScript.ISyntaxToken;
        public typeNames: TypeScript.ISeparatedSyntaxList;
        constructor(extendsOrImplementsKeyword: TypeScript.ISyntaxToken, typeNames: TypeScript.ISeparatedSyntaxList, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(extendsOrImplementsKeyword: TypeScript.ISyntaxToken, typeNames: TypeScript.ISeparatedSyntaxList): HeritageClauseSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): HeritageClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): HeritageClauseSyntax;
        public withExtendsOrImplementsKeyword(extendsOrImplementsKeyword: TypeScript.ISyntaxToken): HeritageClauseSyntax;
        public withTypeNames(typeNames: TypeScript.ISeparatedSyntaxList): HeritageClauseSyntax;
        public withTypeName(typeName: TypeScript.INameSyntax): HeritageClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ModuleDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IModuleElementSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public moduleKeyword: TypeScript.ISyntaxToken;
        public moduleName: TypeScript.INameSyntax;
        public stringLiteral: TypeScript.ISyntaxToken;
        public openBraceToken: TypeScript.ISyntaxToken;
        public moduleElements: TypeScript.ISyntaxList;
        public closeBraceToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, moduleKeyword: TypeScript.ISyntaxToken, moduleName: TypeScript.INameSyntax, stringLiteral: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, moduleElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isModuleElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, moduleKeyword: TypeScript.ISyntaxToken, moduleName: TypeScript.INameSyntax, stringLiteral: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, moduleElements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): ModuleDeclarationSyntax;
        static create(moduleKeyword: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, closeBraceToken: TypeScript.ISyntaxToken): ModuleDeclarationSyntax;
        static create1(): ModuleDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ModuleDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ModuleDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): ModuleDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): ModuleDeclarationSyntax;
        public withModuleKeyword(moduleKeyword: TypeScript.ISyntaxToken): ModuleDeclarationSyntax;
        public withModuleName(moduleName: TypeScript.INameSyntax): ModuleDeclarationSyntax;
        public withStringLiteral(stringLiteral: TypeScript.ISyntaxToken): ModuleDeclarationSyntax;
        public withOpenBraceToken(openBraceToken: TypeScript.ISyntaxToken): ModuleDeclarationSyntax;
        public withModuleElements(moduleElements: TypeScript.ISyntaxList): ModuleDeclarationSyntax;
        public withModuleElement(moduleElement: TypeScript.IModuleElementSyntax): ModuleDeclarationSyntax;
        public withCloseBraceToken(closeBraceToken: TypeScript.ISyntaxToken): ModuleDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class FunctionDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public functionKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): FunctionDeclarationSyntax;
        static create(functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax): FunctionDeclarationSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): FunctionDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): FunctionDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): FunctionDeclarationSyntax;
        public withFunctionKeyword(functionKeyword: TypeScript.ISyntaxToken): FunctionDeclarationSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): FunctionDeclarationSyntax;
        public withCallSignature(callSignature: CallSignatureSyntax): FunctionDeclarationSyntax;
        public withBlock(block: BlockSyntax): FunctionDeclarationSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): FunctionDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class VariableStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public variableDeclaration: VariableDeclarationSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, variableDeclaration: VariableDeclarationSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, variableDeclaration: VariableDeclarationSyntax, semicolonToken: TypeScript.ISyntaxToken): VariableStatementSyntax;
        static create(variableDeclaration: VariableDeclarationSyntax, semicolonToken: TypeScript.ISyntaxToken): VariableStatementSyntax;
        static create1(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): VariableStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): VariableStatementSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): VariableStatementSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): VariableStatementSyntax;
        public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): VariableStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): VariableStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class VariableDeclarationSyntax extends TypeScript.SyntaxNode {
        public varKeyword: TypeScript.ISyntaxToken;
        public variableDeclarators: TypeScript.ISeparatedSyntaxList;
        constructor(varKeyword: TypeScript.ISyntaxToken, variableDeclarators: TypeScript.ISeparatedSyntaxList, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(varKeyword: TypeScript.ISyntaxToken, variableDeclarators: TypeScript.ISeparatedSyntaxList): VariableDeclarationSyntax;
        static create1(variableDeclarators: TypeScript.ISeparatedSyntaxList): VariableDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): VariableDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): VariableDeclarationSyntax;
        public withVarKeyword(varKeyword: TypeScript.ISyntaxToken): VariableDeclarationSyntax;
        public withVariableDeclarators(variableDeclarators: TypeScript.ISeparatedSyntaxList): VariableDeclarationSyntax;
        public withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): VariableDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class VariableDeclaratorSyntax extends TypeScript.SyntaxNode {
        public identifier: TypeScript.ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public equalsValueClause: EqualsValueClauseSyntax;
        constructor(identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        static create(identifier: TypeScript.ISyntaxToken): VariableDeclaratorSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): VariableDeclaratorSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): VariableDeclaratorSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): VariableDeclaratorSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): VariableDeclaratorSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): VariableDeclaratorSyntax;
        public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): VariableDeclaratorSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class EqualsValueClauseSyntax extends TypeScript.SyntaxNode {
        public equalsToken: TypeScript.ISyntaxToken;
        public value: TypeScript.IExpressionSyntax;
        constructor(equalsToken: TypeScript.ISyntaxToken, value: TypeScript.IExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(equalsToken: TypeScript.ISyntaxToken, value: TypeScript.IExpressionSyntax): EqualsValueClauseSyntax;
        static create1(value: TypeScript.IExpressionSyntax): EqualsValueClauseSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): EqualsValueClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): EqualsValueClauseSyntax;
        public withEqualsToken(equalsToken: TypeScript.ISyntaxToken): EqualsValueClauseSyntax;
        public withValue(value: TypeScript.IExpressionSyntax): EqualsValueClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class PrefixUnaryExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public operatorToken: TypeScript.ISyntaxToken;
        public operand: TypeScript.IUnaryExpressionSyntax;
        private _kind;
        constructor(kind: TypeScript.SyntaxKind, operatorToken: TypeScript.ISyntaxToken, operand: TypeScript.IUnaryExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public update(kind: TypeScript.SyntaxKind, operatorToken: TypeScript.ISyntaxToken, operand: TypeScript.IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): PrefixUnaryExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): PrefixUnaryExpressionSyntax;
        public withKind(kind: TypeScript.SyntaxKind): PrefixUnaryExpressionSyntax;
        public withOperatorToken(operatorToken: TypeScript.ISyntaxToken): PrefixUnaryExpressionSyntax;
        public withOperand(operand: TypeScript.IUnaryExpressionSyntax): PrefixUnaryExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ArrayLiteralExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public openBracketToken: TypeScript.ISyntaxToken;
        public expressions: TypeScript.ISeparatedSyntaxList;
        public closeBracketToken: TypeScript.ISyntaxToken;
        constructor(openBracketToken: TypeScript.ISyntaxToken, expressions: TypeScript.ISeparatedSyntaxList, closeBracketToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(openBracketToken: TypeScript.ISyntaxToken, expressions: TypeScript.ISeparatedSyntaxList, closeBracketToken: TypeScript.ISyntaxToken): ArrayLiteralExpressionSyntax;
        static create(openBracketToken: TypeScript.ISyntaxToken, closeBracketToken: TypeScript.ISyntaxToken): ArrayLiteralExpressionSyntax;
        static create1(): ArrayLiteralExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArrayLiteralExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArrayLiteralExpressionSyntax;
        public withOpenBracketToken(openBracketToken: TypeScript.ISyntaxToken): ArrayLiteralExpressionSyntax;
        public withExpressions(expressions: TypeScript.ISeparatedSyntaxList): ArrayLiteralExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ArrayLiteralExpressionSyntax;
        public withCloseBracketToken(closeBracketToken: TypeScript.ISyntaxToken): ArrayLiteralExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class OmittedExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IExpressionSyntax {
        constructor(parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isExpression(): boolean;
        public update(): OmittedExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): OmittedExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): OmittedExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ParenthesizedExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public openParenToken: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        public closeParenToken: TypeScript.ISyntaxToken;
        constructor(openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken): ParenthesizedExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): ParenthesizedExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParenthesizedExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParenthesizedExpressionSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): ParenthesizedExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ParenthesizedExpressionSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): ParenthesizedExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ArrowFunctionExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public equalsGreaterThanToken: TypeScript.ISyntaxToken;
        public body: TypeScript.ISyntaxNodeOrToken;
        constructor(equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken, parsedInStrictMode: boolean);
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArrowFunctionExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArrowFunctionExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class SimpleArrowFunctionExpressionSyntax extends ArrowFunctionExpressionSyntax {
        public identifier: TypeScript.ISyntaxToken;
        constructor(identifier: TypeScript.ISyntaxToken, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(identifier: TypeScript.ISyntaxToken, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax;
        static create1(identifier: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SimpleArrowFunctionExpressionSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): SimpleArrowFunctionExpressionSyntax;
        public withEqualsGreaterThanToken(equalsGreaterThanToken: TypeScript.ISyntaxToken): SimpleArrowFunctionExpressionSyntax;
        public withBody(body: TypeScript.ISyntaxNodeOrToken): SimpleArrowFunctionExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ParenthesizedArrowFunctionExpressionSyntax extends ArrowFunctionExpressionSyntax {
        public callSignature: CallSignatureSyntax;
        constructor(callSignature: CallSignatureSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(callSignature: CallSignatureSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, body: TypeScript.ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax;
        static create1(body: TypeScript.ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParenthesizedArrowFunctionExpressionSyntax;
        public withCallSignature(callSignature: CallSignatureSyntax): ParenthesizedArrowFunctionExpressionSyntax;
        public withEqualsGreaterThanToken(equalsGreaterThanToken: TypeScript.ISyntaxToken): ParenthesizedArrowFunctionExpressionSyntax;
        public withBody(body: TypeScript.ISyntaxNodeOrToken): ParenthesizedArrowFunctionExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class QualifiedNameSyntax extends TypeScript.SyntaxNode implements TypeScript.INameSyntax {
        public left: TypeScript.INameSyntax;
        public dotToken: TypeScript.ISyntaxToken;
        public right: TypeScript.ISyntaxToken;
        constructor(left: TypeScript.INameSyntax, dotToken: TypeScript.ISyntaxToken, right: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isName(): boolean;
        public isType(): boolean;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(left: TypeScript.INameSyntax, dotToken: TypeScript.ISyntaxToken, right: TypeScript.ISyntaxToken): QualifiedNameSyntax;
        static create1(left: TypeScript.INameSyntax, right: TypeScript.ISyntaxToken): QualifiedNameSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): QualifiedNameSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): QualifiedNameSyntax;
        public withLeft(left: TypeScript.INameSyntax): QualifiedNameSyntax;
        public withDotToken(dotToken: TypeScript.ISyntaxToken): QualifiedNameSyntax;
        public withRight(right: TypeScript.ISyntaxToken): QualifiedNameSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class TypeArgumentListSyntax extends TypeScript.SyntaxNode {
        public lessThanToken: TypeScript.ISyntaxToken;
        public typeArguments: TypeScript.ISeparatedSyntaxList;
        public greaterThanToken: TypeScript.ISyntaxToken;
        constructor(lessThanToken: TypeScript.ISyntaxToken, typeArguments: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(lessThanToken: TypeScript.ISyntaxToken, typeArguments: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeArgumentListSyntax;
        static create(lessThanToken: TypeScript.ISyntaxToken, greaterThanToken: TypeScript.ISyntaxToken): TypeArgumentListSyntax;
        static create1(): TypeArgumentListSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeArgumentListSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeArgumentListSyntax;
        public withLessThanToken(lessThanToken: TypeScript.ISyntaxToken): TypeArgumentListSyntax;
        public withTypeArguments(typeArguments: TypeScript.ISeparatedSyntaxList): TypeArgumentListSyntax;
        public withTypeArgument(typeArgument: TypeScript.ITypeSyntax): TypeArgumentListSyntax;
        public withGreaterThanToken(greaterThanToken: TypeScript.ISyntaxToken): TypeArgumentListSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ConstructorTypeSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeSyntax {
        public newKeyword: TypeScript.ISyntaxToken;
        public typeParameterList: TypeParameterListSyntax;
        public parameterList: ParameterListSyntax;
        public equalsGreaterThanToken: TypeScript.ISyntaxToken;
        public type: TypeScript.ITypeSyntax;
        constructor(newKeyword: TypeScript.ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isType(): boolean;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(newKeyword: TypeScript.ISyntaxToken, typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): ConstructorTypeSyntax;
        static create(newKeyword: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): ConstructorTypeSyntax;
        static create1(type: TypeScript.ITypeSyntax): ConstructorTypeSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstructorTypeSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstructorTypeSyntax;
        public withNewKeyword(newKeyword: TypeScript.ISyntaxToken): ConstructorTypeSyntax;
        public withTypeParameterList(typeParameterList: TypeParameterListSyntax): ConstructorTypeSyntax;
        public withParameterList(parameterList: ParameterListSyntax): ConstructorTypeSyntax;
        public withEqualsGreaterThanToken(equalsGreaterThanToken: TypeScript.ISyntaxToken): ConstructorTypeSyntax;
        public withType(type: TypeScript.ITypeSyntax): ConstructorTypeSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class FunctionTypeSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeSyntax {
        public typeParameterList: TypeParameterListSyntax;
        public parameterList: ParameterListSyntax;
        public equalsGreaterThanToken: TypeScript.ISyntaxToken;
        public type: TypeScript.ITypeSyntax;
        constructor(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isType(): boolean;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): FunctionTypeSyntax;
        static create(parameterList: ParameterListSyntax, equalsGreaterThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): FunctionTypeSyntax;
        static create1(type: TypeScript.ITypeSyntax): FunctionTypeSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionTypeSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionTypeSyntax;
        public withTypeParameterList(typeParameterList: TypeParameterListSyntax): FunctionTypeSyntax;
        public withParameterList(parameterList: ParameterListSyntax): FunctionTypeSyntax;
        public withEqualsGreaterThanToken(equalsGreaterThanToken: TypeScript.ISyntaxToken): FunctionTypeSyntax;
        public withType(type: TypeScript.ITypeSyntax): FunctionTypeSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ObjectTypeSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeSyntax {
        public openBraceToken: TypeScript.ISyntaxToken;
        public typeMembers: TypeScript.ISeparatedSyntaxList;
        public closeBraceToken: TypeScript.ISyntaxToken;
        constructor(openBraceToken: TypeScript.ISyntaxToken, typeMembers: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isType(): boolean;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(openBraceToken: TypeScript.ISyntaxToken, typeMembers: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): ObjectTypeSyntax;
        static create(openBraceToken: TypeScript.ISyntaxToken, closeBraceToken: TypeScript.ISyntaxToken): ObjectTypeSyntax;
        static create1(): ObjectTypeSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ObjectTypeSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ObjectTypeSyntax;
        public withOpenBraceToken(openBraceToken: TypeScript.ISyntaxToken): ObjectTypeSyntax;
        public withTypeMembers(typeMembers: TypeScript.ISeparatedSyntaxList): ObjectTypeSyntax;
        public withTypeMember(typeMember: TypeScript.ITypeMemberSyntax): ObjectTypeSyntax;
        public withCloseBraceToken(closeBraceToken: TypeScript.ISyntaxToken): ObjectTypeSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ArrayTypeSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeSyntax {
        public type: TypeScript.ITypeSyntax;
        public openBracketToken: TypeScript.ISyntaxToken;
        public closeBracketToken: TypeScript.ISyntaxToken;
        constructor(type: TypeScript.ITypeSyntax, openBracketToken: TypeScript.ISyntaxToken, closeBracketToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isType(): boolean;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(type: TypeScript.ITypeSyntax, openBracketToken: TypeScript.ISyntaxToken, closeBracketToken: TypeScript.ISyntaxToken): ArrayTypeSyntax;
        static create1(type: TypeScript.ITypeSyntax): ArrayTypeSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArrayTypeSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArrayTypeSyntax;
        public withType(type: TypeScript.ITypeSyntax): ArrayTypeSyntax;
        public withOpenBracketToken(openBracketToken: TypeScript.ISyntaxToken): ArrayTypeSyntax;
        public withCloseBracketToken(closeBracketToken: TypeScript.ISyntaxToken): ArrayTypeSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class GenericTypeSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeSyntax {
        public name: TypeScript.INameSyntax;
        public typeArgumentList: TypeArgumentListSyntax;
        constructor(name: TypeScript.INameSyntax, typeArgumentList: TypeArgumentListSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isType(): boolean;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(name: TypeScript.INameSyntax, typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax;
        static create1(name: TypeScript.INameSyntax): GenericTypeSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): GenericTypeSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): GenericTypeSyntax;
        public withName(name: TypeScript.INameSyntax): GenericTypeSyntax;
        public withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): GenericTypeSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class TypeQuerySyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeSyntax {
        public typeOfKeyword: TypeScript.ISyntaxToken;
        public name: TypeScript.INameSyntax;
        constructor(typeOfKeyword: TypeScript.ISyntaxToken, name: TypeScript.INameSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isType(): boolean;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(typeOfKeyword: TypeScript.ISyntaxToken, name: TypeScript.INameSyntax): TypeQuerySyntax;
        static create1(name: TypeScript.INameSyntax): TypeQuerySyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeQuerySyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeQuerySyntax;
        public withTypeOfKeyword(typeOfKeyword: TypeScript.ISyntaxToken): TypeQuerySyntax;
        public withName(name: TypeScript.INameSyntax): TypeQuerySyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class TypeAnnotationSyntax extends TypeScript.SyntaxNode {
        public colonToken: TypeScript.ISyntaxToken;
        public type: TypeScript.ITypeSyntax;
        constructor(colonToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(colonToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): TypeAnnotationSyntax;
        static create1(type: TypeScript.ITypeSyntax): TypeAnnotationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeAnnotationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeAnnotationSyntax;
        public withColonToken(colonToken: TypeScript.ISyntaxToken): TypeAnnotationSyntax;
        public withType(type: TypeScript.ITypeSyntax): TypeAnnotationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class BlockSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public openBraceToken: TypeScript.ISyntaxToken;
        public statements: TypeScript.ISyntaxList;
        public closeBraceToken: TypeScript.ISyntaxToken;
        constructor(openBraceToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(openBraceToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): BlockSyntax;
        static create(openBraceToken: TypeScript.ISyntaxToken, closeBraceToken: TypeScript.ISyntaxToken): BlockSyntax;
        static create1(): BlockSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): BlockSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): BlockSyntax;
        public withOpenBraceToken(openBraceToken: TypeScript.ISyntaxToken): BlockSyntax;
        public withStatements(statements: TypeScript.ISyntaxList): BlockSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): BlockSyntax;
        public withCloseBraceToken(closeBraceToken: TypeScript.ISyntaxToken): BlockSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ParameterSyntax extends TypeScript.SyntaxNode {
        public dotDotDotToken: TypeScript.ISyntaxToken;
        public publicOrPrivateKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public questionToken: TypeScript.ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public equalsValueClause: EqualsValueClauseSyntax;
        constructor(dotDotDotToken: TypeScript.ISyntaxToken, publicOrPrivateKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(dotDotDotToken: TypeScript.ISyntaxToken, publicOrPrivateKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax;
        static create(identifier: TypeScript.ISyntaxToken): ParameterSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): ParameterSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParameterSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParameterSyntax;
        public withDotDotDotToken(dotDotDotToken: TypeScript.ISyntaxToken): ParameterSyntax;
        public withPublicOrPrivateKeyword(publicOrPrivateKeyword: TypeScript.ISyntaxToken): ParameterSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): ParameterSyntax;
        public withQuestionToken(questionToken: TypeScript.ISyntaxToken): ParameterSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): ParameterSyntax;
        public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): ParameterSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class MemberAccessExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public expression: TypeScript.IExpressionSyntax;
        public dotToken: TypeScript.ISyntaxToken;
        public name: TypeScript.ISyntaxToken;
        constructor(expression: TypeScript.IExpressionSyntax, dotToken: TypeScript.ISyntaxToken, name: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(expression: TypeScript.IExpressionSyntax, dotToken: TypeScript.ISyntaxToken, name: TypeScript.ISyntaxToken): MemberAccessExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax, name: TypeScript.ISyntaxToken): MemberAccessExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberAccessExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberAccessExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): MemberAccessExpressionSyntax;
        public withDotToken(dotToken: TypeScript.ISyntaxToken): MemberAccessExpressionSyntax;
        public withName(name: TypeScript.ISyntaxToken): MemberAccessExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class PostfixUnaryExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public operand: TypeScript.IExpressionSyntax;
        public operatorToken: TypeScript.ISyntaxToken;
        private _kind;
        constructor(kind: TypeScript.SyntaxKind, operand: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public update(kind: TypeScript.SyntaxKind, operand: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken): PostfixUnaryExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): PostfixUnaryExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): PostfixUnaryExpressionSyntax;
        public withKind(kind: TypeScript.SyntaxKind): PostfixUnaryExpressionSyntax;
        public withOperand(operand: TypeScript.IExpressionSyntax): PostfixUnaryExpressionSyntax;
        public withOperatorToken(operatorToken: TypeScript.ISyntaxToken): PostfixUnaryExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ElementAccessExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public expression: TypeScript.IExpressionSyntax;
        public openBracketToken: TypeScript.ISyntaxToken;
        public argumentExpression: TypeScript.IExpressionSyntax;
        public closeBracketToken: TypeScript.ISyntaxToken;
        constructor(expression: TypeScript.IExpressionSyntax, openBracketToken: TypeScript.ISyntaxToken, argumentExpression: TypeScript.IExpressionSyntax, closeBracketToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(expression: TypeScript.IExpressionSyntax, openBracketToken: TypeScript.ISyntaxToken, argumentExpression: TypeScript.IExpressionSyntax, closeBracketToken: TypeScript.ISyntaxToken): ElementAccessExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax, argumentExpression: TypeScript.IExpressionSyntax): ElementAccessExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ElementAccessExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ElementAccessExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ElementAccessExpressionSyntax;
        public withOpenBracketToken(openBracketToken: TypeScript.ISyntaxToken): ElementAccessExpressionSyntax;
        public withArgumentExpression(argumentExpression: TypeScript.IExpressionSyntax): ElementAccessExpressionSyntax;
        public withCloseBracketToken(closeBracketToken: TypeScript.ISyntaxToken): ElementAccessExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class InvocationExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public expression: TypeScript.IExpressionSyntax;
        public argumentList: ArgumentListSyntax;
        constructor(expression: TypeScript.IExpressionSyntax, argumentList: ArgumentListSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(expression: TypeScript.IExpressionSyntax, argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): InvocationExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): InvocationExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): InvocationExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): InvocationExpressionSyntax;
        public withArgumentList(argumentList: ArgumentListSyntax): InvocationExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ArgumentListSyntax extends TypeScript.SyntaxNode {
        public typeArgumentList: TypeArgumentListSyntax;
        public openParenToken: TypeScript.ISyntaxToken;
        public arguments: TypeScript.ISeparatedSyntaxList;
        public closeParenToken: TypeScript.ISyntaxToken;
        constructor(typeArgumentList: TypeArgumentListSyntax, openParenToken: TypeScript.ISyntaxToken, arguments: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(typeArgumentList: TypeArgumentListSyntax, openParenToken: TypeScript.ISyntaxToken, _arguments: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): ArgumentListSyntax;
        static create(openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken): ArgumentListSyntax;
        static create1(): ArgumentListSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArgumentListSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ArgumentListSyntax;
        public withTypeArgumentList(typeArgumentList: TypeArgumentListSyntax): ArgumentListSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): ArgumentListSyntax;
        public withArguments(_arguments: TypeScript.ISeparatedSyntaxList): ArgumentListSyntax;
        public withArgument(_argument: TypeScript.IExpressionSyntax): ArgumentListSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): ArgumentListSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class BinaryExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IExpressionSyntax {
        public left: TypeScript.IExpressionSyntax;
        public operatorToken: TypeScript.ISyntaxToken;
        public right: TypeScript.IExpressionSyntax;
        private _kind;
        constructor(kind: TypeScript.SyntaxKind, left: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken, right: TypeScript.IExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isExpression(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public update(kind: TypeScript.SyntaxKind, left: TypeScript.IExpressionSyntax, operatorToken: TypeScript.ISyntaxToken, right: TypeScript.IExpressionSyntax): BinaryExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): BinaryExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): BinaryExpressionSyntax;
        public withKind(kind: TypeScript.SyntaxKind): BinaryExpressionSyntax;
        public withLeft(left: TypeScript.IExpressionSyntax): BinaryExpressionSyntax;
        public withOperatorToken(operatorToken: TypeScript.ISyntaxToken): BinaryExpressionSyntax;
        public withRight(right: TypeScript.IExpressionSyntax): BinaryExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ConditionalExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IExpressionSyntax {
        public condition: TypeScript.IExpressionSyntax;
        public questionToken: TypeScript.ISyntaxToken;
        public whenTrue: TypeScript.IExpressionSyntax;
        public colonToken: TypeScript.ISyntaxToken;
        public whenFalse: TypeScript.IExpressionSyntax;
        constructor(condition: TypeScript.IExpressionSyntax, questionToken: TypeScript.ISyntaxToken, whenTrue: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, whenFalse: TypeScript.IExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isExpression(): boolean;
        public update(condition: TypeScript.IExpressionSyntax, questionToken: TypeScript.ISyntaxToken, whenTrue: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, whenFalse: TypeScript.IExpressionSyntax): ConditionalExpressionSyntax;
        static create1(condition: TypeScript.IExpressionSyntax, whenTrue: TypeScript.IExpressionSyntax, whenFalse: TypeScript.IExpressionSyntax): ConditionalExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConditionalExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConditionalExpressionSyntax;
        public withCondition(condition: TypeScript.IExpressionSyntax): ConditionalExpressionSyntax;
        public withQuestionToken(questionToken: TypeScript.ISyntaxToken): ConditionalExpressionSyntax;
        public withWhenTrue(whenTrue: TypeScript.IExpressionSyntax): ConditionalExpressionSyntax;
        public withColonToken(colonToken: TypeScript.ISyntaxToken): ConditionalExpressionSyntax;
        public withWhenFalse(whenFalse: TypeScript.IExpressionSyntax): ConditionalExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ConstructSignatureSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeMemberSyntax {
        public newKeyword: TypeScript.ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        constructor(newKeyword: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isTypeMember(): boolean;
        public update(newKeyword: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax): ConstructSignatureSyntax;
        static create1(): ConstructSignatureSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstructSignatureSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstructSignatureSyntax;
        public withNewKeyword(newKeyword: TypeScript.ISyntaxToken): ConstructSignatureSyntax;
        public withCallSignature(callSignature: CallSignatureSyntax): ConstructSignatureSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class MethodSignatureSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeMemberSyntax {
        public propertyName: TypeScript.ISyntaxToken;
        public questionToken: TypeScript.ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        constructor(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isTypeMember(): boolean;
        public update(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax;
        static create(propertyName: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax): MethodSignatureSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): MethodSignatureSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): MethodSignatureSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): MethodSignatureSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): MethodSignatureSyntax;
        public withQuestionToken(questionToken: TypeScript.ISyntaxToken): MethodSignatureSyntax;
        public withCallSignature(callSignature: CallSignatureSyntax): MethodSignatureSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class IndexSignatureSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeMemberSyntax, TypeScript.IClassElementSyntax {
        public openBracketToken: TypeScript.ISyntaxToken;
        public parameter: ParameterSyntax;
        public closeBracketToken: TypeScript.ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        constructor(openBracketToken: TypeScript.ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isTypeMember(): boolean;
        public isClassElement(): boolean;
        public update(openBracketToken: TypeScript.ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax;
        static create(openBracketToken: TypeScript.ISyntaxToken, parameter: ParameterSyntax, closeBracketToken: TypeScript.ISyntaxToken): IndexSignatureSyntax;
        static create1(parameter: ParameterSyntax): IndexSignatureSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): IndexSignatureSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): IndexSignatureSyntax;
        public withOpenBracketToken(openBracketToken: TypeScript.ISyntaxToken): IndexSignatureSyntax;
        public withParameter(parameter: ParameterSyntax): IndexSignatureSyntax;
        public withCloseBracketToken(closeBracketToken: TypeScript.ISyntaxToken): IndexSignatureSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): IndexSignatureSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class PropertySignatureSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeMemberSyntax {
        public propertyName: TypeScript.ISyntaxToken;
        public questionToken: TypeScript.ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        constructor(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isTypeMember(): boolean;
        public update(propertyName: TypeScript.ISyntaxToken, questionToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax;
        static create(propertyName: TypeScript.ISyntaxToken): PropertySignatureSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): PropertySignatureSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): PropertySignatureSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): PropertySignatureSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): PropertySignatureSyntax;
        public withQuestionToken(questionToken: TypeScript.ISyntaxToken): PropertySignatureSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): PropertySignatureSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class CallSignatureSyntax extends TypeScript.SyntaxNode implements TypeScript.ITypeMemberSyntax {
        public typeParameterList: TypeParameterListSyntax;
        public parameterList: ParameterListSyntax;
        public typeAnnotation: TypeAnnotationSyntax;
        constructor(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isTypeMember(): boolean;
        public update(typeParameterList: TypeParameterListSyntax, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax;
        static create(parameterList: ParameterListSyntax): CallSignatureSyntax;
        static create1(): CallSignatureSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): CallSignatureSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): CallSignatureSyntax;
        public withTypeParameterList(typeParameterList: TypeParameterListSyntax): CallSignatureSyntax;
        public withParameterList(parameterList: ParameterListSyntax): CallSignatureSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): CallSignatureSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ParameterListSyntax extends TypeScript.SyntaxNode {
        public openParenToken: TypeScript.ISyntaxToken;
        public parameters: TypeScript.ISeparatedSyntaxList;
        public closeParenToken: TypeScript.ISyntaxToken;
        constructor(openParenToken: TypeScript.ISyntaxToken, parameters: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(openParenToken: TypeScript.ISyntaxToken, parameters: TypeScript.ISeparatedSyntaxList, closeParenToken: TypeScript.ISyntaxToken): ParameterListSyntax;
        static create(openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken): ParameterListSyntax;
        static create1(): ParameterListSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParameterListSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ParameterListSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): ParameterListSyntax;
        public withParameters(parameters: TypeScript.ISeparatedSyntaxList): ParameterListSyntax;
        public withParameter(parameter: ParameterSyntax): ParameterListSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): ParameterListSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class TypeParameterListSyntax extends TypeScript.SyntaxNode {
        public lessThanToken: TypeScript.ISyntaxToken;
        public typeParameters: TypeScript.ISeparatedSyntaxList;
        public greaterThanToken: TypeScript.ISyntaxToken;
        constructor(lessThanToken: TypeScript.ISyntaxToken, typeParameters: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(lessThanToken: TypeScript.ISyntaxToken, typeParameters: TypeScript.ISeparatedSyntaxList, greaterThanToken: TypeScript.ISyntaxToken): TypeParameterListSyntax;
        static create(lessThanToken: TypeScript.ISyntaxToken, greaterThanToken: TypeScript.ISyntaxToken): TypeParameterListSyntax;
        static create1(): TypeParameterListSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeParameterListSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeParameterListSyntax;
        public withLessThanToken(lessThanToken: TypeScript.ISyntaxToken): TypeParameterListSyntax;
        public withTypeParameters(typeParameters: TypeScript.ISeparatedSyntaxList): TypeParameterListSyntax;
        public withTypeParameter(typeParameter: TypeParameterSyntax): TypeParameterListSyntax;
        public withGreaterThanToken(greaterThanToken: TypeScript.ISyntaxToken): TypeParameterListSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class TypeParameterSyntax extends TypeScript.SyntaxNode {
        public identifier: TypeScript.ISyntaxToken;
        public constraint: ConstraintSyntax;
        constructor(identifier: TypeScript.ISyntaxToken, constraint: ConstraintSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(identifier: TypeScript.ISyntaxToken, constraint: ConstraintSyntax): TypeParameterSyntax;
        static create(identifier: TypeScript.ISyntaxToken): TypeParameterSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): TypeParameterSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeParameterSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeParameterSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): TypeParameterSyntax;
        public withConstraint(constraint: ConstraintSyntax): TypeParameterSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ConstraintSyntax extends TypeScript.SyntaxNode {
        public extendsKeyword: TypeScript.ISyntaxToken;
        public type: TypeScript.ITypeSyntax;
        constructor(extendsKeyword: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(extendsKeyword: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax): ConstraintSyntax;
        static create1(type: TypeScript.ITypeSyntax): ConstraintSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstraintSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstraintSyntax;
        public withExtendsKeyword(extendsKeyword: TypeScript.ISyntaxToken): ConstraintSyntax;
        public withType(type: TypeScript.ITypeSyntax): ConstraintSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ElseClauseSyntax extends TypeScript.SyntaxNode {
        public elseKeyword: TypeScript.ISyntaxToken;
        public statement: TypeScript.IStatementSyntax;
        constructor(elseKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(elseKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): ElseClauseSyntax;
        static create1(statement: TypeScript.IStatementSyntax): ElseClauseSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ElseClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ElseClauseSyntax;
        public withElseKeyword(elseKeyword: TypeScript.ISyntaxToken): ElseClauseSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): ElseClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class IfStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public ifKeyword: TypeScript.ISyntaxToken;
        public openParenToken: TypeScript.ISyntaxToken;
        public condition: TypeScript.IExpressionSyntax;
        public closeParenToken: TypeScript.ISyntaxToken;
        public statement: TypeScript.IStatementSyntax;
        public elseClause: ElseClauseSyntax;
        constructor(ifKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, elseClause: ElseClauseSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(ifKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, elseClause: ElseClauseSyntax): IfStatementSyntax;
        static create(ifKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): IfStatementSyntax;
        static create1(condition: TypeScript.IExpressionSyntax, statement: TypeScript.IStatementSyntax): IfStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): IfStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): IfStatementSyntax;
        public withIfKeyword(ifKeyword: TypeScript.ISyntaxToken): IfStatementSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): IfStatementSyntax;
        public withCondition(condition: TypeScript.IExpressionSyntax): IfStatementSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): IfStatementSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): IfStatementSyntax;
        public withElseClause(elseClause: ElseClauseSyntax): IfStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ExpressionStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public expression: TypeScript.IExpressionSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): ExpressionStatementSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): ExpressionStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ExpressionStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ExpressionStatementSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ExpressionStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): ExpressionStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ConstructorDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IClassElementSyntax {
        public constructorKeyword: TypeScript.ISyntaxToken;
        public parameterList: ParameterListSyntax;
        public block: BlockSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(constructorKeyword: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isClassElement(): boolean;
        public update(constructorKeyword: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): ConstructorDeclarationSyntax;
        static create(constructorKeyword: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax): ConstructorDeclarationSyntax;
        static create1(): ConstructorDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstructorDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ConstructorDeclarationSyntax;
        public withConstructorKeyword(constructorKeyword: TypeScript.ISyntaxToken): ConstructorDeclarationSyntax;
        public withParameterList(parameterList: ParameterListSyntax): ConstructorDeclarationSyntax;
        public withBlock(block: BlockSyntax): ConstructorDeclarationSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): ConstructorDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class MemberFunctionDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IMemberDeclarationSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public propertyName: TypeScript.ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, propertyName: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isMemberDeclaration(): boolean;
        public isClassElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, propertyName: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, semicolonToken: TypeScript.ISyntaxToken): MemberFunctionDeclarationSyntax;
        static create(propertyName: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax): MemberFunctionDeclarationSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): MemberFunctionDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberFunctionDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberFunctionDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): MemberFunctionDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): MemberFunctionDeclarationSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): MemberFunctionDeclarationSyntax;
        public withCallSignature(callSignature: CallSignatureSyntax): MemberFunctionDeclarationSyntax;
        public withBlock(block: BlockSyntax): MemberFunctionDeclarationSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): MemberFunctionDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class MemberAccessorDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IMemberDeclarationSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public propertyName: TypeScript.ISyntaxToken;
        public parameterList: ParameterListSyntax;
        public block: BlockSyntax;
        constructor(modifiers: TypeScript.ISyntaxList, propertyName: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, parsedInStrictMode: boolean);
        public isMemberDeclaration(): boolean;
        public isClassElement(): boolean;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberAccessorDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberAccessorDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class GetMemberAccessorDeclarationSyntax extends MemberAccessorDeclarationSyntax {
        public getKeyword: TypeScript.ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        constructor(modifiers: TypeScript.ISyntaxList, getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(modifiers: TypeScript.ISyntaxList, getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax;
        static create(getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): GetMemberAccessorDeclarationSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): GetMemberAccessorDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): GetMemberAccessorDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): GetMemberAccessorDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): GetMemberAccessorDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): GetMemberAccessorDeclarationSyntax;
        public withGetKeyword(getKeyword: TypeScript.ISyntaxToken): GetMemberAccessorDeclarationSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): GetMemberAccessorDeclarationSyntax;
        public withParameterList(parameterList: ParameterListSyntax): GetMemberAccessorDeclarationSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): GetMemberAccessorDeclarationSyntax;
        public withBlock(block: BlockSyntax): GetMemberAccessorDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class SetMemberAccessorDeclarationSyntax extends MemberAccessorDeclarationSyntax {
        public setKeyword: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(modifiers: TypeScript.ISyntaxList, setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax;
        static create(setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, parameterList: ParameterListSyntax, block: BlockSyntax): SetMemberAccessorDeclarationSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): SetMemberAccessorDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SetMemberAccessorDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SetMemberAccessorDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): SetMemberAccessorDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): SetMemberAccessorDeclarationSyntax;
        public withSetKeyword(setKeyword: TypeScript.ISyntaxToken): SetMemberAccessorDeclarationSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): SetMemberAccessorDeclarationSyntax;
        public withParameterList(parameterList: ParameterListSyntax): SetMemberAccessorDeclarationSyntax;
        public withBlock(block: BlockSyntax): SetMemberAccessorDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class MemberVariableDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IMemberDeclarationSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public variableDeclarator: VariableDeclaratorSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isMemberDeclaration(): boolean;
        public isClassElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, variableDeclarator: VariableDeclaratorSyntax, semicolonToken: TypeScript.ISyntaxToken): MemberVariableDeclarationSyntax;
        static create(variableDeclarator: VariableDeclaratorSyntax, semicolonToken: TypeScript.ISyntaxToken): MemberVariableDeclarationSyntax;
        static create1(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberVariableDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): MemberVariableDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): MemberVariableDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): MemberVariableDeclarationSyntax;
        public withVariableDeclarator(variableDeclarator: VariableDeclaratorSyntax): MemberVariableDeclarationSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): MemberVariableDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ThrowStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public throwKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(throwKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(throwKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): ThrowStatementSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): ThrowStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ThrowStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ThrowStatementSyntax;
        public withThrowKeyword(throwKeyword: TypeScript.ISyntaxToken): ThrowStatementSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ThrowStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): ThrowStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ReturnStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public returnKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(returnKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(returnKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, semicolonToken: TypeScript.ISyntaxToken): ReturnStatementSyntax;
        static create(returnKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): ReturnStatementSyntax;
        static create1(): ReturnStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ReturnStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ReturnStatementSyntax;
        public withReturnKeyword(returnKeyword: TypeScript.ISyntaxToken): ReturnStatementSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ReturnStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): ReturnStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ObjectCreationExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public newKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        public argumentList: ArgumentListSyntax;
        constructor(newKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, argumentList: ArgumentListSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(newKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax;
        static create(newKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): ObjectCreationExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): ObjectCreationExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ObjectCreationExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ObjectCreationExpressionSyntax;
        public withNewKeyword(newKeyword: TypeScript.ISyntaxToken): ObjectCreationExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ObjectCreationExpressionSyntax;
        public withArgumentList(argumentList: ArgumentListSyntax): ObjectCreationExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class SwitchStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public switchKeyword: TypeScript.ISyntaxToken;
        public openParenToken: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        public closeParenToken: TypeScript.ISyntaxToken;
        public openBraceToken: TypeScript.ISyntaxToken;
        public switchClauses: TypeScript.ISyntaxList;
        public closeBraceToken: TypeScript.ISyntaxToken;
        constructor(switchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, switchClauses: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(switchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, switchClauses: TypeScript.ISyntaxList, closeBraceToken: TypeScript.ISyntaxToken): SwitchStatementSyntax;
        static create(switchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, closeBraceToken: TypeScript.ISyntaxToken): SwitchStatementSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): SwitchStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SwitchStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SwitchStatementSyntax;
        public withSwitchKeyword(switchKeyword: TypeScript.ISyntaxToken): SwitchStatementSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): SwitchStatementSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): SwitchStatementSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): SwitchStatementSyntax;
        public withOpenBraceToken(openBraceToken: TypeScript.ISyntaxToken): SwitchStatementSyntax;
        public withSwitchClauses(switchClauses: TypeScript.ISyntaxList): SwitchStatementSyntax;
        public withSwitchClause(switchClause: SwitchClauseSyntax): SwitchStatementSyntax;
        public withCloseBraceToken(closeBraceToken: TypeScript.ISyntaxToken): SwitchStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class SwitchClauseSyntax extends TypeScript.SyntaxNode implements TypeScript.ISwitchClauseSyntax {
        public colonToken: TypeScript.ISyntaxToken;
        public statements: TypeScript.ISyntaxList;
        constructor(colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, parsedInStrictMode: boolean);
        public isSwitchClause(): boolean;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SwitchClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SwitchClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class CaseSwitchClauseSyntax extends SwitchClauseSyntax {
        public caseKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        constructor(caseKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(caseKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): CaseSwitchClauseSyntax;
        static create(caseKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, colonToken: TypeScript.ISyntaxToken): CaseSwitchClauseSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): CaseSwitchClauseSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): CaseSwitchClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): CaseSwitchClauseSyntax;
        public withCaseKeyword(caseKeyword: TypeScript.ISyntaxToken): CaseSwitchClauseSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): CaseSwitchClauseSyntax;
        public withColonToken(colonToken: TypeScript.ISyntaxToken): CaseSwitchClauseSyntax;
        public withStatements(statements: TypeScript.ISyntaxList): CaseSwitchClauseSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): CaseSwitchClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class DefaultSwitchClauseSyntax extends SwitchClauseSyntax {
        public defaultKeyword: TypeScript.ISyntaxToken;
        constructor(defaultKeyword: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(defaultKeyword: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statements: TypeScript.ISyntaxList): DefaultSwitchClauseSyntax;
        static create(defaultKeyword: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken): DefaultSwitchClauseSyntax;
        static create1(): DefaultSwitchClauseSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): DefaultSwitchClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): DefaultSwitchClauseSyntax;
        public withDefaultKeyword(defaultKeyword: TypeScript.ISyntaxToken): DefaultSwitchClauseSyntax;
        public withColonToken(colonToken: TypeScript.ISyntaxToken): DefaultSwitchClauseSyntax;
        public withStatements(statements: TypeScript.ISyntaxList): DefaultSwitchClauseSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): DefaultSwitchClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class BreakStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public breakKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(breakKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(breakKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): BreakStatementSyntax;
        static create(breakKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): BreakStatementSyntax;
        static create1(): BreakStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): BreakStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): BreakStatementSyntax;
        public withBreakKeyword(breakKeyword: TypeScript.ISyntaxToken): BreakStatementSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): BreakStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): BreakStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ContinueStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public continueKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(continueKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(continueKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): ContinueStatementSyntax;
        static create(continueKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): ContinueStatementSyntax;
        static create1(): ContinueStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ContinueStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ContinueStatementSyntax;
        public withContinueKeyword(continueKeyword: TypeScript.ISyntaxToken): ContinueStatementSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): ContinueStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): ContinueStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class IterationStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public openParenToken: TypeScript.ISyntaxToken;
        public closeParenToken: TypeScript.ISyntaxToken;
        public statement: TypeScript.IStatementSyntax;
        constructor(openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): IterationStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): IterationStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class BaseForStatementSyntax extends IterationStatementSyntax {
        public forKeyword: TypeScript.ISyntaxToken;
        public variableDeclaration: VariableDeclarationSyntax;
        constructor(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): BaseForStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): BaseForStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ForStatementSyntax extends BaseForStatementSyntax {
        public initializer: TypeScript.IExpressionSyntax;
        public firstSemicolonToken: TypeScript.ISyntaxToken;
        public condition: TypeScript.IExpressionSyntax;
        public secondSemicolonToken: TypeScript.ISyntaxToken;
        public incrementor: TypeScript.IExpressionSyntax;
        constructor(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: TypeScript.IExpressionSyntax, firstSemicolonToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, secondSemicolonToken: TypeScript.ISyntaxToken, incrementor: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, initializer: TypeScript.IExpressionSyntax, firstSemicolonToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, secondSemicolonToken: TypeScript.ISyntaxToken, incrementor: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): ForStatementSyntax;
        static create(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, firstSemicolonToken: TypeScript.ISyntaxToken, secondSemicolonToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): ForStatementSyntax;
        static create1(statement: TypeScript.IStatementSyntax): ForStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ForStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ForStatementSyntax;
        public withForKeyword(forKeyword: TypeScript.ISyntaxToken): ForStatementSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): ForStatementSyntax;
        public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForStatementSyntax;
        public withInitializer(initializer: TypeScript.IExpressionSyntax): ForStatementSyntax;
        public withFirstSemicolonToken(firstSemicolonToken: TypeScript.ISyntaxToken): ForStatementSyntax;
        public withCondition(condition: TypeScript.IExpressionSyntax): ForStatementSyntax;
        public withSecondSemicolonToken(secondSemicolonToken: TypeScript.ISyntaxToken): ForStatementSyntax;
        public withIncrementor(incrementor: TypeScript.IExpressionSyntax): ForStatementSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): ForStatementSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): ForStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ForInStatementSyntax extends BaseForStatementSyntax {
        public left: TypeScript.IExpressionSyntax;
        public inKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        constructor(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: TypeScript.IExpressionSyntax, inKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, variableDeclaration: VariableDeclarationSyntax, left: TypeScript.IExpressionSyntax, inKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): ForInStatementSyntax;
        static create(forKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, inKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): ForInStatementSyntax;
        static create1(expression: TypeScript.IExpressionSyntax, statement: TypeScript.IStatementSyntax): ForInStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ForInStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ForInStatementSyntax;
        public withForKeyword(forKeyword: TypeScript.ISyntaxToken): ForInStatementSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): ForInStatementSyntax;
        public withVariableDeclaration(variableDeclaration: VariableDeclarationSyntax): ForInStatementSyntax;
        public withLeft(left: TypeScript.IExpressionSyntax): ForInStatementSyntax;
        public withInKeyword(inKeyword: TypeScript.ISyntaxToken): ForInStatementSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): ForInStatementSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): ForInStatementSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): ForInStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class WhileStatementSyntax extends IterationStatementSyntax {
        public whileKeyword: TypeScript.ISyntaxToken;
        public condition: TypeScript.IExpressionSyntax;
        constructor(whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): WhileStatementSyntax;
        static create1(condition: TypeScript.IExpressionSyntax, statement: TypeScript.IStatementSyntax): WhileStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): WhileStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): WhileStatementSyntax;
        public withWhileKeyword(whileKeyword: TypeScript.ISyntaxToken): WhileStatementSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): WhileStatementSyntax;
        public withCondition(condition: TypeScript.IExpressionSyntax): WhileStatementSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): WhileStatementSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): WhileStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class WithStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public withKeyword: TypeScript.ISyntaxToken;
        public openParenToken: TypeScript.ISyntaxToken;
        public condition: TypeScript.IExpressionSyntax;
        public closeParenToken: TypeScript.ISyntaxToken;
        public statement: TypeScript.IStatementSyntax;
        constructor(withKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(withKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): WithStatementSyntax;
        static create1(condition: TypeScript.IExpressionSyntax, statement: TypeScript.IStatementSyntax): WithStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): WithStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): WithStatementSyntax;
        public withWithKeyword(withKeyword: TypeScript.ISyntaxToken): WithStatementSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): WithStatementSyntax;
        public withCondition(condition: TypeScript.IExpressionSyntax): WithStatementSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): WithStatementSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): WithStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class EnumDeclarationSyntax extends TypeScript.SyntaxNode implements TypeScript.IModuleElementSyntax {
        public modifiers: TypeScript.ISyntaxList;
        public enumKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public openBraceToken: TypeScript.ISyntaxToken;
        public enumElements: TypeScript.ISeparatedSyntaxList;
        public closeBraceToken: TypeScript.ISyntaxToken;
        constructor(modifiers: TypeScript.ISyntaxList, enumKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, enumElements: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isModuleElement(): boolean;
        public update(modifiers: TypeScript.ISyntaxList, enumKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, enumElements: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        static create(enumKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, openBraceToken: TypeScript.ISyntaxToken, closeBraceToken: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): EnumDeclarationSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): EnumDeclarationSyntax;
        public withModifiers(modifiers: TypeScript.ISyntaxList): EnumDeclarationSyntax;
        public withModifier(modifier: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        public withEnumKeyword(enumKeyword: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        public withOpenBraceToken(openBraceToken: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        public withEnumElements(enumElements: TypeScript.ISeparatedSyntaxList): EnumDeclarationSyntax;
        public withEnumElement(enumElement: EnumElementSyntax): EnumDeclarationSyntax;
        public withCloseBraceToken(closeBraceToken: TypeScript.ISyntaxToken): EnumDeclarationSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class EnumElementSyntax extends TypeScript.SyntaxNode {
        public propertyName: TypeScript.ISyntaxToken;
        public equalsValueClause: EqualsValueClauseSyntax;
        constructor(propertyName: TypeScript.ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(propertyName: TypeScript.ISyntaxToken, equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax;
        static create(propertyName: TypeScript.ISyntaxToken): EnumElementSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): EnumElementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): EnumElementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): EnumElementSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): EnumElementSyntax;
        public withEqualsValueClause(equalsValueClause: EqualsValueClauseSyntax): EnumElementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class CastExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public lessThanToken: TypeScript.ISyntaxToken;
        public type: TypeScript.ITypeSyntax;
        public greaterThanToken: TypeScript.ISyntaxToken;
        public expression: TypeScript.IUnaryExpressionSyntax;
        constructor(lessThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, greaterThanToken: TypeScript.ISyntaxToken, expression: TypeScript.IUnaryExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(lessThanToken: TypeScript.ISyntaxToken, type: TypeScript.ITypeSyntax, greaterThanToken: TypeScript.ISyntaxToken, expression: TypeScript.IUnaryExpressionSyntax): CastExpressionSyntax;
        static create1(type: TypeScript.ITypeSyntax, expression: TypeScript.IUnaryExpressionSyntax): CastExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): CastExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): CastExpressionSyntax;
        public withLessThanToken(lessThanToken: TypeScript.ISyntaxToken): CastExpressionSyntax;
        public withType(type: TypeScript.ITypeSyntax): CastExpressionSyntax;
        public withGreaterThanToken(greaterThanToken: TypeScript.ISyntaxToken): CastExpressionSyntax;
        public withExpression(expression: TypeScript.IUnaryExpressionSyntax): CastExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class ObjectLiteralExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public openBraceToken: TypeScript.ISyntaxToken;
        public propertyAssignments: TypeScript.ISeparatedSyntaxList;
        public closeBraceToken: TypeScript.ISyntaxToken;
        constructor(openBraceToken: TypeScript.ISyntaxToken, propertyAssignments: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(openBraceToken: TypeScript.ISyntaxToken, propertyAssignments: TypeScript.ISeparatedSyntaxList, closeBraceToken: TypeScript.ISyntaxToken): ObjectLiteralExpressionSyntax;
        static create(openBraceToken: TypeScript.ISyntaxToken, closeBraceToken: TypeScript.ISyntaxToken): ObjectLiteralExpressionSyntax;
        static create1(): ObjectLiteralExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): ObjectLiteralExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): ObjectLiteralExpressionSyntax;
        public withOpenBraceToken(openBraceToken: TypeScript.ISyntaxToken): ObjectLiteralExpressionSyntax;
        public withPropertyAssignments(propertyAssignments: TypeScript.ISeparatedSyntaxList): ObjectLiteralExpressionSyntax;
        public withPropertyAssignment(propertyAssignment: PropertyAssignmentSyntax): ObjectLiteralExpressionSyntax;
        public withCloseBraceToken(closeBraceToken: TypeScript.ISyntaxToken): ObjectLiteralExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class PropertyAssignmentSyntax extends TypeScript.SyntaxNode {
        public propertyName: TypeScript.ISyntaxToken;
        constructor(propertyName: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): PropertyAssignmentSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): PropertyAssignmentSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class SimplePropertyAssignmentSyntax extends PropertyAssignmentSyntax {
        public colonToken: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        constructor(propertyName: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(propertyName: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): SimplePropertyAssignmentSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): SimplePropertyAssignmentSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SimplePropertyAssignmentSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SimplePropertyAssignmentSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): SimplePropertyAssignmentSyntax;
        public withColonToken(colonToken: TypeScript.ISyntaxToken): SimplePropertyAssignmentSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): SimplePropertyAssignmentSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class FunctionPropertyAssignmentSyntax extends PropertyAssignmentSyntax {
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        constructor(propertyName: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(propertyName: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionPropertyAssignmentSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): FunctionPropertyAssignmentSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionPropertyAssignmentSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionPropertyAssignmentSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): FunctionPropertyAssignmentSyntax;
        public withCallSignature(callSignature: CallSignatureSyntax): FunctionPropertyAssignmentSyntax;
        public withBlock(block: BlockSyntax): FunctionPropertyAssignmentSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class AccessorPropertyAssignmentSyntax extends PropertyAssignmentSyntax {
        public openParenToken: TypeScript.ISyntaxToken;
        public closeParenToken: TypeScript.ISyntaxToken;
        public block: BlockSyntax;
        constructor(propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, block: BlockSyntax, parsedInStrictMode: boolean);
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): AccessorPropertyAssignmentSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): AccessorPropertyAssignmentSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class GetAccessorPropertyAssignmentSyntax extends AccessorPropertyAssignmentSyntax {
        public getKeyword: TypeScript.ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        constructor(getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax;
        static create(getKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, block: BlockSyntax): GetAccessorPropertyAssignmentSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken): GetAccessorPropertyAssignmentSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): GetAccessorPropertyAssignmentSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): GetAccessorPropertyAssignmentSyntax;
        public withGetKeyword(getKeyword: TypeScript.ISyntaxToken): GetAccessorPropertyAssignmentSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): GetAccessorPropertyAssignmentSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): GetAccessorPropertyAssignmentSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): GetAccessorPropertyAssignmentSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): GetAccessorPropertyAssignmentSyntax;
        public withBlock(block: BlockSyntax): GetAccessorPropertyAssignmentSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class SetAccessorPropertyAssignmentSyntax extends AccessorPropertyAssignmentSyntax {
        public setKeyword: TypeScript.ISyntaxToken;
        public parameter: ParameterSyntax;
        constructor(setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, parameter: ParameterSyntax, closeParenToken: TypeScript.ISyntaxToken, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(setKeyword: TypeScript.ISyntaxToken, propertyName: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, parameter: ParameterSyntax, closeParenToken: TypeScript.ISyntaxToken, block: BlockSyntax): SetAccessorPropertyAssignmentSyntax;
        static create1(propertyName: TypeScript.ISyntaxToken, parameter: ParameterSyntax): SetAccessorPropertyAssignmentSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): SetAccessorPropertyAssignmentSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): SetAccessorPropertyAssignmentSyntax;
        public withSetKeyword(setKeyword: TypeScript.ISyntaxToken): SetAccessorPropertyAssignmentSyntax;
        public withPropertyName(propertyName: TypeScript.ISyntaxToken): SetAccessorPropertyAssignmentSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): SetAccessorPropertyAssignmentSyntax;
        public withParameter(parameter: ParameterSyntax): SetAccessorPropertyAssignmentSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): SetAccessorPropertyAssignmentSyntax;
        public withBlock(block: BlockSyntax): SetAccessorPropertyAssignmentSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class FunctionExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public functionKeyword: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public callSignature: CallSignatureSyntax;
        public block: BlockSyntax;
        constructor(functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(functionKeyword: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax;
        static create(functionKeyword: TypeScript.ISyntaxToken, callSignature: CallSignatureSyntax, block: BlockSyntax): FunctionExpressionSyntax;
        static create1(): FunctionExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): FunctionExpressionSyntax;
        public withFunctionKeyword(functionKeyword: TypeScript.ISyntaxToken): FunctionExpressionSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): FunctionExpressionSyntax;
        public withCallSignature(callSignature: CallSignatureSyntax): FunctionExpressionSyntax;
        public withBlock(block: BlockSyntax): FunctionExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class EmptyStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(semicolonToken: TypeScript.ISyntaxToken): EmptyStatementSyntax;
        static create1(): EmptyStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): EmptyStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): EmptyStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): EmptyStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class TryStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public tryKeyword: TypeScript.ISyntaxToken;
        public block: BlockSyntax;
        public catchClause: CatchClauseSyntax;
        public finallyClause: FinallyClauseSyntax;
        constructor(tryKeyword: TypeScript.ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(tryKeyword: TypeScript.ISyntaxToken, block: BlockSyntax, catchClause: CatchClauseSyntax, finallyClause: FinallyClauseSyntax): TryStatementSyntax;
        static create(tryKeyword: TypeScript.ISyntaxToken, block: BlockSyntax): TryStatementSyntax;
        static create1(): TryStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): TryStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): TryStatementSyntax;
        public withTryKeyword(tryKeyword: TypeScript.ISyntaxToken): TryStatementSyntax;
        public withBlock(block: BlockSyntax): TryStatementSyntax;
        public withCatchClause(catchClause: CatchClauseSyntax): TryStatementSyntax;
        public withFinallyClause(finallyClause: FinallyClauseSyntax): TryStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class CatchClauseSyntax extends TypeScript.SyntaxNode {
        public catchKeyword: TypeScript.ISyntaxToken;
        public openParenToken: TypeScript.ISyntaxToken;
        public identifier: TypeScript.ISyntaxToken;
        public typeAnnotation: TypeAnnotationSyntax;
        public closeParenToken: TypeScript.ISyntaxToken;
        public block: BlockSyntax;
        constructor(catchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: TypeScript.ISyntaxToken, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(catchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, typeAnnotation: TypeAnnotationSyntax, closeParenToken: TypeScript.ISyntaxToken, block: BlockSyntax): CatchClauseSyntax;
        static create(catchKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, identifier: TypeScript.ISyntaxToken, closeParenToken: TypeScript.ISyntaxToken, block: BlockSyntax): CatchClauseSyntax;
        static create1(identifier: TypeScript.ISyntaxToken): CatchClauseSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): CatchClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): CatchClauseSyntax;
        public withCatchKeyword(catchKeyword: TypeScript.ISyntaxToken): CatchClauseSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): CatchClauseSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): CatchClauseSyntax;
        public withTypeAnnotation(typeAnnotation: TypeAnnotationSyntax): CatchClauseSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): CatchClauseSyntax;
        public withBlock(block: BlockSyntax): CatchClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class FinallyClauseSyntax extends TypeScript.SyntaxNode {
        public finallyKeyword: TypeScript.ISyntaxToken;
        public block: BlockSyntax;
        constructor(finallyKeyword: TypeScript.ISyntaxToken, block: BlockSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(finallyKeyword: TypeScript.ISyntaxToken, block: BlockSyntax): FinallyClauseSyntax;
        static create1(): FinallyClauseSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): FinallyClauseSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): FinallyClauseSyntax;
        public withFinallyKeyword(finallyKeyword: TypeScript.ISyntaxToken): FinallyClauseSyntax;
        public withBlock(block: BlockSyntax): FinallyClauseSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class LabeledStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public identifier: TypeScript.ISyntaxToken;
        public colonToken: TypeScript.ISyntaxToken;
        public statement: TypeScript.IStatementSyntax;
        constructor(identifier: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(identifier: TypeScript.ISyntaxToken, colonToken: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): LabeledStatementSyntax;
        static create1(identifier: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax): LabeledStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): LabeledStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): LabeledStatementSyntax;
        public withIdentifier(identifier: TypeScript.ISyntaxToken): LabeledStatementSyntax;
        public withColonToken(colonToken: TypeScript.ISyntaxToken): LabeledStatementSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): LabeledStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class DoStatementSyntax extends IterationStatementSyntax {
        public doKeyword: TypeScript.ISyntaxToken;
        public whileKeyword: TypeScript.ISyntaxToken;
        public condition: TypeScript.IExpressionSyntax;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(doKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public update(doKeyword: TypeScript.ISyntaxToken, statement: TypeScript.IStatementSyntax, whileKeyword: TypeScript.ISyntaxToken, openParenToken: TypeScript.ISyntaxToken, condition: TypeScript.IExpressionSyntax, closeParenToken: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): DoStatementSyntax;
        static create1(statement: TypeScript.IStatementSyntax, condition: TypeScript.IExpressionSyntax): DoStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): DoStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): DoStatementSyntax;
        public withDoKeyword(doKeyword: TypeScript.ISyntaxToken): DoStatementSyntax;
        public withStatement(statement: TypeScript.IStatementSyntax): DoStatementSyntax;
        public withWhileKeyword(whileKeyword: TypeScript.ISyntaxToken): DoStatementSyntax;
        public withOpenParenToken(openParenToken: TypeScript.ISyntaxToken): DoStatementSyntax;
        public withCondition(condition: TypeScript.IExpressionSyntax): DoStatementSyntax;
        public withCloseParenToken(closeParenToken: TypeScript.ISyntaxToken): DoStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): DoStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class TypeOfExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public typeOfKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        constructor(typeOfKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(typeOfKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): TypeOfExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): TypeOfExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeOfExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): TypeOfExpressionSyntax;
        public withTypeOfKeyword(typeOfKeyword: TypeScript.ISyntaxToken): TypeOfExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): TypeOfExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class DeleteExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public deleteKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        constructor(deleteKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(deleteKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): DeleteExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): DeleteExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): DeleteExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): DeleteExpressionSyntax;
        public withDeleteKeyword(deleteKeyword: TypeScript.ISyntaxToken): DeleteExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): DeleteExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class VoidExpressionSyntax extends TypeScript.SyntaxNode implements TypeScript.IUnaryExpressionSyntax {
        public voidKeyword: TypeScript.ISyntaxToken;
        public expression: TypeScript.IExpressionSyntax;
        constructor(voidKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isUnaryExpression(): boolean;
        public isExpression(): boolean;
        public update(voidKeyword: TypeScript.ISyntaxToken, expression: TypeScript.IExpressionSyntax): VoidExpressionSyntax;
        static create1(expression: TypeScript.IExpressionSyntax): VoidExpressionSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): VoidExpressionSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): VoidExpressionSyntax;
        public withVoidKeyword(voidKeyword: TypeScript.ISyntaxToken): VoidExpressionSyntax;
        public withExpression(expression: TypeScript.IExpressionSyntax): VoidExpressionSyntax;
        public isTypeScriptSpecific(): boolean;
    }
    class DebuggerStatementSyntax extends TypeScript.SyntaxNode implements TypeScript.IStatementSyntax {
        public debuggerKeyword: TypeScript.ISyntaxToken;
        public semicolonToken: TypeScript.ISyntaxToken;
        constructor(debuggerKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken, parsedInStrictMode: boolean);
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(slot: number): TypeScript.ISyntaxElement;
        public isStatement(): boolean;
        public isModuleElement(): boolean;
        public update(debuggerKeyword: TypeScript.ISyntaxToken, semicolonToken: TypeScript.ISyntaxToken): DebuggerStatementSyntax;
        static create1(): DebuggerStatementSyntax;
        public withLeadingTrivia(trivia: TypeScript.ISyntaxTriviaList): DebuggerStatementSyntax;
        public withTrailingTrivia(trivia: TypeScript.ISyntaxTriviaList): DebuggerStatementSyntax;
        public withDebuggerKeyword(debuggerKeyword: TypeScript.ISyntaxToken): DebuggerStatementSyntax;
        public withSemicolonToken(semicolonToken: TypeScript.ISyntaxToken): DebuggerStatementSyntax;
        public isTypeScriptSpecific(): boolean;
    }
}
declare module TypeScript {
    class SyntaxRewriter implements TypeScript.ISyntaxVisitor {
        public visitToken(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
        public visitNode(node: TypeScript.SyntaxNode): TypeScript.SyntaxNode;
        public visitNodeOrToken(node: TypeScript.ISyntaxNodeOrToken): TypeScript.ISyntaxNodeOrToken;
        public visitList(list: TypeScript.ISyntaxList): TypeScript.ISyntaxList;
        public visitSeparatedList(list: TypeScript.ISeparatedSyntaxList): TypeScript.ISeparatedSyntaxList;
        public visitSourceUnit(node: TypeScript.SourceUnitSyntax): any;
        public visitExternalModuleReference(node: TypeScript.ExternalModuleReferenceSyntax): any;
        public visitModuleNameModuleReference(node: TypeScript.ModuleNameModuleReferenceSyntax): any;
        public visitImportDeclaration(node: TypeScript.ImportDeclarationSyntax): any;
        public visitExportAssignment(node: TypeScript.ExportAssignmentSyntax): any;
        public visitClassDeclaration(node: TypeScript.ClassDeclarationSyntax): any;
        public visitInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax): any;
        public visitHeritageClause(node: TypeScript.HeritageClauseSyntax): any;
        public visitModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax): any;
        public visitFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax): any;
        public visitVariableStatement(node: TypeScript.VariableStatementSyntax): any;
        public visitVariableDeclaration(node: TypeScript.VariableDeclarationSyntax): any;
        public visitVariableDeclarator(node: TypeScript.VariableDeclaratorSyntax): any;
        public visitEqualsValueClause(node: TypeScript.EqualsValueClauseSyntax): any;
        public visitPrefixUnaryExpression(node: TypeScript.PrefixUnaryExpressionSyntax): any;
        public visitArrayLiteralExpression(node: TypeScript.ArrayLiteralExpressionSyntax): any;
        public visitOmittedExpression(node: TypeScript.OmittedExpressionSyntax): any;
        public visitParenthesizedExpression(node: TypeScript.ParenthesizedExpressionSyntax): any;
        public visitSimpleArrowFunctionExpression(node: TypeScript.SimpleArrowFunctionExpressionSyntax): any;
        public visitParenthesizedArrowFunctionExpression(node: TypeScript.ParenthesizedArrowFunctionExpressionSyntax): any;
        public visitQualifiedName(node: TypeScript.QualifiedNameSyntax): any;
        public visitTypeArgumentList(node: TypeScript.TypeArgumentListSyntax): any;
        public visitConstructorType(node: TypeScript.ConstructorTypeSyntax): any;
        public visitFunctionType(node: TypeScript.FunctionTypeSyntax): any;
        public visitObjectType(node: TypeScript.ObjectTypeSyntax): any;
        public visitArrayType(node: TypeScript.ArrayTypeSyntax): any;
        public visitGenericType(node: TypeScript.GenericTypeSyntax): any;
        public visitTypeQuery(node: TypeScript.TypeQuerySyntax): any;
        public visitTypeAnnotation(node: TypeScript.TypeAnnotationSyntax): any;
        public visitBlock(node: TypeScript.BlockSyntax): any;
        public visitParameter(node: TypeScript.ParameterSyntax): any;
        public visitMemberAccessExpression(node: TypeScript.MemberAccessExpressionSyntax): any;
        public visitPostfixUnaryExpression(node: TypeScript.PostfixUnaryExpressionSyntax): any;
        public visitElementAccessExpression(node: TypeScript.ElementAccessExpressionSyntax): any;
        public visitInvocationExpression(node: TypeScript.InvocationExpressionSyntax): any;
        public visitArgumentList(node: TypeScript.ArgumentListSyntax): any;
        public visitBinaryExpression(node: TypeScript.BinaryExpressionSyntax): any;
        public visitConditionalExpression(node: TypeScript.ConditionalExpressionSyntax): any;
        public visitConstructSignature(node: TypeScript.ConstructSignatureSyntax): any;
        public visitMethodSignature(node: TypeScript.MethodSignatureSyntax): any;
        public visitIndexSignature(node: TypeScript.IndexSignatureSyntax): any;
        public visitPropertySignature(node: TypeScript.PropertySignatureSyntax): any;
        public visitCallSignature(node: TypeScript.CallSignatureSyntax): any;
        public visitParameterList(node: TypeScript.ParameterListSyntax): any;
        public visitTypeParameterList(node: TypeScript.TypeParameterListSyntax): any;
        public visitTypeParameter(node: TypeScript.TypeParameterSyntax): any;
        public visitConstraint(node: TypeScript.ConstraintSyntax): any;
        public visitElseClause(node: TypeScript.ElseClauseSyntax): any;
        public visitIfStatement(node: TypeScript.IfStatementSyntax): any;
        public visitExpressionStatement(node: TypeScript.ExpressionStatementSyntax): any;
        public visitConstructorDeclaration(node: TypeScript.ConstructorDeclarationSyntax): any;
        public visitMemberFunctionDeclaration(node: TypeScript.MemberFunctionDeclarationSyntax): any;
        public visitGetMemberAccessorDeclaration(node: TypeScript.GetMemberAccessorDeclarationSyntax): any;
        public visitSetMemberAccessorDeclaration(node: TypeScript.SetMemberAccessorDeclarationSyntax): any;
        public visitMemberVariableDeclaration(node: TypeScript.MemberVariableDeclarationSyntax): any;
        public visitThrowStatement(node: TypeScript.ThrowStatementSyntax): any;
        public visitReturnStatement(node: TypeScript.ReturnStatementSyntax): any;
        public visitObjectCreationExpression(node: TypeScript.ObjectCreationExpressionSyntax): any;
        public visitSwitchStatement(node: TypeScript.SwitchStatementSyntax): any;
        public visitCaseSwitchClause(node: TypeScript.CaseSwitchClauseSyntax): any;
        public visitDefaultSwitchClause(node: TypeScript.DefaultSwitchClauseSyntax): any;
        public visitBreakStatement(node: TypeScript.BreakStatementSyntax): any;
        public visitContinueStatement(node: TypeScript.ContinueStatementSyntax): any;
        public visitForStatement(node: TypeScript.ForStatementSyntax): any;
        public visitForInStatement(node: TypeScript.ForInStatementSyntax): any;
        public visitWhileStatement(node: TypeScript.WhileStatementSyntax): any;
        public visitWithStatement(node: TypeScript.WithStatementSyntax): any;
        public visitEnumDeclaration(node: TypeScript.EnumDeclarationSyntax): any;
        public visitEnumElement(node: TypeScript.EnumElementSyntax): any;
        public visitCastExpression(node: TypeScript.CastExpressionSyntax): any;
        public visitObjectLiteralExpression(node: TypeScript.ObjectLiteralExpressionSyntax): any;
        public visitSimplePropertyAssignment(node: TypeScript.SimplePropertyAssignmentSyntax): any;
        public visitFunctionPropertyAssignment(node: TypeScript.FunctionPropertyAssignmentSyntax): any;
        public visitGetAccessorPropertyAssignment(node: TypeScript.GetAccessorPropertyAssignmentSyntax): any;
        public visitSetAccessorPropertyAssignment(node: TypeScript.SetAccessorPropertyAssignmentSyntax): any;
        public visitFunctionExpression(node: TypeScript.FunctionExpressionSyntax): any;
        public visitEmptyStatement(node: TypeScript.EmptyStatementSyntax): any;
        public visitTryStatement(node: TypeScript.TryStatementSyntax): any;
        public visitCatchClause(node: TypeScript.CatchClauseSyntax): any;
        public visitFinallyClause(node: TypeScript.FinallyClauseSyntax): any;
        public visitLabeledStatement(node: TypeScript.LabeledStatementSyntax): any;
        public visitDoStatement(node: TypeScript.DoStatementSyntax): any;
        public visitTypeOfExpression(node: TypeScript.TypeOfExpressionSyntax): any;
        public visitDeleteExpression(node: TypeScript.DeleteExpressionSyntax): any;
        public visitVoidExpression(node: TypeScript.VoidExpressionSyntax): any;
        public visitDebuggerStatement(node: TypeScript.DebuggerStatementSyntax): any;
    }
}
declare module TypeScript {
    class SyntaxDedenter extends TypeScript.SyntaxRewriter {
        private dedentationAmount;
        private minimumIndent;
        private options;
        private lastTriviaWasNewLine;
        constructor(dedentFirstToken: boolean, dedentationAmount: number, minimumIndent: number, options: FormattingOptions);
        private abort();
        private isAborted();
        public visitToken(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
        private dedentTriviaList(triviaList);
        private dedentSegment(segment, hasFollowingNewLineTrivia);
        private dedentWhitespace(trivia, hasFollowingNewLineTrivia);
        private dedentMultiLineComment(trivia);
        static dedentNode(node: TypeScript.ISyntaxNode, dedentFirstToken: boolean, dedentAmount: number, minimumIndent: number, options: FormattingOptions): TypeScript.ISyntaxNode;
    }
}
declare module TypeScript {
    class SyntaxIndenter extends TypeScript.SyntaxRewriter {
        private indentationAmount;
        private options;
        private lastTriviaWasNewLine;
        private indentationTrivia;
        constructor(indentFirstToken: boolean, indentationAmount: number, options: FormattingOptions);
        public visitToken(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
        public indentTriviaList(triviaList: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxTriviaList;
        private indentSegment(segment);
        private indentWhitespace(trivia, indentThisTrivia, result);
        private indentSingleLineOrSkippedText(trivia, indentThisTrivia, result);
        private indentMultiLineComment(trivia, indentThisTrivia, result);
        static indentNode(node: TypeScript.ISyntaxNode, indentFirstToken: boolean, indentAmount: number, options: FormattingOptions): TypeScript.SyntaxNode;
        static indentNodes(nodes: TypeScript.SyntaxNode[], indentFirstToken: boolean, indentAmount: number, options: FormattingOptions): TypeScript.SyntaxNode[];
    }
}
declare module TypeScript.Syntax {
    class VariableWidthTokenWithNoTrivia implements TypeScript.ISyntaxToken {
        private _sourceText;
        private _fullStart;
        public tokenKind: TypeScript.SyntaxKind;
        private _textOrWidth;
        constructor(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, textOrWidth: any);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        private start();
        private end();
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    class VariableWidthTokenWithLeadingTrivia implements TypeScript.ISyntaxToken {
        private _sourceText;
        private _fullStart;
        public tokenKind: TypeScript.SyntaxKind;
        private _leadingTriviaInfo;
        private _textOrWidth;
        constructor(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, leadingTriviaInfo: number, textOrWidth: any);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        private start();
        private end();
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    class VariableWidthTokenWithTrailingTrivia implements TypeScript.ISyntaxToken {
        private _sourceText;
        private _fullStart;
        public tokenKind: TypeScript.SyntaxKind;
        private _textOrWidth;
        private _trailingTriviaInfo;
        constructor(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, textOrWidth: any, trailingTriviaInfo: number);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        private start();
        private end();
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    class VariableWidthTokenWithLeadingAndTrailingTrivia implements TypeScript.ISyntaxToken {
        private _sourceText;
        private _fullStart;
        public tokenKind: TypeScript.SyntaxKind;
        private _leadingTriviaInfo;
        private _textOrWidth;
        private _trailingTriviaInfo;
        constructor(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, leadingTriviaInfo: number, textOrWidth: any, trailingTriviaInfo: number);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        private start();
        private end();
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    class FixedWidthTokenWithNoTrivia implements TypeScript.ISyntaxToken {
        public tokenKind: TypeScript.SyntaxKind;
        constructor(kind: TypeScript.SyntaxKind);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    class FixedWidthTokenWithLeadingTrivia implements TypeScript.ISyntaxToken {
        private _sourceText;
        private _fullStart;
        public tokenKind: TypeScript.SyntaxKind;
        private _leadingTriviaInfo;
        constructor(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, leadingTriviaInfo: number);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        private start();
        private end();
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    class FixedWidthTokenWithTrailingTrivia implements TypeScript.ISyntaxToken {
        private _sourceText;
        private _fullStart;
        public tokenKind: TypeScript.SyntaxKind;
        private _trailingTriviaInfo;
        constructor(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, trailingTriviaInfo: number);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        private start();
        private end();
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    class FixedWidthTokenWithLeadingAndTrailingTrivia implements TypeScript.ISyntaxToken {
        private _sourceText;
        private _fullStart;
        public tokenKind: TypeScript.SyntaxKind;
        private _leadingTriviaInfo;
        private _trailingTriviaInfo;
        constructor(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, leadingTriviaInfo: number, trailingTriviaInfo: number);
        public clone(): TypeScript.ISyntaxToken;
        public isNode(): boolean;
        public isToken(): boolean;
        public isList(): boolean;
        public isSeparatedList(): boolean;
        public kind(): TypeScript.SyntaxKind;
        public childCount(): number;
        public childAt(index: number): TypeScript.ISyntaxElement;
        public fullWidth(): number;
        private start();
        private end();
        public width(): number;
        public text(): string;
        public fullText(): string;
        public value(): any;
        public valueText(): string;
        public hasLeadingTrivia(): boolean;
        public hasLeadingComment(): boolean;
        public hasLeadingNewLine(): boolean;
        public hasLeadingSkippedText(): boolean;
        public leadingTriviaWidth(): number;
        public leadingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasTrailingTrivia(): boolean;
        public hasTrailingComment(): boolean;
        public hasTrailingNewLine(): boolean;
        public hasTrailingSkippedText(): boolean;
        public trailingTriviaWidth(): number;
        public trailingTrivia(): TypeScript.ISyntaxTriviaList;
        public hasSkippedToken(): boolean;
        public toJSON(key: any): any;
        public firstToken(): TypeScript.ISyntaxToken;
        public lastToken(): TypeScript.ISyntaxToken;
        public isTypeScriptSpecific(): boolean;
        public isIncrementallyUnusable(): boolean;
        public accept(visitor: TypeScript.ISyntaxVisitor): any;
        private realize();
        public collectTextElements(elements: string[]): void;
        private findTokenInternal(parent, position, fullStart);
        public withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
        public withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): TypeScript.ISyntaxToken;
    }
    function fixedWidthToken(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, leadingTriviaInfo: number, trailingTriviaInfo: number): TypeScript.ISyntaxToken;
    function variableWidthToken(sourceText: TypeScript.ISimpleText, fullStart: number, kind: TypeScript.SyntaxKind, leadingTriviaInfo: number, width: number, trailingTriviaInfo: number): TypeScript.ISyntaxToken;
}
declare module TypeScript {
    interface ISyntaxToken extends TypeScript.ISyntaxNodeOrToken, TypeScript.INameSyntax {
        tokenKind: TypeScript.SyntaxKind;
        text(): string;
        value(): any;
        valueText(): string;
        hasLeadingTrivia(): boolean;
        hasLeadingComment(): boolean;
        hasLeadingNewLine(): boolean;
        hasLeadingSkippedText(): boolean;
        hasTrailingTrivia(): boolean;
        hasTrailingComment(): boolean;
        hasTrailingNewLine(): boolean;
        hasTrailingSkippedText(): boolean;
        hasSkippedToken(): boolean;
        leadingTrivia(): TypeScript.ISyntaxTriviaList;
        trailingTrivia(): TypeScript.ISyntaxTriviaList;
        withLeadingTrivia(leadingTrivia: TypeScript.ISyntaxTriviaList): ISyntaxToken;
        withTrailingTrivia(trailingTrivia: TypeScript.ISyntaxTriviaList): ISyntaxToken;
        clone(): ISyntaxToken;
    }
    interface ITokenInfo {
        leadingTrivia?: TypeScript.ISyntaxTrivia[];
        text?: string;
        trailingTrivia?: TypeScript.ISyntaxTrivia[];
    }
}
declare module TypeScript.Syntax {
    function realizeToken(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
    function convertToIdentifierName(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
    function tokenToJSON(token: TypeScript.ISyntaxToken): any;
    function value(token: TypeScript.ISyntaxToken): any;
    function massageEscapes(text: string): string;
    function valueText(token: TypeScript.ISyntaxToken): string;
    function emptyToken(kind: TypeScript.SyntaxKind): TypeScript.ISyntaxToken;
    function token(kind: TypeScript.SyntaxKind, info?: TypeScript.ITokenInfo): TypeScript.ISyntaxToken;
    function identifier(text: string, info?: TypeScript.ITokenInfo): TypeScript.ISyntaxToken;
}
declare module TypeScript {
    class SyntaxTokenReplacer extends TypeScript.SyntaxRewriter {
        private token1;
        private token2;
        constructor(token1: TypeScript.ISyntaxToken, token2: TypeScript.ISyntaxToken);
        public visitToken(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
        public visitNode(node: TypeScript.SyntaxNode): TypeScript.SyntaxNode;
        public visitList(list: TypeScript.ISyntaxList): TypeScript.ISyntaxList;
        public visitSeparatedList(list: TypeScript.ISeparatedSyntaxList): TypeScript.ISeparatedSyntaxList;
    }
}
declare module TypeScript {
    interface ISyntaxTrivia {
        kind(): TypeScript.SyntaxKind;
        isWhitespace(): boolean;
        isComment(): boolean;
        isNewLine(): boolean;
        isSkippedToken(): boolean;
        fullWidth(): number;
        fullText(): string;
        skippedToken(): TypeScript.ISyntaxToken;
    }
}
declare module TypeScript.Syntax {
    function trivia(kind: TypeScript.SyntaxKind, text: string): TypeScript.ISyntaxTrivia;
    function skippedTokenTrivia(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxTrivia;
    function spaces(count: number): TypeScript.ISyntaxTrivia;
    function whitespace(text: string): TypeScript.ISyntaxTrivia;
    function multiLineComment(text: string): TypeScript.ISyntaxTrivia;
    function singleLineComment(text: string): TypeScript.ISyntaxTrivia;
    var spaceTrivia: TypeScript.ISyntaxTrivia;
    var lineFeedTrivia: TypeScript.ISyntaxTrivia;
    var carriageReturnTrivia: TypeScript.ISyntaxTrivia;
    var carriageReturnLineFeedTrivia: TypeScript.ISyntaxTrivia;
    function splitMultiLineCommentTriviaIntoMultipleLines(trivia: TypeScript.ISyntaxTrivia): string[];
}
declare module TypeScript {
    interface ISyntaxTriviaList {
        count(): number;
        syntaxTriviaAt(index: number): TypeScript.ISyntaxTrivia;
        fullWidth(): number;
        fullText(): string;
        hasComment(): boolean;
        hasNewLine(): boolean;
        hasSkippedToken(): boolean;
        last(): TypeScript.ISyntaxTrivia;
        toArray(): TypeScript.ISyntaxTrivia[];
        concat(trivia: ISyntaxTriviaList): ISyntaxTriviaList;
        collectTextElements(elements: string[]): void;
    }
}
declare module TypeScript.Syntax {
    var emptyTriviaList: TypeScript.ISyntaxTriviaList;
    function triviaList(trivia: TypeScript.ISyntaxTrivia[]): TypeScript.ISyntaxTriviaList;
    var spaceTriviaList: TypeScript.ISyntaxTriviaList;
}
declare module TypeScript {
    class SyntaxUtilities {
        static isAngleBracket(positionedElement: TypeScript.PositionedElement): boolean;
        static getToken(list: TypeScript.ISyntaxList, kind: TypeScript.SyntaxKind): TypeScript.ISyntaxToken;
        static containsToken(list: TypeScript.ISyntaxList, kind: TypeScript.SyntaxKind): boolean;
        static hasExportKeyword(moduleElement: TypeScript.IModuleElementSyntax): boolean;
        static getExportKeyword(moduleElement: TypeScript.IModuleElementSyntax): TypeScript.ISyntaxToken;
        static isAmbientDeclarationSyntax(positionNode: TypeScript.PositionedNode): boolean;
    }
}
declare module TypeScript {
    interface ISyntaxVisitor {
        visitToken(token: TypeScript.ISyntaxToken): any;
        visitSourceUnit(node: TypeScript.SourceUnitSyntax): any;
        visitExternalModuleReference(node: TypeScript.ExternalModuleReferenceSyntax): any;
        visitModuleNameModuleReference(node: TypeScript.ModuleNameModuleReferenceSyntax): any;
        visitImportDeclaration(node: TypeScript.ImportDeclarationSyntax): any;
        visitExportAssignment(node: TypeScript.ExportAssignmentSyntax): any;
        visitClassDeclaration(node: TypeScript.ClassDeclarationSyntax): any;
        visitInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax): any;
        visitHeritageClause(node: TypeScript.HeritageClauseSyntax): any;
        visitModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax): any;
        visitFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax): any;
        visitVariableStatement(node: TypeScript.VariableStatementSyntax): any;
        visitVariableDeclaration(node: TypeScript.VariableDeclarationSyntax): any;
        visitVariableDeclarator(node: TypeScript.VariableDeclaratorSyntax): any;
        visitEqualsValueClause(node: TypeScript.EqualsValueClauseSyntax): any;
        visitPrefixUnaryExpression(node: TypeScript.PrefixUnaryExpressionSyntax): any;
        visitArrayLiteralExpression(node: TypeScript.ArrayLiteralExpressionSyntax): any;
        visitOmittedExpression(node: TypeScript.OmittedExpressionSyntax): any;
        visitParenthesizedExpression(node: TypeScript.ParenthesizedExpressionSyntax): any;
        visitSimpleArrowFunctionExpression(node: TypeScript.SimpleArrowFunctionExpressionSyntax): any;
        visitParenthesizedArrowFunctionExpression(node: TypeScript.ParenthesizedArrowFunctionExpressionSyntax): any;
        visitQualifiedName(node: TypeScript.QualifiedNameSyntax): any;
        visitTypeArgumentList(node: TypeScript.TypeArgumentListSyntax): any;
        visitConstructorType(node: TypeScript.ConstructorTypeSyntax): any;
        visitFunctionType(node: TypeScript.FunctionTypeSyntax): any;
        visitObjectType(node: TypeScript.ObjectTypeSyntax): any;
        visitArrayType(node: TypeScript.ArrayTypeSyntax): any;
        visitGenericType(node: TypeScript.GenericTypeSyntax): any;
        visitTypeQuery(node: TypeScript.TypeQuerySyntax): any;
        visitTypeAnnotation(node: TypeScript.TypeAnnotationSyntax): any;
        visitBlock(node: TypeScript.BlockSyntax): any;
        visitParameter(node: TypeScript.ParameterSyntax): any;
        visitMemberAccessExpression(node: TypeScript.MemberAccessExpressionSyntax): any;
        visitPostfixUnaryExpression(node: TypeScript.PostfixUnaryExpressionSyntax): any;
        visitElementAccessExpression(node: TypeScript.ElementAccessExpressionSyntax): any;
        visitInvocationExpression(node: TypeScript.InvocationExpressionSyntax): any;
        visitArgumentList(node: TypeScript.ArgumentListSyntax): any;
        visitBinaryExpression(node: TypeScript.BinaryExpressionSyntax): any;
        visitConditionalExpression(node: TypeScript.ConditionalExpressionSyntax): any;
        visitConstructSignature(node: TypeScript.ConstructSignatureSyntax): any;
        visitMethodSignature(node: TypeScript.MethodSignatureSyntax): any;
        visitIndexSignature(node: TypeScript.IndexSignatureSyntax): any;
        visitPropertySignature(node: TypeScript.PropertySignatureSyntax): any;
        visitCallSignature(node: TypeScript.CallSignatureSyntax): any;
        visitParameterList(node: TypeScript.ParameterListSyntax): any;
        visitTypeParameterList(node: TypeScript.TypeParameterListSyntax): any;
        visitTypeParameter(node: TypeScript.TypeParameterSyntax): any;
        visitConstraint(node: TypeScript.ConstraintSyntax): any;
        visitElseClause(node: TypeScript.ElseClauseSyntax): any;
        visitIfStatement(node: TypeScript.IfStatementSyntax): any;
        visitExpressionStatement(node: TypeScript.ExpressionStatementSyntax): any;
        visitConstructorDeclaration(node: TypeScript.ConstructorDeclarationSyntax): any;
        visitMemberFunctionDeclaration(node: TypeScript.MemberFunctionDeclarationSyntax): any;
        visitGetMemberAccessorDeclaration(node: TypeScript.GetMemberAccessorDeclarationSyntax): any;
        visitSetMemberAccessorDeclaration(node: TypeScript.SetMemberAccessorDeclarationSyntax): any;
        visitMemberVariableDeclaration(node: TypeScript.MemberVariableDeclarationSyntax): any;
        visitThrowStatement(node: TypeScript.ThrowStatementSyntax): any;
        visitReturnStatement(node: TypeScript.ReturnStatementSyntax): any;
        visitObjectCreationExpression(node: TypeScript.ObjectCreationExpressionSyntax): any;
        visitSwitchStatement(node: TypeScript.SwitchStatementSyntax): any;
        visitCaseSwitchClause(node: TypeScript.CaseSwitchClauseSyntax): any;
        visitDefaultSwitchClause(node: TypeScript.DefaultSwitchClauseSyntax): any;
        visitBreakStatement(node: TypeScript.BreakStatementSyntax): any;
        visitContinueStatement(node: TypeScript.ContinueStatementSyntax): any;
        visitForStatement(node: TypeScript.ForStatementSyntax): any;
        visitForInStatement(node: TypeScript.ForInStatementSyntax): any;
        visitWhileStatement(node: TypeScript.WhileStatementSyntax): any;
        visitWithStatement(node: TypeScript.WithStatementSyntax): any;
        visitEnumDeclaration(node: TypeScript.EnumDeclarationSyntax): any;
        visitEnumElement(node: TypeScript.EnumElementSyntax): any;
        visitCastExpression(node: TypeScript.CastExpressionSyntax): any;
        visitObjectLiteralExpression(node: TypeScript.ObjectLiteralExpressionSyntax): any;
        visitSimplePropertyAssignment(node: TypeScript.SimplePropertyAssignmentSyntax): any;
        visitFunctionPropertyAssignment(node: TypeScript.FunctionPropertyAssignmentSyntax): any;
        visitGetAccessorPropertyAssignment(node: TypeScript.GetAccessorPropertyAssignmentSyntax): any;
        visitSetAccessorPropertyAssignment(node: TypeScript.SetAccessorPropertyAssignmentSyntax): any;
        visitFunctionExpression(node: TypeScript.FunctionExpressionSyntax): any;
        visitEmptyStatement(node: TypeScript.EmptyStatementSyntax): any;
        visitTryStatement(node: TypeScript.TryStatementSyntax): any;
        visitCatchClause(node: TypeScript.CatchClauseSyntax): any;
        visitFinallyClause(node: TypeScript.FinallyClauseSyntax): any;
        visitLabeledStatement(node: TypeScript.LabeledStatementSyntax): any;
        visitDoStatement(node: TypeScript.DoStatementSyntax): any;
        visitTypeOfExpression(node: TypeScript.TypeOfExpressionSyntax): any;
        visitDeleteExpression(node: TypeScript.DeleteExpressionSyntax): any;
        visitVoidExpression(node: TypeScript.VoidExpressionSyntax): any;
        visitDebuggerStatement(node: TypeScript.DebuggerStatementSyntax): any;
    }
    class SyntaxVisitor implements ISyntaxVisitor {
        public defaultVisit(node: TypeScript.ISyntaxNodeOrToken): any;
        public visitToken(token: TypeScript.ISyntaxToken): any;
        public visitSourceUnit(node: TypeScript.SourceUnitSyntax): any;
        public visitExternalModuleReference(node: TypeScript.ExternalModuleReferenceSyntax): any;
        public visitModuleNameModuleReference(node: TypeScript.ModuleNameModuleReferenceSyntax): any;
        public visitImportDeclaration(node: TypeScript.ImportDeclarationSyntax): any;
        public visitExportAssignment(node: TypeScript.ExportAssignmentSyntax): any;
        public visitClassDeclaration(node: TypeScript.ClassDeclarationSyntax): any;
        public visitInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax): any;
        public visitHeritageClause(node: TypeScript.HeritageClauseSyntax): any;
        public visitModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax): any;
        public visitFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax): any;
        public visitVariableStatement(node: TypeScript.VariableStatementSyntax): any;
        public visitVariableDeclaration(node: TypeScript.VariableDeclarationSyntax): any;
        public visitVariableDeclarator(node: TypeScript.VariableDeclaratorSyntax): any;
        public visitEqualsValueClause(node: TypeScript.EqualsValueClauseSyntax): any;
        public visitPrefixUnaryExpression(node: TypeScript.PrefixUnaryExpressionSyntax): any;
        public visitArrayLiteralExpression(node: TypeScript.ArrayLiteralExpressionSyntax): any;
        public visitOmittedExpression(node: TypeScript.OmittedExpressionSyntax): any;
        public visitParenthesizedExpression(node: TypeScript.ParenthesizedExpressionSyntax): any;
        public visitSimpleArrowFunctionExpression(node: TypeScript.SimpleArrowFunctionExpressionSyntax): any;
        public visitParenthesizedArrowFunctionExpression(node: TypeScript.ParenthesizedArrowFunctionExpressionSyntax): any;
        public visitQualifiedName(node: TypeScript.QualifiedNameSyntax): any;
        public visitTypeArgumentList(node: TypeScript.TypeArgumentListSyntax): any;
        public visitConstructorType(node: TypeScript.ConstructorTypeSyntax): any;
        public visitFunctionType(node: TypeScript.FunctionTypeSyntax): any;
        public visitObjectType(node: TypeScript.ObjectTypeSyntax): any;
        public visitArrayType(node: TypeScript.ArrayTypeSyntax): any;
        public visitGenericType(node: TypeScript.GenericTypeSyntax): any;
        public visitTypeQuery(node: TypeScript.TypeQuerySyntax): any;
        public visitTypeAnnotation(node: TypeScript.TypeAnnotationSyntax): any;
        public visitBlock(node: TypeScript.BlockSyntax): any;
        public visitParameter(node: TypeScript.ParameterSyntax): any;
        public visitMemberAccessExpression(node: TypeScript.MemberAccessExpressionSyntax): any;
        public visitPostfixUnaryExpression(node: TypeScript.PostfixUnaryExpressionSyntax): any;
        public visitElementAccessExpression(node: TypeScript.ElementAccessExpressionSyntax): any;
        public visitInvocationExpression(node: TypeScript.InvocationExpressionSyntax): any;
        public visitArgumentList(node: TypeScript.ArgumentListSyntax): any;
        public visitBinaryExpression(node: TypeScript.BinaryExpressionSyntax): any;
        public visitConditionalExpression(node: TypeScript.ConditionalExpressionSyntax): any;
        public visitConstructSignature(node: TypeScript.ConstructSignatureSyntax): any;
        public visitMethodSignature(node: TypeScript.MethodSignatureSyntax): any;
        public visitIndexSignature(node: TypeScript.IndexSignatureSyntax): any;
        public visitPropertySignature(node: TypeScript.PropertySignatureSyntax): any;
        public visitCallSignature(node: TypeScript.CallSignatureSyntax): any;
        public visitParameterList(node: TypeScript.ParameterListSyntax): any;
        public visitTypeParameterList(node: TypeScript.TypeParameterListSyntax): any;
        public visitTypeParameter(node: TypeScript.TypeParameterSyntax): any;
        public visitConstraint(node: TypeScript.ConstraintSyntax): any;
        public visitElseClause(node: TypeScript.ElseClauseSyntax): any;
        public visitIfStatement(node: TypeScript.IfStatementSyntax): any;
        public visitExpressionStatement(node: TypeScript.ExpressionStatementSyntax): any;
        public visitConstructorDeclaration(node: TypeScript.ConstructorDeclarationSyntax): any;
        public visitMemberFunctionDeclaration(node: TypeScript.MemberFunctionDeclarationSyntax): any;
        public visitGetMemberAccessorDeclaration(node: TypeScript.GetMemberAccessorDeclarationSyntax): any;
        public visitSetMemberAccessorDeclaration(node: TypeScript.SetMemberAccessorDeclarationSyntax): any;
        public visitMemberVariableDeclaration(node: TypeScript.MemberVariableDeclarationSyntax): any;
        public visitThrowStatement(node: TypeScript.ThrowStatementSyntax): any;
        public visitReturnStatement(node: TypeScript.ReturnStatementSyntax): any;
        public visitObjectCreationExpression(node: TypeScript.ObjectCreationExpressionSyntax): any;
        public visitSwitchStatement(node: TypeScript.SwitchStatementSyntax): any;
        public visitCaseSwitchClause(node: TypeScript.CaseSwitchClauseSyntax): any;
        public visitDefaultSwitchClause(node: TypeScript.DefaultSwitchClauseSyntax): any;
        public visitBreakStatement(node: TypeScript.BreakStatementSyntax): any;
        public visitContinueStatement(node: TypeScript.ContinueStatementSyntax): any;
        public visitForStatement(node: TypeScript.ForStatementSyntax): any;
        public visitForInStatement(node: TypeScript.ForInStatementSyntax): any;
        public visitWhileStatement(node: TypeScript.WhileStatementSyntax): any;
        public visitWithStatement(node: TypeScript.WithStatementSyntax): any;
        public visitEnumDeclaration(node: TypeScript.EnumDeclarationSyntax): any;
        public visitEnumElement(node: TypeScript.EnumElementSyntax): any;
        public visitCastExpression(node: TypeScript.CastExpressionSyntax): any;
        public visitObjectLiteralExpression(node: TypeScript.ObjectLiteralExpressionSyntax): any;
        public visitSimplePropertyAssignment(node: TypeScript.SimplePropertyAssignmentSyntax): any;
        public visitFunctionPropertyAssignment(node: TypeScript.FunctionPropertyAssignmentSyntax): any;
        public visitGetAccessorPropertyAssignment(node: TypeScript.GetAccessorPropertyAssignmentSyntax): any;
        public visitSetAccessorPropertyAssignment(node: TypeScript.SetAccessorPropertyAssignmentSyntax): any;
        public visitFunctionExpression(node: TypeScript.FunctionExpressionSyntax): any;
        public visitEmptyStatement(node: TypeScript.EmptyStatementSyntax): any;
        public visitTryStatement(node: TypeScript.TryStatementSyntax): any;
        public visitCatchClause(node: TypeScript.CatchClauseSyntax): any;
        public visitFinallyClause(node: TypeScript.FinallyClauseSyntax): any;
        public visitLabeledStatement(node: TypeScript.LabeledStatementSyntax): any;
        public visitDoStatement(node: TypeScript.DoStatementSyntax): any;
        public visitTypeOfExpression(node: TypeScript.TypeOfExpressionSyntax): any;
        public visitDeleteExpression(node: TypeScript.DeleteExpressionSyntax): any;
        public visitVoidExpression(node: TypeScript.VoidExpressionSyntax): any;
        public visitDebuggerStatement(node: TypeScript.DebuggerStatementSyntax): any;
    }
}
declare module TypeScript {
    class SyntaxWalker implements TypeScript.ISyntaxVisitor {
        public visitToken(token: TypeScript.ISyntaxToken): void;
        public visitNode(node: TypeScript.SyntaxNode): void;
        public visitNodeOrToken(nodeOrToken: TypeScript.ISyntaxNodeOrToken): void;
        private visitOptionalToken(token);
        public visitOptionalNode(node: TypeScript.SyntaxNode): void;
        public visitOptionalNodeOrToken(nodeOrToken: TypeScript.ISyntaxNodeOrToken): void;
        public visitList(list: TypeScript.ISyntaxList): void;
        public visitSeparatedList(list: TypeScript.ISeparatedSyntaxList): void;
        public visitSourceUnit(node: TypeScript.SourceUnitSyntax): void;
        public visitExternalModuleReference(node: TypeScript.ExternalModuleReferenceSyntax): void;
        public visitModuleNameModuleReference(node: TypeScript.ModuleNameModuleReferenceSyntax): void;
        public visitImportDeclaration(node: TypeScript.ImportDeclarationSyntax): void;
        public visitExportAssignment(node: TypeScript.ExportAssignmentSyntax): void;
        public visitClassDeclaration(node: TypeScript.ClassDeclarationSyntax): void;
        public visitInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax): void;
        public visitHeritageClause(node: TypeScript.HeritageClauseSyntax): void;
        public visitModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax): void;
        public visitFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax): void;
        public visitVariableStatement(node: TypeScript.VariableStatementSyntax): void;
        public visitVariableDeclaration(node: TypeScript.VariableDeclarationSyntax): void;
        public visitVariableDeclarator(node: TypeScript.VariableDeclaratorSyntax): void;
        public visitEqualsValueClause(node: TypeScript.EqualsValueClauseSyntax): void;
        public visitPrefixUnaryExpression(node: TypeScript.PrefixUnaryExpressionSyntax): void;
        public visitArrayLiteralExpression(node: TypeScript.ArrayLiteralExpressionSyntax): void;
        public visitOmittedExpression(node: TypeScript.OmittedExpressionSyntax): void;
        public visitParenthesizedExpression(node: TypeScript.ParenthesizedExpressionSyntax): void;
        public visitSimpleArrowFunctionExpression(node: TypeScript.SimpleArrowFunctionExpressionSyntax): void;
        public visitParenthesizedArrowFunctionExpression(node: TypeScript.ParenthesizedArrowFunctionExpressionSyntax): void;
        public visitQualifiedName(node: TypeScript.QualifiedNameSyntax): void;
        public visitTypeArgumentList(node: TypeScript.TypeArgumentListSyntax): void;
        public visitConstructorType(node: TypeScript.ConstructorTypeSyntax): void;
        public visitFunctionType(node: TypeScript.FunctionTypeSyntax): void;
        public visitObjectType(node: TypeScript.ObjectTypeSyntax): void;
        public visitArrayType(node: TypeScript.ArrayTypeSyntax): void;
        public visitGenericType(node: TypeScript.GenericTypeSyntax): void;
        public visitTypeQuery(node: TypeScript.TypeQuerySyntax): void;
        public visitTypeAnnotation(node: TypeScript.TypeAnnotationSyntax): void;
        public visitBlock(node: TypeScript.BlockSyntax): void;
        public visitParameter(node: TypeScript.ParameterSyntax): void;
        public visitMemberAccessExpression(node: TypeScript.MemberAccessExpressionSyntax): void;
        public visitPostfixUnaryExpression(node: TypeScript.PostfixUnaryExpressionSyntax): void;
        public visitElementAccessExpression(node: TypeScript.ElementAccessExpressionSyntax): void;
        public visitInvocationExpression(node: TypeScript.InvocationExpressionSyntax): void;
        public visitArgumentList(node: TypeScript.ArgumentListSyntax): void;
        public visitBinaryExpression(node: TypeScript.BinaryExpressionSyntax): void;
        public visitConditionalExpression(node: TypeScript.ConditionalExpressionSyntax): void;
        public visitConstructSignature(node: TypeScript.ConstructSignatureSyntax): void;
        public visitMethodSignature(node: TypeScript.MethodSignatureSyntax): void;
        public visitIndexSignature(node: TypeScript.IndexSignatureSyntax): void;
        public visitPropertySignature(node: TypeScript.PropertySignatureSyntax): void;
        public visitCallSignature(node: TypeScript.CallSignatureSyntax): void;
        public visitParameterList(node: TypeScript.ParameterListSyntax): void;
        public visitTypeParameterList(node: TypeScript.TypeParameterListSyntax): void;
        public visitTypeParameter(node: TypeScript.TypeParameterSyntax): void;
        public visitConstraint(node: TypeScript.ConstraintSyntax): void;
        public visitElseClause(node: TypeScript.ElseClauseSyntax): void;
        public visitIfStatement(node: TypeScript.IfStatementSyntax): void;
        public visitExpressionStatement(node: TypeScript.ExpressionStatementSyntax): void;
        public visitConstructorDeclaration(node: TypeScript.ConstructorDeclarationSyntax): void;
        public visitMemberFunctionDeclaration(node: TypeScript.MemberFunctionDeclarationSyntax): void;
        public visitGetMemberAccessorDeclaration(node: TypeScript.GetMemberAccessorDeclarationSyntax): void;
        public visitSetMemberAccessorDeclaration(node: TypeScript.SetMemberAccessorDeclarationSyntax): void;
        public visitMemberVariableDeclaration(node: TypeScript.MemberVariableDeclarationSyntax): void;
        public visitThrowStatement(node: TypeScript.ThrowStatementSyntax): void;
        public visitReturnStatement(node: TypeScript.ReturnStatementSyntax): void;
        public visitObjectCreationExpression(node: TypeScript.ObjectCreationExpressionSyntax): void;
        public visitSwitchStatement(node: TypeScript.SwitchStatementSyntax): void;
        public visitCaseSwitchClause(node: TypeScript.CaseSwitchClauseSyntax): void;
        public visitDefaultSwitchClause(node: TypeScript.DefaultSwitchClauseSyntax): void;
        public visitBreakStatement(node: TypeScript.BreakStatementSyntax): void;
        public visitContinueStatement(node: TypeScript.ContinueStatementSyntax): void;
        public visitForStatement(node: TypeScript.ForStatementSyntax): void;
        public visitForInStatement(node: TypeScript.ForInStatementSyntax): void;
        public visitWhileStatement(node: TypeScript.WhileStatementSyntax): void;
        public visitWithStatement(node: TypeScript.WithStatementSyntax): void;
        public visitEnumDeclaration(node: TypeScript.EnumDeclarationSyntax): void;
        public visitEnumElement(node: TypeScript.EnumElementSyntax): void;
        public visitCastExpression(node: TypeScript.CastExpressionSyntax): void;
        public visitObjectLiteralExpression(node: TypeScript.ObjectLiteralExpressionSyntax): void;
        public visitSimplePropertyAssignment(node: TypeScript.SimplePropertyAssignmentSyntax): void;
        public visitFunctionPropertyAssignment(node: TypeScript.FunctionPropertyAssignmentSyntax): void;
        public visitGetAccessorPropertyAssignment(node: TypeScript.GetAccessorPropertyAssignmentSyntax): void;
        public visitSetAccessorPropertyAssignment(node: TypeScript.SetAccessorPropertyAssignmentSyntax): void;
        public visitFunctionExpression(node: TypeScript.FunctionExpressionSyntax): void;
        public visitEmptyStatement(node: TypeScript.EmptyStatementSyntax): void;
        public visitTryStatement(node: TypeScript.TryStatementSyntax): void;
        public visitCatchClause(node: TypeScript.CatchClauseSyntax): void;
        public visitFinallyClause(node: TypeScript.FinallyClauseSyntax): void;
        public visitLabeledStatement(node: TypeScript.LabeledStatementSyntax): void;
        public visitDoStatement(node: TypeScript.DoStatementSyntax): void;
        public visitTypeOfExpression(node: TypeScript.TypeOfExpressionSyntax): void;
        public visitDeleteExpression(node: TypeScript.DeleteExpressionSyntax): void;
        public visitVoidExpression(node: TypeScript.VoidExpressionSyntax): void;
        public visitDebuggerStatement(node: TypeScript.DebuggerStatementSyntax): void;
    }
}
declare module TypeScript {
    class PositionTrackingWalker extends TypeScript.SyntaxWalker {
        private _position;
        public visitToken(token: TypeScript.ISyntaxToken): void;
        public position(): number;
        public skip(element: TypeScript.ISyntaxElement): void;
    }
}
declare module TypeScript {
    interface ITokenInformation {
        previousToken: TypeScript.ISyntaxToken;
        nextToken: TypeScript.ISyntaxToken;
    }
    class SyntaxInformationMap extends TypeScript.SyntaxWalker {
        private trackParents;
        private trackPreviousToken;
        private tokenToInformation;
        private elementToPosition;
        private _previousToken;
        private _previousTokenInformation;
        private _currentPosition;
        private _elementToParent;
        private _parentStack;
        constructor(trackParents: boolean, trackPreviousToken: boolean);
        static create(node: TypeScript.SyntaxNode, trackParents: boolean, trackPreviousToken: boolean): SyntaxInformationMap;
        public visitNode(node: TypeScript.SyntaxNode): void;
        public visitToken(token: TypeScript.ISyntaxToken): void;
        public parent(element: TypeScript.ISyntaxElement): TypeScript.SyntaxNode;
        public fullStart(element: TypeScript.ISyntaxElement): number;
        public start(element: TypeScript.ISyntaxElement): number;
        public end(element: TypeScript.ISyntaxElement): number;
        public previousToken(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
        public tokenInformation(token: TypeScript.ISyntaxToken): ITokenInformation;
        public firstTokenInLineContainingToken(token: TypeScript.ISyntaxToken): TypeScript.ISyntaxToken;
        public isFirstTokenInLine(token: TypeScript.ISyntaxToken): boolean;
        private isFirstTokenInLineWorker(information);
    }
}
declare module TypeScript {
    class SyntaxNodeInvariantsChecker extends TypeScript.SyntaxWalker {
        private tokenTable;
        static checkInvariants(node: TypeScript.SyntaxNode): void;
        public visitToken(token: TypeScript.ISyntaxToken): void;
    }
}
declare module TypeScript {
    class DepthLimitedWalker extends TypeScript.PositionTrackingWalker {
        private _depth;
        private _maximumDepth;
        constructor(maximumDepth: number);
        public visitNode(node: TypeScript.SyntaxNode): void;
    }
}
declare module TypeScript.Parser {
    function parse(fileName: string, text: TypeScript.ISimpleText, isDeclaration: boolean, options: TypeScript.ParseOptions): TypeScript.SyntaxTree;
    function incrementalParse(oldSyntaxTree: TypeScript.SyntaxTree, textChangeRange: TypeScript.TextChangeRange, newText: TypeScript.ISimpleText): TypeScript.SyntaxTree;
}
declare module TypeScript {
}
declare module TypeScript {
    class Unicode {
        static unicodeES3IdentifierStart: number[];
        static unicodeES3IdentifierPart: number[];
        static unicodeES5IdentifierStart: number[];
        static unicodeES5IdentifierPart: number[];
        static lookupInUnicodeMap(code: number, map: number[]): boolean;
        static isIdentifierStart(code: number, languageVersion: TypeScript.LanguageVersion): boolean;
        static isIdentifierPart(code: number, languageVersion: TypeScript.LanguageVersion): boolean;
    }
}
declare module TypeScript {
    class SyntaxTree {
        private _sourceUnit;
        private _isDeclaration;
        private _parserDiagnostics;
        private _allDiagnostics;
        private _fileName;
        private _lineMap;
        private _parseOptions;
        constructor(sourceUnit: TypeScript.SourceUnitSyntax, isDeclaration: boolean, diagnostics: TypeScript.Diagnostic[], fileName: string, lineMap: TypeScript.LineMap, parseOtions: TypeScript.ParseOptions);
        public toJSON(key: any): any;
        public sourceUnit(): TypeScript.SourceUnitSyntax;
        public isDeclaration(): boolean;
        private computeDiagnostics();
        public diagnostics(): TypeScript.Diagnostic[];
        public fileName(): string;
        public lineMap(): TypeScript.LineMap;
        public parseOptions(): TypeScript.ParseOptions;
        public structuralEquals(tree: SyntaxTree): boolean;
    }
}
declare module Lint {
    interface Rule {
        getOptions(): any[];
        isEnabled(): boolean;
        apply(syntaxTree: TypeScript.SyntaxTree): RuleFailure[];
        applyWithWalker(walker: Lint.RuleWalker): RuleFailure[];
    }
    class RuleFailurePosition {
        private position;
        private lineAndCharacter;
        constructor(position: number, lineAndCharacter: TypeScript.LineAndCharacter);
        public getPosition(): number;
        public getLineAndCharacter(): TypeScript.LineAndCharacter;
        public toJson(): {
            position: number;
            line: number;
            character: number;
        };
        public equals(ruleFailurePosition: RuleFailurePosition): boolean;
    }
    class RuleFailure {
        private fileName;
        private startPosition;
        private endPosition;
        private failure;
        constructor(syntaxTree: TypeScript.SyntaxTree, start: number, end: number, failure: string);
        public getFileName(): string;
        public getStartPosition(): RuleFailurePosition;
        public getEndPosition(): RuleFailurePosition;
        public getFailure(): string;
        public toJson(): any;
        public equals(ruleFailure: RuleFailure): boolean;
        private createFailurePosition(syntaxTree, position);
    }
}
declare module Lint {
    class RuleWalker extends TypeScript.PositionTrackingWalker {
        private limit;
        private fileName;
        private options;
        private failures;
        private syntaxTree;
        constructor(syntaxTree: TypeScript.SyntaxTree, options?: any);
        public getSyntaxTree(): TypeScript.SyntaxTree;
        public getFailures(): Lint.RuleFailure[];
        public positionAfter(...elements: TypeScript.ISyntaxElement[]): number;
        public getOptions(): any;
        public hasOption(option: string): boolean;
        public createFailure(start: number, width: number, failure: string): Lint.RuleFailure;
        public addFailure(failure: Lint.RuleFailure): void;
        private existsFailure(failure);
    }
}
declare module Lint {
    function loadRules(ruleConfiguration, rulesDirectory?: string): Rule[];
    function findRule(name: string, rulesDirectory?: string);
}
declare module Lint.Configuration {
    function findConfiguration(configFile): any;
}
declare module Lint {
    interface Formatter {
        format(failures: Lint.RuleFailure[]): string;
    }
}
declare module Lint {
    function findFormatter(name: string, formattersDirectory?: string);
}
declare module TypeScript {
    module CompilerDiagnostics {
        var debug: boolean;
        interface IDiagnosticWriter {
            Alert(output: string): void;
        }
        var diagnosticWriter: IDiagnosticWriter;
        var analysisPass: number;
        function Alert(output: string): void;
        function debugPrint(s: string): void;
        function assert(condition: boolean, s: string): void;
    }
    interface IDiagnosticReporter {
        addDiagnostic(diagnostic: TypeScript.Diagnostic): void;
    }
    interface ILogger {
        information(): boolean;
        debug(): boolean;
        warning(): boolean;
        error(): boolean;
        fatal(): boolean;
        log(s: string): void;
    }
    class NullLogger implements ILogger {
        public information(): boolean;
        public debug(): boolean;
        public warning(): boolean;
        public error(): boolean;
        public fatal(): boolean;
        public log(s: string): void;
    }
    function timeFunction(logger: ILogger, funcDescription: string, func: () => any): any;
}
declare module TypeScript {
    function hasFlag(val: number, flag: number): boolean;
    function withoutFlag(val: number, flag: number): number;
    enum ASTFlags {
        None,
        SingleLine,
        OptionalName,
        TypeReference,
        EnumElement,
    }
    enum DeclFlags {
        None,
        Exported,
        Private,
        Public,
        Ambient,
        Static,
    }
    enum ModuleFlags {
        None,
        Exported,
        Private,
        Public,
        Ambient,
        Static,
        IsEnum,
        IsWholeFile,
        IsDynamic,
    }
    enum VariableFlags {
        None,
        Exported,
        Private,
        Public,
        Ambient,
        Static,
        Property,
        ClassProperty,
        EnumElement,
        ForInVariable,
    }
    enum FunctionFlags {
        None,
        Exported,
        Private,
        Public,
        Ambient,
        Static,
        GetAccessor,
        SetAccessor,
        Signature,
        Method,
        CallMember,
        ConstructMember,
        IsFatArrowFunction,
        IndexerMember,
        IsFunctionExpression,
        IsFunctionProperty,
    }
    function ToDeclFlags(functionFlags: FunctionFlags): DeclFlags;
    function ToDeclFlags(varFlags: VariableFlags): DeclFlags;
    function ToDeclFlags(moduleFlags: ModuleFlags): DeclFlags;
    enum TypeRelationshipFlags {
        SuccessfulComparison,
        RequiredPropertyIsMissing,
        IncompatibleSignatures,
        SourceSignatureHasTooManyParameters,
        IncompatibleReturnTypes,
        IncompatiblePropertyTypes,
        IncompatibleParameterTypes,
        InconsistantPropertyAccesibility,
    }
    enum ModuleGenTarget {
        Unspecified,
        Synchronous,
        Asynchronous,
    }
}
declare module TypeScript {
    enum NodeType {
        None,
        List,
        Script,
        TrueLiteral,
        FalseLiteral,
        StringLiteral,
        RegularExpressionLiteral,
        NumericLiteral,
        NullLiteral,
        TypeParameter,
        GenericType,
        TypeRef,
        TypeQuery,
        FunctionDeclaration,
        ClassDeclaration,
        InterfaceDeclaration,
        ModuleDeclaration,
        ImportDeclaration,
        VariableDeclarator,
        VariableDeclaration,
        Parameter,
        Name,
        ArrayLiteralExpression,
        ObjectLiteralExpression,
        OmittedExpression,
        VoidExpression,
        CommaExpression,
        PlusExpression,
        NegateExpression,
        DeleteExpression,
        ThisExpression,
        SuperExpression,
        InExpression,
        MemberAccessExpression,
        InstanceOfExpression,
        TypeOfExpression,
        ElementAccessExpression,
        InvocationExpression,
        ObjectCreationExpression,
        AssignmentExpression,
        AddAssignmentExpression,
        SubtractAssignmentExpression,
        DivideAssignmentExpression,
        MultiplyAssignmentExpression,
        ModuloAssignmentExpression,
        AndAssignmentExpression,
        ExclusiveOrAssignmentExpression,
        OrAssignmentExpression,
        LeftShiftAssignmentExpression,
        SignedRightShiftAssignmentExpression,
        UnsignedRightShiftAssignmentExpression,
        ConditionalExpression,
        LogicalOrExpression,
        LogicalAndExpression,
        BitwiseOrExpression,
        BitwiseExclusiveOrExpression,
        BitwiseAndExpression,
        EqualsWithTypeConversionExpression,
        NotEqualsWithTypeConversionExpression,
        EqualsExpression,
        NotEqualsExpression,
        LessThanExpression,
        LessThanOrEqualExpression,
        GreaterThanExpression,
        GreaterThanOrEqualExpression,
        AddExpression,
        SubtractExpression,
        MultiplyExpression,
        DivideExpression,
        ModuloExpression,
        LeftShiftExpression,
        SignedRightShiftExpression,
        UnsignedRightShiftExpression,
        BitwiseNotExpression,
        LogicalNotExpression,
        PreIncrementExpression,
        PreDecrementExpression,
        PostIncrementExpression,
        PostDecrementExpression,
        CastExpression,
        ParenthesizedExpression,
        Member,
        Block,
        BreakStatement,
        ContinueStatement,
        DebuggerStatement,
        DoStatement,
        EmptyStatement,
        ExportAssignment,
        ExpressionStatement,
        ForInStatement,
        ForStatement,
        IfStatement,
        LabeledStatement,
        ReturnStatement,
        SwitchStatement,
        ThrowStatement,
        TryStatement,
        VariableStatement,
        WhileStatement,
        WithStatement,
        CaseClause,
        CatchClause,
        Comment,
    }
}
declare module TypeScript {
    class BlockIntrinsics {
        public prototype: any;
        public toString: any;
        public toLocaleString: any;
        public valueOf: any;
        public hasOwnProperty: any;
        public propertyIsEnumerable: any;
        public isPrototypeOf: any;
        constructor();
    }
    interface IHashTable<T> {
        getAllKeys(): string[];
        add(key: string, data: T): boolean;
        addOrUpdate(key: string, data: T): boolean;
        map(fn: (k: string, value: T, context: any) => void, context: any): void;
        every(fn: (k: string, value: T, context: any) => void, context: any): boolean;
        some(fn: (k: string, value: T, context: any) => void, context: any): boolean;
        count(): number;
        lookup(key: string): T;
    }
    class StringHashTable<T> implements IHashTable<T> {
        private itemCount;
        private table;
        public getAllKeys(): string[];
        public add(key: string, data: T): boolean;
        public addOrUpdate(key: string, data: T): boolean;
        public map(fn: (k: string, value: T, context: any) => void, context: any): void;
        public every(fn: (k: string, value: T, context: any) => void, context: any): boolean;
        public some(fn: (k: string, value: any, context: any) => void, context: any): boolean;
        public count(): number;
        public lookup(key: string): T;
    }
    class IdentiferNameHashTable<T> extends StringHashTable<T> {
        public getAllKeys(): string[];
        public add(key: string, data: T): boolean;
        public addOrUpdate(key: string, data: T): boolean;
        public map(fn: (k: string, value: T, context: any) => void, context: any): void;
        public every(fn: (k: string, value: T, context: any) => void, context: any): boolean;
        public some(fn: (k: string, value: any, context: any) => void, context: any): boolean;
        public lookup(key: string): T;
    }
}
declare module TypeScript {
    interface IASTSpan {
        minChar: number;
        limChar: number;
        trailingTriviaWidth: number;
    }
    class ASTSpan implements IASTSpan {
        public minChar: number;
        public limChar: number;
        public trailingTriviaWidth: number;
    }
    function structuralEqualsNotIncludingPosition(ast1: AST, ast2: AST): boolean;
    function structuralEqualsIncludingPosition(ast1: AST, ast2: AST): boolean;
    interface IAST extends IASTSpan {
        nodeType(): TypeScript.NodeType;
        astID: number;
        astIDString: string;
        getLength(): number;
    }
    class AST implements IAST {
        public minChar: number;
        public limChar: number;
        public trailingTriviaWidth: number;
        private _flags;
        public typeCheckPhase: number;
        public astIDString: string;
        public astID: number;
        public symbol: TypeScript.PullSymbol;
        public aliasSymbol: TypeScript.PullSymbol;
        public decl: TypeScript.PullDecl;
        private _preComments;
        private _postComments;
        private _docComments;
        constructor();
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public preComments(): Comment[];
        public postComments(): Comment[];
        public setPreComments(comments: Comment[]): void;
        public setPostComments(comments: Comment[]): void;
        public shouldEmit(): boolean;
        public getFlags(): TypeScript.ASTFlags;
        public setFlags(flags: TypeScript.ASTFlags): void;
        public getLength(): number;
        public isDeclaration(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public docComments(): Comment[];
        public structuralEquals(ast: AST, includingPosition: boolean): boolean;
    }
    class ASTList extends AST {
        public members: AST[];
        public separatorCount: number;
        constructor(members: AST[], separatorCount?: number);
        public nodeType(): TypeScript.NodeType;
        public emit(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ASTList, includingPosition: boolean): boolean;
    }
    class Identifier extends AST {
        public actualText: string;
        private _text;
        constructor(actualText: string, text: string);
        public text(): string;
        public nodeType(): TypeScript.NodeType;
        public isMissing(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: Identifier, includingPosition: boolean): boolean;
    }
    class MissingIdentifier extends Identifier {
        constructor();
        public isMissing(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
    }
    class LiteralExpression extends AST {
        private _nodeType;
        constructor(_nodeType: TypeScript.NodeType);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ParenthesizedExpression, includingPosition: boolean): boolean;
    }
    class ThisExpression extends AST {
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ParenthesizedExpression, includingPosition: boolean): boolean;
    }
    class SuperExpression extends AST {
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ParenthesizedExpression, includingPosition: boolean): boolean;
    }
    class ParenthesizedExpression extends AST {
        public expression: AST;
        constructor(expression: AST);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ParenthesizedExpression, includingPosition: boolean): boolean;
    }
    class UnaryExpression extends AST {
        private _nodeType;
        public operand: AST;
        public castTerm: TypeReference;
        constructor(_nodeType: TypeScript.NodeType, operand: AST, castTerm: TypeReference);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: UnaryExpression, includingPosition: boolean): boolean;
    }
    interface ICallExpression extends IAST {
        target: AST;
        typeArguments: ASTList;
        arguments: ASTList;
        closeParenSpan: ASTSpan;
        callResolutionData: TypeScript.PullAdditionalCallResolutionData;
    }
    class ObjectCreationExpression extends AST implements ICallExpression {
        public target: AST;
        public typeArguments: ASTList;
        public arguments: ASTList;
        public closeParenSpan: ASTSpan;
        public callResolutionData: TypeScript.PullAdditionalCallResolutionData;
        constructor(target: AST, typeArguments: ASTList, arguments: ASTList, closeParenSpan: ASTSpan);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ObjectCreationExpression, includingPosition: boolean): boolean;
    }
    class InvocationExpression extends AST implements ICallExpression {
        public target: AST;
        public typeArguments: ASTList;
        public arguments: ASTList;
        public closeParenSpan: ASTSpan;
        public callResolutionData: TypeScript.PullAdditionalCallResolutionData;
        constructor(target: AST, typeArguments: ASTList, arguments: ASTList, closeParenSpan: ASTSpan);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: InvocationExpression, includingPosition: boolean): boolean;
    }
    class BinaryExpression extends AST {
        private _nodeType;
        public operand1: AST;
        public operand2: AST;
        constructor(_nodeType: TypeScript.NodeType, operand1: AST, operand2: AST);
        public nodeType(): TypeScript.NodeType;
        static getTextForBinaryToken(nodeType: TypeScript.NodeType): string;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: BinaryExpression, includingPosition: boolean): boolean;
    }
    class ConditionalExpression extends AST {
        public operand1: AST;
        public operand2: AST;
        public operand3: AST;
        constructor(operand1: AST, operand2: AST, operand3: AST);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ConditionalExpression, includingPosition: boolean): boolean;
    }
    class NumberLiteral extends AST {
        public value: number;
        private _text;
        constructor(value: number, text: string);
        public text(): string;
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: NumberLiteral, includingPosition: boolean): boolean;
    }
    class RegexLiteral extends AST {
        public text: string;
        constructor(text: string);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: RegexLiteral, includingPosition: boolean): boolean;
    }
    class StringLiteral extends AST {
        public actualText: string;
        private _text;
        constructor(actualText: string, text: string);
        public text(): string;
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: StringLiteral, includingPosition: boolean): boolean;
    }
    class ImportDeclaration extends AST {
        public id: Identifier;
        public alias: AST;
        private _varFlags;
        constructor(id: Identifier, alias: AST);
        public nodeType(): TypeScript.NodeType;
        public isDeclaration(): boolean;
        public getVarFlags(): TypeScript.VariableFlags;
        public setVarFlags(flags: TypeScript.VariableFlags): void;
        public isExternalImportDeclaration(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
        public getAliasName(aliasAST?: AST): string;
        public firstAliasedModToString(): string;
        public structuralEquals(ast: ImportDeclaration, includingPosition: boolean): boolean;
    }
    class ExportAssignment extends AST {
        public id: Identifier;
        constructor(id: Identifier);
        public nodeType(): TypeScript.NodeType;
        public structuralEquals(ast: ExportAssignment, includingPosition: boolean): boolean;
        public emit(emitter: TypeScript.Emitter): void;
    }
    class BoundDecl extends AST {
        public id: Identifier;
        public typeExpr: AST;
        public init: AST;
        public constantValue: number;
        private _varFlags;
        constructor(id: Identifier, typeExpr: AST, init: AST);
        public isDeclaration(): boolean;
        public getVarFlags(): TypeScript.VariableFlags;
        public setVarFlags(flags: TypeScript.VariableFlags): void;
        public isProperty(): boolean;
        public structuralEquals(ast: BoundDecl, includingPosition: boolean): boolean;
    }
    class VariableDeclarator extends BoundDecl {
        constructor(id: Identifier, typeExpr: AST, init: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatic(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
    }
    class Parameter extends BoundDecl {
        public isOptional: boolean;
        constructor(id: Identifier, typeExpr: AST, init: AST, isOptional: boolean);
        public nodeType(): TypeScript.NodeType;
        public isOptionalArg(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: Parameter, includingPosition: boolean): boolean;
    }
    class FunctionDeclaration extends AST {
        public name: Identifier;
        public block: Block;
        public isConstructor: boolean;
        public typeArguments: ASTList;
        public arguments: ASTList;
        public returnTypeAnnotation: AST;
        public variableArgList: boolean;
        public hint: string;
        private _functionFlags;
        public classDecl: ClassDeclaration;
        public returnStatementsWithExpressions: ReturnStatement[];
        constructor(name: Identifier, block: Block, isConstructor: boolean, typeArguments: ASTList, arguments: ASTList, returnTypeAnnotation: AST, variableArgList: boolean);
        public isDeclaration(): boolean;
        public nodeType(): TypeScript.NodeType;
        public getFunctionFlags(): TypeScript.FunctionFlags;
        public setFunctionFlags(flags: TypeScript.FunctionFlags): void;
        public structuralEquals(ast: FunctionDeclaration, includingPosition: boolean): boolean;
        public shouldEmit(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
        public getNameText(): string;
        public isMethod(): boolean;
        public isCallMember(): boolean;
        public isConstructMember(): boolean;
        public isIndexerMember(): boolean;
        public isSpecialFn(): boolean;
        public isAccessor(): boolean;
        public isGetAccessor(): boolean;
        public isSetAccessor(): boolean;
        public isStatic(): boolean;
        public isSignature(): boolean;
    }
    class Script extends AST {
        public moduleElements: ASTList;
        public referencedFiles: string[];
        public isDeclareFile: boolean;
        public topLevelMod: ModuleDeclaration;
        public nodeType(): TypeScript.NodeType;
        public emit(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: Script, includingPosition: boolean): boolean;
    }
    class ModuleDeclaration extends AST {
        public name: Identifier;
        public members: ASTList;
        public endingToken: ASTSpan;
        private _moduleFlags;
        public prettyName: string;
        public amdDependencies: string[];
        constructor(name: Identifier, members: ASTList, endingToken: ASTSpan);
        public isDeclaration(): boolean;
        public nodeType(): TypeScript.NodeType;
        public getModuleFlags(): TypeScript.ModuleFlags;
        public setModuleFlags(flags: TypeScript.ModuleFlags): void;
        public structuralEquals(ast: ModuleDeclaration, includingPosition: boolean): boolean;
        public isEnum(): boolean;
        public isWholeFile(): boolean;
        public shouldEmit(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
    }
    class TypeDeclaration extends AST {
        public name: Identifier;
        public typeParameters: ASTList;
        public extendsList: ASTList;
        public implementsList: ASTList;
        public members: ASTList;
        private _varFlags;
        constructor(name: Identifier, typeParameters: ASTList, extendsList: ASTList, implementsList: ASTList, members: ASTList);
        public isDeclaration(): boolean;
        public getVarFlags(): TypeScript.VariableFlags;
        public setVarFlags(flags: TypeScript.VariableFlags): void;
        public structuralEquals(ast: TypeDeclaration, includingPosition: boolean): boolean;
    }
    class ClassDeclaration extends TypeDeclaration {
        public endingToken: ASTSpan;
        public constructorDecl: FunctionDeclaration;
        constructor(name: Identifier, typeParameters: ASTList, members: ASTList, extendsList: ASTList, implementsList: ASTList, endingToken: ASTSpan);
        public nodeType(): TypeScript.NodeType;
        public shouldEmit(): boolean;
        public emit(emitter: TypeScript.Emitter): void;
    }
    class InterfaceDeclaration extends TypeDeclaration {
        public isObjectTypeLiteral: boolean;
        constructor(name: Identifier, typeParameters: ASTList, members: ASTList, extendsList: ASTList, implementsList: ASTList, isObjectTypeLiteral: boolean);
        public nodeType(): TypeScript.NodeType;
        public shouldEmit(): boolean;
    }
    class ThrowStatement extends AST {
        public expression: AST;
        constructor(expression: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ThrowStatement, includingPosition: boolean): boolean;
    }
    class ExpressionStatement extends AST {
        public expression: AST;
        constructor(expression: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ExpressionStatement, includingPosition: boolean): boolean;
    }
    class LabeledStatement extends AST {
        public identifier: Identifier;
        public statement: AST;
        constructor(identifier: Identifier, statement: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: LabeledStatement, includingPosition: boolean): boolean;
    }
    class VariableDeclaration extends AST {
        public declarators: ASTList;
        constructor(declarators: ASTList);
        public nodeType(): TypeScript.NodeType;
        public emit(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: VariableDeclaration, includingPosition: boolean): boolean;
    }
    class VariableStatement extends AST {
        public declaration: VariableDeclaration;
        constructor(declaration: VariableDeclaration);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public shouldEmit(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: VariableStatement, includingPosition: boolean): boolean;
    }
    class Block extends AST {
        public statements: ASTList;
        public closeBraceSpan: IASTSpan;
        public closeBraceLeadingComments: Comment[];
        constructor(statements: ASTList, closeBraceSpan: IASTSpan);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: Block, includingPosition: boolean): boolean;
    }
    class Jump extends AST {
        private _nodeType;
        public target: string;
        constructor(_nodeType: TypeScript.NodeType, target: string);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public hasExplicitTarget(): string;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: Jump, includingPosition: boolean): boolean;
    }
    class WhileStatement extends AST {
        public cond: AST;
        public body: AST;
        constructor(cond: AST, body: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: WhileStatement, includingPosition: boolean): boolean;
    }
    class DoStatement extends AST {
        public body: AST;
        public cond: AST;
        public whileSpan: ASTSpan;
        constructor(body: AST, cond: AST, whileSpan: ASTSpan);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: DoStatement, includingPosition: boolean): boolean;
    }
    class IfStatement extends AST {
        public cond: AST;
        public thenBod: AST;
        public elseBod: AST;
        constructor(cond: AST, thenBod: AST, elseBod: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: IfStatement, includingPosition: boolean): boolean;
    }
    class ReturnStatement extends AST {
        public returnExpression: AST;
        constructor(returnExpression: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ReturnStatement, includingPosition: boolean): boolean;
    }
    class ForInStatement extends AST {
        public lval: AST;
        public obj: AST;
        public body: AST;
        constructor(lval: AST, obj: AST, body: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ForInStatement, includingPosition: boolean): boolean;
    }
    class ForStatement extends AST {
        public init: AST;
        public cond: AST;
        public incr: AST;
        public body: AST;
        constructor(init: AST, cond: AST, incr: AST, body: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: ForStatement, includingPosition: boolean): boolean;
    }
    class WithStatement extends AST {
        public expr: AST;
        public body: AST;
        constructor(expr: AST, body: AST);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: WithStatement, includingPosition: boolean): boolean;
    }
    class SwitchStatement extends AST {
        public val: AST;
        public caseList: ASTList;
        public defaultCase: CaseClause;
        public statement: ASTSpan;
        constructor(val: AST, caseList: ASTList, defaultCase: CaseClause, statement: ASTSpan);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: SwitchStatement, includingPosition: boolean): boolean;
    }
    class CaseClause extends AST {
        public expr: AST;
        public body: ASTList;
        constructor(expr: AST, body: ASTList);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: CaseClause, includingPosition: boolean): boolean;
    }
    class TypeParameter extends AST {
        public name: Identifier;
        public constraint: AST;
        constructor(name: Identifier, constraint: AST);
        public nodeType(): TypeScript.NodeType;
        public structuralEquals(ast: TypeParameter, includingPosition: boolean): boolean;
    }
    class GenericType extends AST {
        public name: AST;
        public typeArguments: ASTList;
        constructor(name: AST, typeArguments: ASTList);
        public nodeType(): TypeScript.NodeType;
        public emit(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: GenericType, includingPosition: boolean): boolean;
    }
    class TypeQuery extends AST {
        public name: AST;
        constructor(name: AST);
        public nodeType(): TypeScript.NodeType;
        public emit(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: TypeQuery, includingPosition: boolean): boolean;
    }
    class TypeReference extends AST {
        public term: AST;
        public arrayCount: number;
        constructor(term: AST, arrayCount: number);
        public nodeType(): TypeScript.NodeType;
        public emit(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: TypeReference, includingPosition: boolean): boolean;
    }
    class TryStatement extends AST {
        public tryBody: Block;
        public catchClause: CatchClause;
        public finallyBody: Block;
        constructor(tryBody: Block, catchClause: CatchClause, finallyBody: Block);
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: TryStatement, includingPosition: boolean): boolean;
    }
    class CatchClause extends AST {
        public param: VariableDeclarator;
        public body: Block;
        constructor(param: VariableDeclarator, body: Block);
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: CatchClause, includingPosition: boolean): boolean;
    }
    class DebuggerStatement extends AST {
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
    }
    class OmittedExpression extends AST {
        public nodeType(): TypeScript.NodeType;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: CatchClause, includingPosition: boolean): boolean;
    }
    class EmptyStatement extends AST {
        public nodeType(): TypeScript.NodeType;
        public isStatement(): boolean;
        public emitWorker(emitter: TypeScript.Emitter): void;
        public structuralEquals(ast: CatchClause, includingPosition: boolean): boolean;
    }
    class Comment extends AST {
        public content: string;
        public isBlockComment: boolean;
        public endsLine: boolean;
        public text: string[];
        private docCommentText;
        constructor(content: string, isBlockComment: boolean, endsLine: boolean);
        public nodeType(): TypeScript.NodeType;
        public structuralEquals(ast: Comment, includingPosition: boolean): boolean;
        public getText(): string[];
        public isDocComment(): boolean;
        public getDocCommentTextValue(): string;
        static consumeLeadingSpace(line: string, startIndex: number, maxSpacesToRemove?: number): number;
        static isSpaceChar(line: string, index: number): boolean;
        static cleanDocCommentLine(line: string, jsDocStyleComment: boolean, jsDocLineSpaceToRemove?: number): {
            minChar: number;
            limChar: number;
            jsDocSpacesRemoved: number;
        };
        static cleanJSDocComment(content: string, spacesToRemove?: number): string;
        static getDocCommentText(comments: Comment[]): string;
        static getParameterDocCommentText(param: string, fncDocComments: Comment[]): string;
    }
}
declare module TypeScript {
    interface IAstWalker {
        walk(ast: TypeScript.AST, parent: TypeScript.AST): TypeScript.AST;
        options: AstWalkOptions;
        state: any;
    }
    class AstWalkOptions {
        public goChildren: boolean;
    }
    interface IAstWalkCallback {
        (ast: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker): TypeScript.AST;
    }
    interface IAstWalkChildren {
        (preAst: TypeScript.AST, parent: TypeScript.AST, walker: IAstWalker): void;
    }
    class AstWalkerFactory {
        private childrenWalkers;
        constructor();
        public walk(ast: TypeScript.AST, pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): TypeScript.AST;
        public getWalker(pre: IAstWalkCallback, post?: IAstWalkCallback, options?: AstWalkOptions, state?: any): IAstWalker;
        private getSlowWalker(pre, post?, options?, state?);
        private initChildrenWalkers();
    }
    function getAstWalkerFactory(): AstWalkerFactory;
}
declare module TypeScript {
    function max(a: number, b: number): number;
    function min(a: number, b: number): number;
    class AstPath {
        public asts: TypeScript.AST[];
        public top: number;
        static reverseIndexOf(items: any[], index: number): any;
        public clone(): AstPath;
        public pop(): TypeScript.AST;
        public push(ast: TypeScript.AST): void;
        public up(): void;
        public down(): void;
        public nodeType(): TypeScript.NodeType;
        public ast(): TypeScript.AST;
        public parent(): TypeScript.AST;
        public count(): number;
        public get(index: number): TypeScript.AST;
        public isNameOfClass(): boolean;
        public isNameOfInterface(): boolean;
        public isNameOfArgument(): boolean;
        public isNameOfVariable(): boolean;
        public isNameOfModule(): boolean;
        public isNameOfFunction(): boolean;
        public isBodyOfFunction(): boolean;
        public isArgumentListOfFunction(): boolean;
        public isTargetOfCall(): boolean;
        public isTargetOfNew(): boolean;
        public isInClassImplementsList(): boolean;
        public isInInterfaceExtendsList(): boolean;
        public isMemberOfMemberAccessExpression(): boolean;
        public isCallExpression(): boolean;
        public isCallExpressionTarget(): boolean;
        public isDeclaration(): boolean;
        private isMemberOfList(list, item);
    }
    function isValidAstNode(ast: IASTSpan): boolean;
    class AstPathContext {
        public path: AstPath;
    }
    function getAstPathToPosition(script: AST, pos: number, useTrailingTriviaAsLimChar?: boolean): AstPath;
    function walkAST(ast: AST, callback: (path: AstPath, walker: IAstWalker) => void): void;
}
declare module TypeScript {
    class Base64VLQFormat {
        static encode(inValue: number): string;
        static decode(inString: string): {
            value: number;
            rest: string;
        };
    }
}
declare module TypeScript {
    class SourceMapPosition {
        public sourceLine: number;
        public sourceColumn: number;
        public emittedLine: number;
        public emittedColumn: number;
    }
    class SourceMapping {
        public start: SourceMapPosition;
        public end: SourceMapPosition;
        public nameIndex: number;
        public childMappings: SourceMapping[];
    }
    class SourceMapSourceInfo {
        public jsFileName: string;
        public tsFilePath: string;
        public sourceMapPath: string;
        public sourceMapDirectory: string;
        public sourceRoot: string;
        constructor(oldSourceMapSourceInfo?: SourceMapSourceInfo);
    }
    class SourceMapper {
        public jsFile: ITextWriter;
        public sourceMapOut: ITextWriter;
        public sourceMapSourceInfo: SourceMapSourceInfo;
        static MapFileExtension: string;
        public sourceMappings: SourceMapping[];
        public currentMappings: SourceMapping[][];
        public names: string[];
        public currentNameIndex: number[];
        constructor(jsFile: ITextWriter, sourceMapOut: ITextWriter, sourceMapSourceInfo: SourceMapSourceInfo);
        static emitSourceMapping(allSourceMappers: SourceMapper[]): void;
    }
}
declare module TypeScript {
    enum EmitContainer {
        Prog,
        Module,
        DynamicModule,
        Class,
        Constructor,
        Function,
        Args,
        Interface,
    }
    class EmitState {
        public column: number;
        public line: number;
        public container: EmitContainer;
        constructor();
    }
    class EmitOptions {
        public compilationSettings: TypeScript.CompilationSettings;
        public ioHost: TypeScript.EmitterIOHost;
        public outputMany: boolean;
        public commonDirectoryPath: string;
        constructor(compilationSettings: TypeScript.CompilationSettings);
        public mapOutputFileName(document: TypeScript.Document, extensionChanger: (fname: string, wholeFileNameReplaced: boolean) => string): string;
        public decodeSourceMapOptions(document: TypeScript.Document, jsFilePath: string, oldSourceMapSourceInfo?: TypeScript.SourceMapSourceInfo): TypeScript.SourceMapSourceInfo;
    }
    class Indenter {
        static indentStep: number;
        static indentStepString: string;
        static indentStrings: string[];
        public indentAmt: number;
        public increaseIndent(): void;
        public decreaseIndent(): void;
        public getIndent(): string;
    }
    interface BoundDeclInfo {
        boundDecl: TypeScript.BoundDecl;
        pullDecl: TypeScript.PullDecl;
    }
    class Emitter {
        public emittingFileName: string;
        public outfile: ITextWriter;
        public emitOptions: EmitOptions;
        private semanticInfoChain;
        public globalThisCapturePrologueEmitted: boolean;
        public extendsPrologueEmitted: boolean;
        public thisClassNode: TypeScript.ClassDeclaration;
        public thisFunctionDeclaration: TypeScript.FunctionDeclaration;
        public moduleName: string;
        public emitState: EmitState;
        public indenter: Indenter;
        public modAliasId: string;
        public firstModAlias: string;
        public allSourceMappers: TypeScript.SourceMapper[];
        public sourceMapper: TypeScript.SourceMapper;
        public captureThisStmtString: string;
        public varListCountStack: number[];
        private declStack;
        private resolvingContext;
        private exportAssignmentIdentifier;
        public document: TypeScript.Document;
        private copyrightElement;
        constructor(emittingFileName: string, outfile: ITextWriter, emitOptions: EmitOptions, semanticInfoChain: TypeScript.SemanticInfoChain);
        private pushDecl(decl);
        private popDecl(decl);
        private getEnclosingDecl();
        public setExportAssignmentIdentifier(id: string): void;
        public getExportAssignmentIdentifier(): string;
        public setDocument(document: TypeScript.Document): void;
        public importStatementShouldBeEmitted(importDeclAST: TypeScript.ImportDeclaration, unitPath?: string): boolean;
        public emitImportDeclaration(importDeclAST: TypeScript.ImportDeclaration): void;
        public setSourceMappings(mapper: TypeScript.SourceMapper): void;
        private updateLineAndColumn(s);
        public writeToOutput(s: string): void;
        public writeToOutputTrimmable(s: string): void;
        public writeLineToOutput(s: string): void;
        public writeCaptureThisStatement(ast: TypeScript.AST): void;
        public setInVarBlock(count: number): void;
        public setContainer(c: number): number;
        private getIndentString();
        public emitIndent(): void;
        public emitComment(comment: TypeScript.Comment): void;
        public emitComments(ast: TypeScript.AST, pre: boolean): void;
        public emitCommentsArray(comments: TypeScript.Comment[]): void;
        public emitObjectLiteral(objectLiteral: TypeScript.UnaryExpression): void;
        public emitArrayLiteral(arrayLiteral: TypeScript.UnaryExpression): void;
        public emitNew(objectCreationExpression: TypeScript.ObjectCreationExpression, target: TypeScript.AST, args: TypeScript.ASTList): void;
        public getVarDeclFromIdentifier(boundDeclInfo: BoundDeclInfo): BoundDeclInfo;
        public getConstantDecl(dotExpr: TypeScript.BinaryExpression): BoundDeclInfo;
        public tryEmitConstant(dotExpr: TypeScript.BinaryExpression): boolean;
        public emitCall(callNode: TypeScript.InvocationExpression, target: TypeScript.AST, args: TypeScript.ASTList): void;
        public emitInnerFunction(funcDecl: TypeScript.FunctionDeclaration, printName: boolean, includePreComments?: boolean): void;
        private emitDefaultValueAssignments(funcDecl);
        private emitRestParameterInitializer(funcDecl);
        private getImportDecls(fileName);
        public getModuleImportAndDependencyList(moduleDecl: TypeScript.ModuleDeclaration): {
            importList: string;
            dependencyList: string;
        };
        public shouldCaptureThis(ast: TypeScript.AST): boolean;
        public emitModule(moduleDecl: TypeScript.ModuleDeclaration): void;
        public emitEnumElement(varDecl: TypeScript.VariableDeclarator): void;
        public emitIndex(operand1: TypeScript.AST, operand2: TypeScript.AST): void;
        public emitFunction(funcDecl: TypeScript.FunctionDeclaration): void;
        public emitAmbientVarDecl(varDecl: TypeScript.VariableDeclarator): void;
        public varListCount(): number;
        public emitVarDeclVar(): boolean;
        public onEmitVar(): void;
        public emitVariableDeclaration(declaration: TypeScript.VariableDeclaration): void;
        public emitVariableDeclarator(varDecl: TypeScript.VariableDeclarator): void;
        private symbolIsUsedInItsEnclosingContainer(symbol, dynamic?);
        public emitName(name: TypeScript.Identifier, addThis: boolean): void;
        public recordSourceMappingNameStart(name: string): void;
        public recordSourceMappingNameEnd(): void;
        public recordSourceMappingStart(ast: TypeScript.IASTSpan): void;
        public recordSourceMappingEnd(ast: TypeScript.IASTSpan): void;
        public emitSourceMapsAndClose(): void;
        private emitParameterPropertyAndMemberVariableAssignments();
        public emitCommaSeparatedList(list: TypeScript.ASTList, startLine?: boolean): void;
        public emitModuleElements(list: TypeScript.ASTList): void;
        private isDirectivePrologueElement(node);
        public emitSpaceBetweenConstructs(node1: TypeScript.AST, node2: TypeScript.AST): void;
        private getCopyrightComments();
        private emitPossibleCopyrightHeaders(script);
        public emitScriptElements(script: TypeScript.Script): void;
        public emitConstructorStatements(funcDecl: TypeScript.FunctionDeclaration): void;
        public emitJavascript(ast: TypeScript.AST, startLine: boolean): void;
        public emitPropertyAccessor(funcDecl: TypeScript.FunctionDeclaration, className: string, isProto: boolean): void;
        public emitPrototypeMember(funcDecl: TypeScript.FunctionDeclaration, className: string): void;
        public emitClass(classDecl: TypeScript.ClassDeclaration): void;
        private emitClassMembers(classDecl);
        private requiresExtendsBlock(moduleElements);
        public emitPrologue(script: TypeScript.Script): void;
        public emitSuperReference(): void;
        public emitSuperCall(callEx: TypeScript.InvocationExpression): boolean;
        public emitThis(): void;
        public emitBlockOrStatement(node: TypeScript.AST): void;
        static throwEmitterError(e: Error): void;
        static handleEmitterError(fileName: string, e: Error): TypeScript.Diagnostic[];
    }
}
declare module TypeScript {
    class MemberName {
        public prefix: string;
        public suffix: string;
        public isString(): boolean;
        public isArray(): boolean;
        public isMarker(): boolean;
        public toString(): string;
        static memberNameToString(memberName: MemberName, markerInfo?: number[], markerBaseLength?: number): string;
        static create(text: string): MemberName;
        static create(entry: MemberName, prefix: string, suffix: string): MemberName;
    }
    class MemberNameString extends MemberName {
        public text: string;
        constructor(text: string);
        public isString(): boolean;
    }
    class MemberNameArray extends MemberName {
        public delim: string;
        public entries: MemberName[];
        public isArray(): boolean;
        public add(entry: MemberName): void;
        public addAll(entries: MemberName[]): void;
        constructor();
    }
}
declare module TypeScript {
    function stripQuotes(str: string): string;
    function isSingleQuoted(str: string): boolean;
    function isQuoted(str: string): boolean;
    function quoteStr(str: string): string;
    function swapQuotes(str: string): string;
    function switchToForwardSlashes(path: string): string;
    function trimModName(modName: string): string;
    function getDeclareFilePath(fname: string): string;
    function isJSFile(fname: string): boolean;
    function isTSFile(fname: string): boolean;
    function isDTSFile(fname: string): boolean;
    function getPrettyName(modPath: string, quote?: boolean, treatAsFileName?: boolean): any;
    function getPathComponents(path: string): string[];
    function getRelativePathToFixedPath(fixedModFilePath: string, absoluteModPath: string, isAbsoultePathURL?: boolean): string;
    function quoteBaseName(modPath: string): string;
    function changePathToDTS(modPath: string): string;
    function isRelative(path: string): boolean;
    function isRooted(path: string): boolean;
    function getRootFilePath(outFname: string): string;
    function filePathComponents(fullPath: string): string[];
    function filePath(fullPath: string): string;
    function normalizePath(path: string): string;
}
declare module TypeScript {
    interface IFileReference extends TypeScript.ILineAndCharacter {
        path: string;
        isResident: boolean;
        position: number;
        length: number;
    }
}
declare module TypeScript {
    interface IResolvedFile {
        path: string;
        referencedFiles: string[];
        importedFiles: string[];
    }
    interface IReferenceResolverHost {
        getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot;
        resolveRelativePath(path: string, directory: string): string;
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        getParentDirectory(path: string): string;
    }
    class ReferenceResolutionResult {
        public resolvedFiles: IResolvedFile[];
        public diagnostics: TypeScript.Diagnostic[];
        public seenNoDefaultLibTag: boolean;
    }
    class ReferenceResolver {
        private inputFileNames;
        private host;
        private settings;
        private visited;
        constructor(inputFileNames: string[], host: IReferenceResolverHost, settings: TypeScript.CompilationSettings);
        static resolve(inputFileNames: string[], host: IReferenceResolverHost, settings: TypeScript.CompilationSettings): ReferenceResolutionResult;
        public resolveInputFiles(): ReferenceResolutionResult;
        private resolveIncludedFile(path, referenceLocation, resolutionResult);
        private resolveImportedFile(path, referenceLocation, resolutionResult);
        private resolveFile(normalizedPath, resolutionResult);
        private getNormalizedFilePath(path, parentFilePath);
        private getUniqueFileId(filePath);
        private recordVisitedFile(filePath);
        private isVisited(filePath);
        private isSameFile(filePath1, filePath2);
    }
}
declare module TypeScript {
    class TextWriter implements ITextWriter {
        private ioHost;
        private path;
        private writeByteOrderMark;
        private contents;
        public onNewLine: boolean;
        constructor(ioHost: TypeScript.EmitterIOHost, path: string, writeByteOrderMark: boolean);
        public Write(s: string): void;
        public WriteLine(s: string): void;
        public Close(): void;
    }
    class DeclarationEmitter {
        private emittingFileName;
        public document: TypeScript.Document;
        private compiler;
        private declFile;
        private indenter;
        private declarationContainerStack;
        private isDottedModuleName;
        private dottedModuleEmit;
        private ignoreCallbackAst;
        private varListCount;
        private emittedReferencePaths;
        constructor(emittingFileName: string, document: TypeScript.Document, compiler: TypeScript.TypeScriptCompiler);
        public widenType(type: TypeScript.PullTypeSymbol): TypeScript.PullTypeSymbol;
        public close(): void;
        public emitDeclarations(script: TypeScript.Script): void;
        public getAstDeclarationContainer(): TypeScript.AST;
        private emitDottedModuleName();
        private getIndentString(declIndent?);
        private emitIndent();
        private canEmitSignature(declFlags, declAST, canEmitGlobalAmbientDecl?, useDeclarationContainerTop?);
        private canEmitPrePostAstSignature(declFlags, astWithPrePostCallback, preCallback);
        private getDeclFlagsString(declFlags, pullDecl, typeString);
        private emitDeclFlags(declFlags, pullDecl, typeString);
        private canEmitTypeAnnotationSignature(declFlag?);
        private pushDeclarationContainer(ast);
        private popDeclarationContainer(ast);
        public emitTypeNamesMember(memberName: TypeScript.MemberName, emitIndent?: boolean): void;
        private emitTypeSignature(type);
        private emitComment(comment);
        private emitDeclarationComments(ast, endLine?);
        public writeDeclarationComments(declComments: TypeScript.Comment[], endLine?: boolean): void;
        public emitTypeOfBoundDecl(boundDecl: TypeScript.BoundDecl): void;
        private variableDeclaratorCallback(pre, varDecl);
        private blockCallback(pre, block);
        private variableStatementCallback(pre, variableStatement);
        private variableDeclarationCallback(pre, variableDeclaration);
        private emitArgDecl(argDecl, funcDecl);
        public isOverloadedCallSignature(funcDecl: TypeScript.FunctionDeclaration): boolean;
        private functionDeclarationCallback(pre, funcDecl);
        public emitBaseExpression(bases: TypeScript.ASTList, index: number): void;
        private emitBaseList(typeDecl, useExtendsList);
        private emitAccessorDeclarationComments(funcDecl);
        public emitPropertyAccessorSignature(funcDecl: TypeScript.FunctionDeclaration): boolean;
        private emitClassMembersFromConstructorDefinition(funcDecl);
        private classDeclarationCallback(pre, classDecl);
        private emitTypeParameters(typeParams, funcSignature?);
        private interfaceDeclarationCallback(pre, interfaceDecl);
        private importDeclarationCallback(pre, importDeclAST);
        private emitEnumSignature(moduleDecl);
        private moduleDeclarationCallback(pre, moduleDecl);
        public exportAssignmentCallback(pre: boolean, ast: TypeScript.ExportAssignment): boolean;
        private emitReferencePaths(script);
        public scriptCallback(pre: boolean, script: TypeScript.Script): boolean;
        private defaultCallback(pre, ast);
    }
}
declare module TypeScript {
    class BloomFilter {
        private bitArray;
        private hashFunctionCount;
        static falsePositiveProbability: number;
        constructor(expectedCount: number);
        static computeM(expectedCount: number): number;
        static computeK(expectedCount: number): number;
        private computeHash(key, seed);
        public addKeys(keys: TypeScript.BlockIntrinsics): void;
        public add(value: string): void;
        public probablyContains(value: string): boolean;
        public isEquivalent(filter: BloomFilter): boolean;
        static isEquivalent(array1: boolean[], array2: boolean[]): boolean;
    }
}
declare module TypeScript {
    class IdentifierWalker extends TypeScript.SyntaxWalker {
        public list: TypeScript.BlockIntrinsics;
        constructor(list: TypeScript.BlockIntrinsics);
        public visitToken(token: TypeScript.ISyntaxToken): void;
    }
}
declare module TypeScript {
    class DataMap {
        public map: any;
        public link(id: string, data: any): void;
        public unlink(id: string): void;
        public read(id: string): any;
    }
}
declare module TypeScript {
    enum PullElementFlags {
        None,
        Exported,
        Private,
        Public,
        Ambient,
        Static,
        GetAccessor,
        SetAccessor,
        Optional,
        Call,
        Constructor,
        Index,
        Signature,
        Enum,
        FatArrow,
        ClassConstructorVariable,
        InitializedModule,
        InitializedDynamicModule,
        InitializedEnum,
        MustCaptureThis,
        Constant,
        ExpressionElement,
        DeclaredInAWithBlock,
        HasReturnStatement,
        PropertyParameter,
        IsAnnotatedWithAny,
        ImplicitVariable,
        SomeInitializedModule,
    }
    enum PullElementKind {
        None,
        Global,
        Script,
        Primitive,
        Container,
        Class,
        Interface,
        DynamicModule,
        Enum,
        Array,
        TypeAlias,
        ObjectLiteral,
        Variable,
        Parameter,
        Property,
        TypeParameter,
        Function,
        ConstructorMethod,
        Method,
        FunctionExpression,
        GetAccessor,
        SetAccessor,
        CallSignature,
        ConstructSignature,
        IndexSignature,
        ObjectType,
        FunctionType,
        ConstructorType,
        EnumMember,
        ErrorType,
        Expression,
        WithBlock,
        CatchBlock,
        All,
        SomeFunction,
        SomeValue,
        SomeType,
        AcceptableAlias,
        SomeContainer,
        SomeBlock,
        SomeSignature,
        SomeAccessor,
        SomeTypeReference,
        SomeLHS,
        InterfaceTypeExtension,
        ClassTypeExtension,
        EnumTypeExtension,
    }
}
declare module TypeScript {
    var pullDeclID: number;
    var lastBoundPullDeclId: number;
    class PullDecl {
        public kind: TypeScript.PullElementKind;
        public name: string;
        private declDisplayName;
        private symbol;
        private declGroups;
        private signatureSymbol;
        private specializingSignatureSymbol;
        private childDecls;
        private typeParameters;
        public childDeclTypeCache: any;
        public childDeclValueCache: any;
        public childDeclNamespaceCache: any;
        public childDeclTypeParameterCache: any;
        public declID: number;
        public declIDString: string;
        public flags: TypeScript.PullElementFlags;
        private span;
        private scriptName;
        private diagnostics;
        private parentDecl;
        private _parentPath;
        private _isBound;
        private synthesizedValDecl;
        public hashCode: number;
        public ast: TypeScript.AST;
        constructor(declName: string, displayName: string, kind: TypeScript.PullElementKind, declFlags: TypeScript.PullElementFlags, span: TypeScript.TextSpan, scriptName: string);
        public getDisplayName(): string;
        public setSymbol(symbol: TypeScript.PullSymbol): void;
        public ensureSymbolIsBound(bindSignatureSymbol?: boolean): void;
        public getSymbol(): TypeScript.PullSymbol;
        public hasSymbol(): boolean;
        public setSignatureSymbol(signature: TypeScript.PullSignatureSymbol): void;
        public getSignatureSymbol(): TypeScript.PullSignatureSymbol;
        public hasSignature(): boolean;
        public setSpecializingSignatureSymbol(signature: TypeScript.PullSignatureSymbol): void;
        public getSpecializingSignatureSymbol(): TypeScript.PullSignatureSymbol;
        public setFlags(flags: TypeScript.PullElementFlags): void;
        public setFlag(flags: TypeScript.PullElementFlags): void;
        public getSpan(): TypeScript.TextSpan;
        public setSpan(span: TypeScript.TextSpan): void;
        public getScriptName(): string;
        public setValueDecl(valDecl: PullDecl): void;
        public getValueDecl(): PullDecl;
        public isEqual(other: PullDecl): boolean;
        public getParentDecl(): PullDecl;
        public setParentDecl(parentDecl: PullDecl): void;
        public addDiagnostic(diagnostic: TypeScript.Diagnostic): void;
        public getDiagnostics(): TypeScript.Diagnostic[];
        public resetErrors(): void;
        private getChildDeclCache(declKind);
        public addChildDecl(childDecl: PullDecl): void;
        public searchChildDecls(declName: string, searchKind: TypeScript.PullElementKind): PullDecl[];
        public getChildDecls(): PullDecl[];
        public getTypeParameters(): any[];
        public addVariableDeclToGroup(decl: PullDecl): void;
        public getVariableDeclGroups(): PullDecl[][];
        public getParentPath(): PullDecl[];
        public setParentPath(path: PullDecl[]): void;
        public setIsBound(isBinding: boolean): void;
        public isBound(): boolean;
    }
    class PullFunctionExpressionDecl extends PullDecl {
        private functionExpressionName;
        constructor(expressionName: string, declFlags: TypeScript.PullElementFlags, span: TypeScript.TextSpan, scriptName: string);
        public getFunctionExpressionName(): string;
    }
    class PullDeclGroup {
        public name: string;
        private _decls;
        constructor(name: string);
        public addDecl(decl: PullDecl): void;
        public getDecls(): PullDecl[];
    }
}
declare module TypeScript {
    var pullSymbolID: number;
    var globalTyvarID: number;
    var sentinelEmptyArray: any[];
    class PullSymbol {
        public pullSymbolID: number;
        public pullSymbolIDString: string;
        public name: string;
        private cachedPathIDs;
        public kind: TypeScript.PullElementKind;
        private _container;
        public type: PullTypeSymbol;
        private _declarations;
        public isResolved: boolean;
        public isOptional: boolean;
        public inResolution: boolean;
        private isSynthesized;
        public isVarArg: boolean;
        private isSpecialized;
        public isBeingSpecialized: boolean;
        private rootSymbol;
        private _parentAccessorSymbol;
        private _enclosingSignature;
        public docComments: string;
        public isPrinting: boolean;
        public ast: TypeScript.AST;
        public isType(): boolean;
        public isSignature(): boolean;
        public isArray(): boolean;
        public isPrimitive(): boolean;
        public isAccessor(): boolean;
        public isError(): boolean;
        public isInterface(): boolean;
        public isMethod(): boolean;
        public isProperty(): boolean;
        public isAlias(): boolean;
        public isContainer(): boolean;
        constructor(name: string, declKind: TypeScript.PullElementKind);
        public setAccessorSymbol(accessor: PullSymbol): void;
        public getAccessorySymbol(): PullSymbol;
        private findAliasedType(decls);
        public getAliasedSymbol(scopeSymbol: PullSymbol): PullTypeAliasSymbol;
        public getScopedDynamicModuleAlias(scopeSymbol: PullSymbol): PullTypeAliasSymbol;
        public getName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public getDisplayName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public setIsSpecialized(): void;
        public getIsSpecialized(): boolean;
        public currentlyBeingSpecialized(): boolean;
        public setIsBeingSpecialized(): void;
        public setValueIsBeingSpecialized(val: boolean): void;
        public getRootSymbol(): PullSymbol;
        public setRootSymbol(symbol: PullSymbol): void;
        public setIsSynthesized(value?: boolean): void;
        public getIsSynthesized(): boolean;
        public setEnclosingSignature(signature: PullSignatureSymbol): void;
        public getEnclosingSignature(): PullSignatureSymbol;
        public addCacheID(cacheID: string): void;
        public invalidateCachedIDs(cache: any): void;
        public addDeclaration(decl: TypeScript.PullDecl): void;
        public getDeclarations(): TypeScript.PullDecl[];
        public setContainer(containerSymbol: PullTypeSymbol): void;
        public getContainer(): PullTypeSymbol;
        public setResolved(): void;
        public startResolving(): void;
        public setUnresolved(): void;
        public invalidate(): void;
        public hasFlag(flag: TypeScript.PullElementFlags): boolean;
        public allDeclsHaveFlag(flag: TypeScript.PullElementFlags): boolean;
        public pathToRoot(): PullSymbol[];
        public findCommonAncestorPath(b: PullSymbol): PullSymbol[];
        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public getNamePartForFullName(): string;
        public fullName(scopeSymbol?: PullSymbol): string;
        public getScopedName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public getScopedNameEx(scopeSymbol?: PullSymbol, useConstraintInName?: boolean, getPrettyTypeName?: boolean, getTypeParamMarkerInfo?: boolean): TypeScript.MemberName;
        public getTypeName(scopeSymbol?: PullSymbol, getPrettyTypeName?: boolean): string;
        public getTypeNameEx(scopeSymbol?: PullSymbol, getPrettyTypeName?: boolean): TypeScript.MemberName;
        private getTypeNameForFunctionSignature(prefix, scopeSymbol?, getPrettyTypeName?);
        public getNameAndTypeName(scopeSymbol?: PullSymbol): string;
        public getNameAndTypeNameEx(scopeSymbol?: PullSymbol): TypeScript.MemberName;
        static getTypeParameterString(typars: PullTypeSymbol[], scopeSymbol?: PullSymbol, useContraintInName?: boolean): string;
        static getTypeParameterStringEx(typeParameters: PullTypeSymbol[], scopeSymbol?: PullSymbol, getTypeParamMarkerInfo?: boolean, useContraintInName?: boolean): TypeScript.MemberNameArray;
        static getIsExternallyVisible(symbol: PullSymbol, fromIsExternallyVisibleSymbol: PullSymbol, inIsExternallyVisibleSymbols: PullSymbol[]): boolean;
        public isExternallyVisible(inIsExternallyVisibleSymbols?: PullSymbol[]): boolean;
    }
    class PullSignatureSymbol extends PullSymbol {
        public parameters: PullSymbol[];
        public typeParameters: PullTypeParameterSymbol[];
        public returnType: PullTypeSymbol;
        public functionType: PullTypeSymbol;
        public hasOptionalParam: boolean;
        public nonOptionalParamCount: number;
        public hasVarArgs: boolean;
        private specializationCache;
        private memberTypeParameterNameCache;
        public hasAGenericParameter: boolean;
        private stringConstantOverload;
        public hasBeenChecked: boolean;
        constructor(kind: TypeScript.PullElementKind);
        public isDefinition(): boolean;
        public isGeneric(): boolean;
        public addParameter(parameter: PullSymbol, isOptional?: boolean): void;
        public addSpecialization(signature: PullSignatureSymbol, typeArguments: PullTypeSymbol[]): void;
        public getSpecialization(typeArguments: PullTypeSymbol[]): PullSignatureSymbol;
        public addTypeParameter(typeParameter: PullTypeParameterSymbol): void;
        public getTypeParameters(): PullTypeParameterSymbol[];
        public findTypeParameter(name: string): PullTypeParameterSymbol;
        public mimicSignature(signature: PullSignatureSymbol, resolver: TypeScript.PullTypeResolver): void;
        public isFixed(): boolean;
        public invalidate(): void;
        public isStringConstantOverloadSignature(): boolean;
        static getSignatureTypeMemberName(candidateSignature: PullSignatureSymbol, signatures: PullSignatureSymbol[], scopeSymbol: PullSymbol): TypeScript.MemberNameArray;
        static getSignaturesTypeNameEx(signatures: PullSignatureSymbol[], prefix: string, shortform: boolean, brackets: boolean, scopeSymbol?: PullSymbol, getPrettyTypeName?: boolean, candidateSignature?: PullSignatureSymbol): TypeScript.MemberName[];
        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public getSignatureTypeNameEx(prefix: string, shortform: boolean, brackets: boolean, scopeSymbol?: PullSymbol, getParamMarkerInfo?: boolean, getTypeParamMarkerInfo?: boolean): TypeScript.MemberNameArray;
    }
    class PullTypeSymbol extends PullSymbol {
        private _members;
        private _enclosedMemberTypes;
        private _typeParameters;
        private _typeArguments;
        private _containedNonMembers;
        private _containedNonMemberTypes;
        private _specializedVersionsOfThisType;
        private _arrayVersionOfThisType;
        private _implementedTypes;
        private _extendedTypes;
        private _typesThatExplicitlyImplementThisType;
        private _typesThatExtendThisType;
        private _callSignatures;
        private _allCallSignatures;
        private _constructSignatures;
        private _allConstructSignatures;
        private _indexSignatures;
        private _allIndexSignatures;
        private _elementType;
        private _memberNameCache;
        private _enclosedTypeNameCache;
        private _typeParameterNameCache;
        private _containedNonMemberNameCache;
        private _containedNonMemberTypeNameCache;
        private _specializedTypeIDCache;
        private _hasGenericSignature;
        private _hasGenericMember;
        private _hasBaseTypeConflict;
        private _knownBaseTypeCount;
        private _invalidatedSpecializations;
        private _associatedContainerTypeSymbol;
        private _constructorMethod;
        private _hasDefaultConstructor;
        private _functionSymbol;
        public hasRecursiveSpecializationError: boolean;
        private inMemberTypeNameEx;
        public inSymbolPrivacyCheck: boolean;
        constructor(name: string, kind: TypeScript.PullElementKind);
        public isType(): boolean;
        public isClass(): boolean;
        public isFunction(): boolean;
        public isConstructor(): boolean;
        public isTypeParameter(): boolean;
        public isTypeVariable(): boolean;
        public isError(): boolean;
        public isEnum(): boolean;
        public getKnownBaseTypeCount(): number;
        public resetKnownBaseTypeCount(): void;
        public incrementKnownBaseCount(): void;
        public setHasBaseTypeConflict(): void;
        public hasBaseTypeConflict(): boolean;
        public setUnresolved(): void;
        public hasMembers(): boolean;
        public setHasGenericSignature(): void;
        public getHasGenericSignature(): boolean;
        public setHasGenericMember(): void;
        public getHasGenericMember(): boolean;
        public setAssociatedContainerType(type: PullTypeSymbol): void;
        public getAssociatedContainerType(): PullTypeSymbol;
        public getArrayType(): PullTypeSymbol;
        public getElementType(): PullTypeSymbol;
        public setElementType(type: PullTypeSymbol): void;
        public setArrayType(arrayType: PullTypeSymbol): void;
        public getFunctionSymbol(): PullSymbol;
        public setFunctionSymbol(symbol: PullSymbol): void;
        public addContainedNonMember(nonMember: PullSymbol): void;
        public findContainedNonMember(name: string): PullSymbol;
        public findContainedNonMemberType(typeName: string): PullTypeSymbol;
        public addMember(memberSymbol: PullSymbol): void;
        public addEnclosedMemberType(enclosedType: PullTypeSymbol): void;
        public addEnclosedNonMember(enclosedNonMember: PullSymbol): void;
        public addEnclosedNonMemberType(enclosedNonMemberType: PullTypeSymbol): void;
        public addTypeParameter(typeParameter: PullTypeParameterSymbol): void;
        public addConstructorTypeParameter(typeParameter: PullTypeParameterSymbol): void;
        public getMembers(): PullSymbol[];
        public setHasDefaultConstructor(hasOne?: boolean): void;
        public getHasDefaultConstructor(): boolean;
        public getConstructorMethod(): PullSymbol;
        public setConstructorMethod(constructorMethod: PullSymbol): void;
        public getTypeParameters(): PullTypeParameterSymbol[];
        public isGeneric(): boolean;
        public isFixed(): boolean;
        public addSpecialization(specializedVersionOfThisType: PullTypeSymbol, substitutingTypes: PullTypeSymbol[]): void;
        public getSpecialization(substitutingTypes: PullTypeSymbol[]): PullTypeSymbol;
        public getKnownSpecializations(): PullTypeSymbol[];
        public getTypeArguments(): PullTypeSymbol[];
        public setTypeArguments(typeArgs: PullTypeSymbol[]): void;
        public addCallSignature(callSignature: PullSignatureSymbol): void;
        public addConstructSignature(constructSignature: PullSignatureSymbol): void;
        public addIndexSignature(indexSignature: PullSignatureSymbol): void;
        public hasOwnCallSignatures(): boolean;
        public getCallSignatures(collectBaseSignatures?: boolean): PullSignatureSymbol[];
        public hasOwnConstructSignatures(): boolean;
        public getConstructSignatures(collectBaseSignatures?: boolean): PullSignatureSymbol[];
        public hasOwnIndexSignatures(): boolean;
        public getIndexSignatures(collectBaseSignatures?: boolean): PullSignatureSymbol[];
        public addImplementedType(implementedType: PullTypeSymbol): void;
        public getImplementedTypes(): PullTypeSymbol[];
        public addExtendedType(extendedType: PullTypeSymbol): void;
        public getExtendedTypes(): PullTypeSymbol[];
        public addTypeThatExtendsThisType(type: PullTypeSymbol): void;
        public getTypesThatExtendThisType(): PullTypeSymbol[];
        public addTypeThatExplicitlyImplementsThisType(type: PullTypeSymbol): void;
        public getTypesThatExplicitlyImplementThisType(): PullTypeSymbol[];
        public hasBase(potentialBase: PullTypeSymbol, origin?: PullSymbol): boolean;
        public isValidBaseKind(baseType: PullTypeSymbol, isExtendedType: boolean): boolean;
        public findMember(name: string, lookInParent?: boolean): PullSymbol;
        public findNestedType(name: string, kind?: TypeScript.PullElementKind): PullTypeSymbol;
        public getAllMembers(searchDeclKind: TypeScript.PullElementKind, includePrivate: boolean): PullSymbol[];
        public findTypeParameter(name: string): PullTypeParameterSymbol;
        public setResolved(): void;
        public invalidate(): void;
        public getNamePartForFullName(): string;
        public getScopedName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public isNamedTypeSymbol(): boolean;
        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public getScopedNameEx(scopeSymbol?: PullSymbol, useConstraintInName?: boolean, getPrettyTypeName?: boolean, getTypeParamMarkerInfo?: boolean): TypeScript.MemberName;
        public hasOnlyOverloadCallSignatures(): boolean;
        private getMemberTypeNameEx(topLevel, scopeSymbol?, getPrettyTypeName?);
        public isExternallyVisible(inIsExternallyVisibleSymbols?: PullSymbol[]): boolean;
    }
    class PullPrimitiveTypeSymbol extends PullTypeSymbol {
        constructor(name: string);
        public isStringConstant(): boolean;
        public isFixed(): boolean;
        public invalidate(): void;
    }
    class PullStringConstantTypeSymbol extends PullPrimitiveTypeSymbol {
        constructor(name: string);
        public isStringConstant(): boolean;
    }
    class PullErrorTypeSymbol extends PullPrimitiveTypeSymbol {
        private diagnostic;
        public delegateType: PullTypeSymbol;
        private _data;
        constructor(diagnostic: TypeScript.Diagnostic, delegateType: PullTypeSymbol, _data?: any);
        public isError(): boolean;
        public getDiagnostic(): TypeScript.Diagnostic;
        public getName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public getDisplayName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public toString(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public setData(data: any): void;
        public getData(): any;
    }
    class PullContainerTypeSymbol extends PullTypeSymbol {
        public instanceSymbol: PullSymbol;
        private assignedValue;
        private assignedType;
        private assignedContainer;
        constructor(name: string, kind?: TypeScript.PullElementKind);
        public isContainer(): boolean;
        public setInstanceSymbol(symbol: PullSymbol): void;
        public getInstanceSymbol(): PullSymbol;
        public invalidate(): void;
        public setExportAssignedValueSymbol(symbol: PullSymbol): void;
        public getExportAssignedValueSymbol(): PullSymbol;
        public setExportAssignedTypeSymbol(type: PullTypeSymbol): void;
        public getExportAssignedTypeSymbol(): PullTypeSymbol;
        public setExportAssignedContainerSymbol(container: PullContainerTypeSymbol): void;
        public getExportAssignedContainerSymbol(): PullContainerTypeSymbol;
        public resetExportAssignedSymbols(): void;
        static usedAsSymbol(containerSymbol: PullSymbol, symbol: PullSymbol): boolean;
        public getInstanceType(): PullTypeSymbol;
    }
    class PullTypeAliasSymbol extends PullTypeSymbol {
        public assignedValue: PullSymbol;
        public assignedType: PullTypeSymbol;
        public assignedContainer: PullContainerTypeSymbol;
        public isUsedAsValue: boolean;
        public typeUsedExternally: boolean;
        private retrievingExportAssignment;
        constructor(name: string);
        public isAlias(): boolean;
        public isContainer(): boolean;
        public setAssignedValueSymbol(symbol: PullSymbol): void;
        public getExportAssignedValueSymbol(): PullSymbol;
        public setAssignedTypeSymbol(type: PullTypeSymbol): void;
        public getExportAssignedTypeSymbol(): PullTypeSymbol;
        public setAssignedContainerSymbol(container: PullContainerTypeSymbol): void;
        public getExportAssignedContainerSymbol(): PullContainerTypeSymbol;
        public getMembers(): PullSymbol[];
        public getCallSignatures(): PullSignatureSymbol[];
        public getConstructSignatures(): PullSignatureSymbol[];
        public getIndexSignatures(): PullSignatureSymbol[];
        public findMember(name: string): PullSymbol;
        public findNestedType(name: string): PullTypeSymbol;
        public getAllMembers(searchDeclKind: TypeScript.PullElementKind, includePrivate: boolean): PullSymbol[];
        public invalidate(): void;
    }
    class PullDefinitionSignatureSymbol extends PullSignatureSymbol {
        public isDefinition(): boolean;
    }
    class PullTypeParameterSymbol extends PullTypeSymbol {
        private _isFunctionTypeParameter;
        private _constraint;
        constructor(name: string, _isFunctionTypeParameter: boolean);
        public isTypeParameter(): boolean;
        public isFunctionTypeParameter(): boolean;
        public isFixed(): boolean;
        public setConstraint(constraintType: PullTypeSymbol): void;
        public getConstraint(): PullTypeSymbol;
        public isGeneric(): boolean;
        public fullName(scopeSymbol?: PullSymbol): string;
        public getName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public getDisplayName(scopeSymbol?: PullSymbol, useConstraintInName?: boolean): string;
        public isExternallyVisible(inIsExternallyVisibleSymbols?: PullSymbol[]): boolean;
    }
    class PullTypeVariableSymbol extends PullTypeParameterSymbol {
        constructor(name: string, isFunctionTypeParameter: boolean);
        private tyvarID;
        public isTypeParameter(): boolean;
        public isTypeVariable(): boolean;
    }
    class PullAccessorSymbol extends PullSymbol {
        private _getterSymbol;
        private _setterSymbol;
        constructor(name: string);
        public isAccessor(): boolean;
        public setSetter(setter: PullSymbol): void;
        public getSetter(): PullSymbol;
        public setGetter(getter: PullSymbol): void;
        public getGetter(): PullSymbol;
        public invalidate(): void;
    }
    function typeWrapsTypeParameter(type: PullTypeSymbol, typeParameter: PullTypeParameterSymbol): boolean;
    function getRootType(typeToSpecialize: PullTypeSymbol): PullTypeSymbol;
    var nSpecializationsCreated: number;
    var nSpecializedSignaturesCreated: number;
    function shouldSpecializeTypeParameterForTypeParameter(specialization: PullTypeParameterSymbol, typeToSpecialize: PullTypeParameterSymbol): boolean;
    function specializeType(typeToSpecialize: PullTypeSymbol, typeArguments: PullTypeSymbol[], resolver: PullTypeResolver, enclosingDecl: PullDecl, context: PullTypeResolutionContext, ast?: AST): PullTypeSymbol;
    function specializeSignature(signature: PullSignatureSymbol, skipLocalTypeParameters: boolean, typeReplacementMap: any, typeArguments: PullTypeSymbol[], resolver: PullTypeResolver, enclosingDecl: PullDecl, context: PullTypeResolutionContext, ast?: AST): PullSignatureSymbol;
    function getIDForTypeSubstitutions(types: PullTypeSymbol[]): string;
}
declare module TypeScript {
    class PullSymbolBindingContext {
        public semanticInfoChain: TypeScript.SemanticInfoChain;
        public scriptName: string;
        private parentChain;
        private declPath;
        public semanticInfo: TypeScript.SemanticInfo;
        public reBindingAfterChange: boolean;
        public startingDeclForRebind: number;
        constructor(semanticInfoChain: TypeScript.SemanticInfoChain, scriptName: string);
        public getParent(n?: number): TypeScript.PullTypeSymbol;
        public getDeclPath(): string[];
        public pushParent(parentDecl: TypeScript.PullTypeSymbol): void;
        public popParent(): void;
    }
    var time_in_findSymbol: number;
}
declare module TypeScript {
    class CandidateInferenceInfo {
        public typeParameter: TypeScript.PullTypeParameterSymbol;
        public isFixed: boolean;
        public inferenceCandidates: TypeScript.PullTypeSymbol[];
        public addCandidate(candidate: TypeScript.PullTypeSymbol): void;
    }
    class ArgumentInferenceContext {
        public inferenceCache: any;
        public candidateCache: any;
        public alreadyRelatingTypes(objectType: TypeScript.PullTypeSymbol, parameterType: TypeScript.PullTypeSymbol): boolean;
        public resetRelationshipCache(): void;
        public addInferenceRoot(param: TypeScript.PullTypeParameterSymbol): void;
        public getInferenceInfo(param: TypeScript.PullTypeParameterSymbol): CandidateInferenceInfo;
        public addCandidateForInference(param: TypeScript.PullTypeParameterSymbol, candidate: TypeScript.PullTypeSymbol, fix: boolean): void;
        public getInferenceCandidates(): any[];
        public inferArgumentTypes(resolver: TypeScript.PullTypeResolver, context: PullTypeResolutionContext): {
            results: {
                param: TypeScript.PullTypeParameterSymbol;
                type: TypeScript.PullTypeSymbol;
            }[];
            unfit: boolean;
        };
    }
    class PullContextualTypeContext {
        public contextualType: TypeScript.PullTypeSymbol;
        public provisional: boolean;
        public substitutions: any;
        public provisionallyTypedSymbols: TypeScript.PullSymbol[];
        public provisionalDiagnostic: TypeScript.Diagnostic[];
        constructor(contextualType: TypeScript.PullTypeSymbol, provisional: boolean, substitutions: any);
        public recordProvisionallyTypedSymbol(symbol: TypeScript.PullSymbol): void;
        public invalidateProvisionallyTypedSymbols(): void;
        public postDiagnostic(error: TypeScript.Diagnostic): void;
        public hadProvisionalErrors(): boolean;
    }
    class PullTypeResolutionContext {
        public inTypeCheck: boolean;
        private contextStack;
        private typeSpecializationStack;
        private genericASTResolutionStack;
        public resolvingTypeReference: boolean;
        public resolvingNamespaceMemberAccess: boolean;
        public resolveAggressively: boolean;
        public canUseTypeSymbol: boolean;
        public specializingToAny: boolean;
        public specializingToObject: boolean;
        public isResolvingClassExtendedType: boolean;
        public isSpecializingSignatureAtCallSite: boolean;
        public isSpecializingConstructorMethod: boolean;
        public isComparingSpecializedSignatures: boolean;
        public isResolvingSuperConstructorTarget: boolean;
        public inConstructorArguments: boolean;
        public inImportDeclaration: boolean;
        public isInStaticInitializer: boolean;
        public isInInvocationExpression: boolean;
        public resolvingTypeNameAsNameExpression: boolean;
        constructor(inTypeCheck?: boolean);
        public pushContextualType(type: TypeScript.PullTypeSymbol, provisional: boolean, substitutions: any): void;
        public popContextualType(): PullContextualTypeContext;
        public findSubstitution(type: TypeScript.PullTypeSymbol): TypeScript.PullTypeSymbol;
        public getContextualType(): TypeScript.PullTypeSymbol;
        public inProvisionalResolution(): boolean;
        public inSpecialization: boolean;
        public suppressErrors: boolean;
        private inBaseTypeResolution;
        public isInBaseTypeResolution(): boolean;
        public startBaseTypeResolution(): boolean;
        public doneBaseTypeResolution(wasInBaseTypeResolution: boolean): void;
        public setTypeInContext(symbol: TypeScript.PullSymbol, type: TypeScript.PullTypeSymbol): void;
        public pushTypeSpecializationCache(cache: any): void;
        public popTypeSpecializationCache(): void;
        public findSpecializationForType(type: TypeScript.PullTypeSymbol): TypeScript.PullTypeSymbol;
        public postError(fileName: string, offset: number, length: number, diagnosticKey: string, arguments: any[], enclosingDecl: TypeScript.PullDecl, post?: boolean): TypeScript.Diagnostic;
        public postDiagnostic(diagnostic: TypeScript.Diagnostic, enclosingDecl: TypeScript.PullDecl): void;
        public typeCheck(): boolean;
        public startResolvingTypeArguments(ast: TypeScript.AST): void;
        public isResolvingTypeArguments(ast: TypeScript.AST): boolean;
        public doneResolvingTypeArguments(): void;
    }
}
declare module TypeScript {
    interface IPullTypeCollection {
        getLength(): number;
        setTypeAtIndex(index: number, type: TypeScript.PullTypeSymbol): void;
        getTypeAtIndex(index: number): TypeScript.PullTypeSymbol;
    }
    interface IPullResolutionData {
        actuals: TypeScript.PullTypeSymbol[];
        exactCandidates: TypeScript.PullSignatureSymbol[];
        conversionCandidates: TypeScript.PullSignatureSymbol[];
        id: number;
    }
    class PullResolutionDataCache {
        private cacheSize;
        private rdCache;
        private nextUp;
        constructor();
        public getResolutionData(): IPullResolutionData;
        public returnResolutionData(rd: IPullResolutionData): void;
    }
    interface PullApplicableSignature {
        signature: TypeScript.PullSignatureSymbol;
        hadProvisionalErrors: boolean;
    }
    class PullAdditionalCallResolutionData {
        public targetSymbol: TypeScript.PullSymbol;
        public targetTypeSymbol: TypeScript.PullTypeSymbol;
        public resolvedSignatures: TypeScript.PullSignatureSymbol[];
        public candidateSignature: TypeScript.PullSignatureSymbol;
        public actualParametersContextTypeSymbols: TypeScript.PullTypeSymbol[];
    }
    class PullAdditionalObjectLiteralResolutionData {
        public membersContextTypeSymbols: TypeScript.PullTypeSymbol[];
    }
    class PullTypeResolver {
        private compilationSettings;
        public semanticInfoChain: TypeScript.SemanticInfoChain;
        private unitPath;
        private _cachedArrayInterfaceType;
        private _cachedNumberInterfaceType;
        private _cachedStringInterfaceType;
        private _cachedBooleanInterfaceType;
        private _cachedObjectInterfaceType;
        private _cachedFunctionInterfaceType;
        private _cachedIArgumentsInterfaceType;
        private _cachedRegExpInterfaceType;
        static typeCheckCallBacks: {
            (): void;
        }[];
        private cachedFunctionArgumentsSymbol;
        private seenSuperConstructorCall;
        private assignableCache;
        private subtypeCache;
        private identicalCache;
        private resolutionDataCache;
        private currentUnit;
        public cleanCachedGlobals(): void;
        private cachedArrayInterfaceType();
        public getCachedArrayType(): TypeScript.PullTypeSymbol;
        private cachedNumberInterfaceType();
        private cachedStringInterfaceType();
        private cachedBooleanInterfaceType();
        private cachedObjectInterfaceType();
        private cachedFunctionInterfaceType();
        private cachedIArgumentsInterfaceType();
        private cachedRegExpInterfaceType();
        constructor(compilationSettings: TypeScript.CompilationSettings, semanticInfoChain: TypeScript.SemanticInfoChain, unitPath: string);
        public getUnitPath(): string;
        public setUnitPath(unitPath: string): void;
        public getDeclForAST(ast: TypeScript.AST): TypeScript.PullDecl;
        public getSymbolForAST(ast: TypeScript.IAST): TypeScript.PullSymbol;
        private setSymbolForAST(ast, symbol, context);
        public getASTForSymbol(symbol: TypeScript.PullSymbol): TypeScript.AST;
        public getASTForDecl(decl: TypeScript.PullDecl): TypeScript.AST;
        public getNewErrorTypeSymbol(diagnostic: TypeScript.Diagnostic, data?: any): TypeScript.PullErrorTypeSymbol;
        public getEnclosingDecl(decl: TypeScript.PullDecl): TypeScript.PullDecl;
        private getExportedMemberSymbol(symbol, parent);
        private getMemberSymbol(symbolName, declSearchKind, parent);
        private getSymbolFromDeclPath(symbolName, declPath, declSearchKind);
        private getVisibleDeclsFromDeclPath(declPath, declSearchKind);
        private addFilteredDecls(decls, declSearchKind, result);
        public getVisibleDecls(enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullDecl[];
        public getVisibleContextSymbols(enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullSymbol[];
        public getVisibleMembersFromExpression(expression: TypeScript.AST, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullSymbol[];
        public isAnyOrEquivalent(type: TypeScript.PullTypeSymbol): boolean;
        public isNumberOrEquivalent(type: TypeScript.PullTypeSymbol): boolean;
        public isTypeArgumentOrWrapper(type: TypeScript.PullTypeSymbol);
        public isArrayOrEquivalent(type: TypeScript.PullTypeSymbol);
        private lastExternalModulePath;
        private findTypeSymbolForDynamicModule(idText, currentFileName, search);
        public resolveDeclaredSymbol(symbol: TypeScript.PullSymbol, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullSymbol;
        private resolveDeclaredSymbolWorker(symbol, enclosingDecl, context);
        private resolveModuleDeclaration(ast, context);
        public isTypeRefWithoutTypeArgs(typeRef: TypeScript.TypeReference): boolean;
        private resolveReferenceTypeDeclaration(typeDeclAST, context);
        private resolveClassDeclaration(classDeclAST, context);
        private resolveInterfaceDeclaration(interfaceDeclAST, context);
        private filterSymbol(symbol, kind);
        private getMemberSymbolOfKind(symbolName, kind, pullTypeSymbol);
        private resolveIdentifierOfInternalModuleReference(importDecl, identifier, moduleSymbol, enclosingDecl, context);
        private resolveModuleReference(importDecl, moduleNameExpr, context, declPath);
        private resolveInternalModuleReference(importStatementAST, context);
        private resolveImportDeclaration(importStatementAST, context);
        public resolveExportAssignmentStatement(exportAssignmentAST: TypeScript.ExportAssignment, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullSymbol;
        public resolveFunctionTypeSignature(funcDeclAST: TypeScript.FunctionDeclaration, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullTypeSymbol;
        private resolveFunctionTypeSignatureParameter(argDeclAST, signature, enclosingDecl, context);
        private resolveFunctionExpressionParameter(argDeclAST, contextParam, enclosingDecl, context);
        public resolveInterfaceTypeReference(interfaceDeclAST: TypeScript.InterfaceDeclaration, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullTypeSymbol;
        public resolveTypeReference(typeRef: TypeScript.TypeReference, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullTypeSymbol;
        private computeTypeReferenceSymbol(typeRef, enclosingDecl, context);
        private genericTypeIsUsedWithoutRequiredTypeArguments(typeSymbol, typeReference, context);
        private resolveVariableDeclaration(varDecl, context, enclosingDecl?);
        private resolveTypeParameterDeclaration(typeParameterAST, context);
        private resolveFunctionBodyReturnTypes(funcDeclAST, signature, useContextualType, enclosingDecl, context);
        private resolveFunctionDeclaration(funcDeclAST, context);
        private resolveGetAccessorDeclaration(funcDeclAST, context);
        private resolveSetAccessorDeclaration(funcDeclAST, context);
        private resolveList(list, enclosingDecl, context);
        private resolveVoidExpression(ast, enclosingDecl, context);
        private resolveLogicalOperation(ast, enclosingDecl, context);
        private resolveUnaryLogicalOperation(ast, enclosingDecl, context);
        private resolveUnaryArithmeticOperation(ast, enclosingDecl, context);
        private resolveBinaryArithmeticExpression(ast, enclosingDecl, context);
        private resolveTypeOfExpression(ast, enclosingDecl, context);
        private resolveThrowStatement(ast, enclosingDecl, context);
        private resolveDeleteStatement(ast, enclosingDecl, context);
        private resolveInstanceOfExpression(ast, enclosingDecl, context);
        private resolveCommaExpression(ast, enclosingDecl, context);
        private resolveInExpression(ast, enclosingDecl, context);
        private resolveForStatement(ast, enclosingDecl, context);
        private resolveForInStatement(ast, enclosingDecl, context);
        private resolveWhileStatement(ast, enclosingDecl, context);
        private resolveDoStatement(ast, enclosingDecl, context);
        private resolveIfStatement(ast, enclosingDecl, context);
        private resolveBlock(ast, enclosingDecl, context);
        private resolveVariableStatement(ast, enclosingDecl, context);
        private resolveVariableDeclarationList(ast, enclosingDecl, context);
        private resolveWithStatement(ast, enclosingDecl, context);
        private resolveTryStatement(ast, enclosingDecl, context);
        private resolveCatchClause(ast, enclosingDecl, context);
        private resolveReturnStatement(ast, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveSwitchStatement(ast, enclosingDecl, context);
        private resolveCaseClause(ast, enclosingDecl, context);
        private resolveLabeledStatement(ast, enclosingDecl, context);
        public resolveAST(ast: TypeScript.AST, inContextuallyTypedAssignment: boolean, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext, specializingSignature?: boolean): TypeScript.PullSymbol;
        private resolveRegularExpressionLiteral();
        private isNameOrMemberAccessExpression(ast);
        private resolveNameSymbol(nameSymbol, context);
        public resolveNameExpression(nameAST: TypeScript.Identifier, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullSymbol;
        private computeNameExpression(nameAST, enclosingDecl, context);
        public resolveDottedNameExpression(dottedNameAST: TypeScript.BinaryExpression, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullSymbol;
        public isPrototypeMember(dottedNameAST: TypeScript.BinaryExpression, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): boolean;
        private computeDottedNameExpressionSymbol(dottedNameAST, enclosingDecl, context);
        public resolveTypeNameExpression(nameAST: TypeScript.Identifier, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullTypeSymbol;
        private computeTypeNameExpression(nameAST, enclosingDecl, context);
        private resolveGenericTypeReference(genericTypeAST, enclosingDecl, context);
        private resolveDottedTypeNameExpression(dottedNameAST, enclosingDecl, context);
        private computeDottedTypeNameExpression(dottedNameAST, enclosingDecl, context);
        private resolveFunctionExpression(funcDeclAST, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveThisExpression(ast, enclosingDecl, context);
        private computeThisExpressionSymbol(ast, enclosingDecl, context);
        private getEnclosingNonLambdaDecl(enclosingDecl);
        private resolveSuperExpression(ast, enclosingDecl, context);
        public resolveObjectLiteralExpression(expressionAST: TypeScript.AST, inContextuallyTypedAssignment: boolean, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext, additionalResults?: PullAdditionalObjectLiteralResolutionData): TypeScript.PullSymbol;
        private computeObjectLiteralExpression(expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults?);
        private resolveArrayLiteralExpression(arrayLit, inContextuallyTypedAssignment, enclosingDecl, context);
        private computeArrayLiteralExpressionSymbol(arrayLit, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveIndexExpression(callEx, inContextuallyTypedAssignment, enclosingDecl, context);
        private computeIndexExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveBitwiseOperator(expressionAST, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveBinaryAdditionOperation(binaryExpression, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveLogicalOrExpression(binex, inContextuallyTypedAssignment, enclosingDecl, context);
        private computeLogicalOrExpressionSymbol(binex, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveLogicalAndExpression(binex, inContextuallyTypedAssignment, enclosingDecl, context);
        private resolveConditionalExpression(trinex, enclosingDecl, context);
        private computeConditionalExpressionSymbol(trinex, enclosingDecl, context);
        private resolveParenthesizedExpression(ast, enclosingDecl, context);
        private resolveExpressionStatement(ast, inContextuallyTypedAssignment, enclosingDecl, context);
        public resolveInvocationExpression(callEx: TypeScript.InvocationExpression, inContextuallyTypedAssignment: boolean, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): TypeScript.PullSymbol;
        public computeInvocationExpressionSymbol(callEx: TypeScript.InvocationExpression, inContextuallyTypedAssignment: boolean, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): TypeScript.PullSymbol;
        public resolveObjectCreationExpression(callEx: TypeScript.ObjectCreationExpression, inContextuallyTypedAssignment: boolean, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): TypeScript.PullSymbol;
        public computeObjectCreationExpressionSymbol(callEx: TypeScript.ObjectCreationExpression, inContextuallyTypedAssignment: boolean, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext, additionalResults?: PullAdditionalCallResolutionData): TypeScript.PullSymbol;
        public resolveTypeAssertionExpression(assertionExpression: TypeScript.UnaryExpression, inContextuallyTypedAssignment: boolean, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullTypeSymbol;
        private resolveAssignmentStatement(binaryExpression, inContextuallyTypedAssignment, enclosingDecl, context);
        private computeAssignmentStatementSymbol(binex, inContextuallyTypedAssignment, enclosingDecl, context);
        private getInstanceTypeForAssignment(lhs, type, enclosingDecl, context);
        public resolveBoundDecls(decl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): void;
        private mergeOrdered(a, b, context, comparisonInfo?);
        public widenType(type: TypeScript.PullTypeSymbol): TypeScript.PullTypeSymbol;
        private isNullOrUndefinedType(type);
        private canApplyContextualType(type);
        public findBestCommonType(initialType: TypeScript.PullTypeSymbol, targetType: TypeScript.PullTypeSymbol, collection: IPullTypeCollection, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): TypeScript.PullTypeSymbol;
        public typesAreIdentical(t1: TypeScript.PullTypeSymbol, t2: TypeScript.PullTypeSymbol, val?: TypeScript.AST);
        private signatureGroupsAreIdentical(sg1, sg2);
        public signaturesAreIdentical(s1: TypeScript.PullSignatureSymbol, s2: TypeScript.PullSignatureSymbol, includingReturnType?: boolean): boolean;
        public substituteUpperBoundForType(type: TypeScript.PullTypeSymbol);
        private symbolsShareDeclaration(symbol1, symbol2);
        private sourceExtendsTarget(source, target, context);
        public sourceIsSubtypeOfTarget(source: TypeScript.PullTypeSymbol, target: TypeScript.PullTypeSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        public sourceMembersAreSubtypeOfTargetMembers(source: TypeScript.PullTypeSymbol, target: TypeScript.PullTypeSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        public sourcePropertyIsSubtypeOfTargetProperty(source: TypeScript.PullTypeSymbol, target: TypeScript.PullTypeSymbol, sourceProp: TypeScript.PullSymbol, targetProp: TypeScript.PullSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        public sourceCallSignaturesAreSubtypeOfTargetCallSignatures(source: TypeScript.PullTypeSymbol, target: TypeScript.PullTypeSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        public sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(source: TypeScript.PullTypeSymbol, target: TypeScript.PullTypeSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        public sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(source: TypeScript.PullTypeSymbol, target: TypeScript.PullTypeSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        public typeIsSubtypeOfFunction(source: TypeScript.PullTypeSymbol, context: TypeScript.PullTypeResolutionContext): boolean;
        private signatureGroupIsSubtypeOfTarget(sg1, sg2, context, comparisonInfo?);
        public signatureIsSubtypeOfTarget(s1: TypeScript.PullSignatureSymbol, s2: TypeScript.PullSignatureSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        public sourceIsAssignableToTarget(source: TypeScript.PullTypeSymbol, target: TypeScript.PullTypeSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo, isInProvisionalResolution?: boolean): boolean;
        private signatureGroupIsAssignableToTarget(sg1, sg2, context, comparisonInfo?);
        public signatureIsAssignableToTarget(s1: TypeScript.PullSignatureSymbol, s2: TypeScript.PullSignatureSymbol, context: TypeScript.PullTypeResolutionContext, comparisonInfo?: TypeComparisonInfo): boolean;
        private sourceIsRelatableToTarget(source, target, assignableTo, comparisonCache, context, comparisonInfo);
        private sourceMembersAreRelatableToTargetMembers(source, target, assignableTo, comparisonCache, context, comparisonInfo);
        private sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo);
        private sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, assignableTo, comparisonCache, context, comparisonInfo);
        private sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, assignableTo, comparisonCache, context, comparisonInfo);
        private sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, assignableTo, comparisonCache, context, comparisonInfo);
        private signatureGroupIsRelatableToTarget(sourceSG, targetSG, assignableTo, comparisonCache, context, comparisonInfo?);
        private signatureIsRelatableToTarget(sourceSig, targetSig, assignableTo, comparisonCache, context, comparisonInfo?);
        private resolveOverloads(application, group, enclosingDecl, haveTypeArgumentsAtCallSite, context, diagnostics);
        private getLastIdentifierInTarget(callEx);
        private getCandidateSignatures(signature, actuals, args, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo);
        private getApplicableSignaturesFromCandidates(candidateSignatures, args, comparisonInfo, enclosingDecl, context);
        private findMostApplicableSignature(signatures, args, enclosingDecl, context);
        private canApplyContextualTypeToFunction(candidateType, funcDecl, beStringent);
        private inferArgumentTypesForSignature(signature, args, comparisonInfo, enclosingDecl, context);
        private relateTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        private relateFunctionSignatureToTypeParameters(expressionSignature, parameterSignature, argContext, enclosingDecl, context);
        private relateObjectTypeToTypeParameters(objectType, parameterType, shouldFix, argContext, enclosingDecl, context);
        private relateArrayTypeToTypeParameters(argArrayType, parameterArrayType, shouldFix, argContext, enclosingDecl, context);
        public specializeTypeToAny(typeToSpecialize: TypeScript.PullTypeSymbol, enclosingDecl: TypeScript.PullDecl, context: TypeScript.PullTypeResolutionContext): TypeScript.PullTypeSymbol;
        private specializeSignatureToAny(signatureToSpecialize, enclosingDecl, context);
        static globalTypeCheckPhase: number;
        static typeCheck(compilationSettings: TypeScript.CompilationSettings, semanticInfoChain: TypeScript.SemanticInfoChain, scriptName: string, script: TypeScript.Script): void;
        private validateVariableDeclarationGroups(enclosingDecl, context);
        private typeCheckFunctionOverloads(funcDecl, context, signature?, allSignatures?);
        private checkSymbolPrivacy(declSymbol, symbol, context, privacyErrorReporter);
        private checkTypePrivacyOfSignatures(declSymbol, signatures, context, privacyErrorReporter);
        private baseListPrivacyErrorReporter(declAST, declSymbol, baseAst, isExtendedType, symbol, context);
        private variablePrivacyErrorReporter(declSymbol, symbol, context);
        private checkFunctionTypePrivacy(funcDeclAST, inContextuallyTypedAssignment, context);
        private functionArgumentTypePrivacyErrorReporter(declAST, argIndex, paramSymbol, symbol, context);
        private functionReturnTypePrivacyErrorReporter(declAST, funcReturnType, symbol, context);
        public enclosingClassIsDerived(decl: TypeScript.PullDecl): boolean;
        private isSuperCallNode(node);
        private getFirstStatementFromFunctionDeclAST(funcDeclAST);
        private superCallMustBeFirstStatementInConstructor(enclosingConstructor, enclosingClass);
        private checkForThisOrSuperCaptureInArrowFunction(expression, enclosingDecl);
        private typeCheckMembersAgainstIndexer(containerType, containerTypeDecl, context);
        private checkThatMemberIsSubtypeOfIndexer(member, indexSignature, astForError, context, enclosingDecl, isNumeric);
        private typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMember, extendedTypeMember, enclosingDecl, comparisonInfo);
        private typeCheckIfTypeExtendsType(typeDecl, typeSymbol, extendedType, enclosingDecl, context);
        private typeCheckIfClassImplementsType(classDecl, classSymbol, implementedType, enclosingDecl, context);
        private hasClassTypeSymbolConflictAsValue(valueDeclAST, typeSymbol, enclosingDecl, context);
        private typeCheckBase(typeDeclAst, typeSymbol, baseDeclAST, isExtendedType, enclosingDecl, context);
        private typeCheckBases(typeDeclAst, typeSymbol, enclosingDecl, context);
        private checkAssignability(ast, source, target, enclosingDecl, context);
        private isValidLHS(ast, expressionSymbol);
        private checkForSuperMemberAccess(memberAccessExpression, resolvedName, enclosingDecl, context);
        private checkForPrivateMemberAccess(memberAccessExpression, expressionType, resolvedName, enclosingDecl, context);
        private checkForStaticMemberAccess(memberAccessExpression, expressionType, resolvedName, enclosingDecl, context);
    }
    class TypeComparisonInfo {
        public onlyCaptureFirstError: boolean;
        public flags: TypeScript.TypeRelationshipFlags;
        public message: string;
        public stringConstantVal: TypeScript.AST;
        private indent;
        constructor(sourceComparisonInfo?: TypeComparisonInfo);
        private indentString();
        public addMessage(message: string): void;
        public setMessage(message: string): void;
    }
}
declare module TypeScript {
    var declCacheHit: number;
    var declCacheMiss: number;
    var symbolCacheHit: number;
    var symbolCacheMiss: number;
    class SemanticInfo {
        private compilationUnitPath;
        private topLevelDecls;
        private topLevelSynthesizedDecls;
        private declASTMap;
        private astDeclMap;
        private astSymbolMap;
        private astAliasSymbolMap;
        private symbolASTMap;
        private astCallResolutionDataMap;
        private syntaxElementSymbolMap;
        private symbolSyntaxElementMap;
        private hasBeenTypeChecked;
        constructor(compilationUnitPath: string);
        public addTopLevelDecl(decl: TypeScript.PullDecl): void;
        public setTypeChecked(shouldTC?: boolean): void;
        public getTypeChecked(): boolean;
        public invalidate(): void;
        public getTopLevelDecls(): TypeScript.PullDecl[];
        public getPath(): string;
        public addSynthesizedDecl(decl: TypeScript.PullDecl): void;
        public getSynthesizedDecls(): TypeScript.PullDecl[];
        public cleanSynthesizedDecls(): void;
        public getDeclForAST(ast: TypeScript.AST): TypeScript.PullDecl;
        public setDeclForAST(ast: TypeScript.AST, decl: TypeScript.PullDecl): void;
        public getASTForDecl(decl: TypeScript.PullDecl): TypeScript.AST;
        public setASTForDecl(decl: TypeScript.PullDecl, ast: TypeScript.AST): void;
        public setSymbolForAST(ast: TypeScript.AST, symbol: TypeScript.PullSymbol): void;
        public getSymbolForAST(ast: TypeScript.IAST): TypeScript.PullSymbol;
        public getASTForSymbol(symbol: TypeScript.PullSymbol): TypeScript.AST;
        public setAliasSymbolForAST(ast: TypeScript.AST, symbol: TypeScript.PullTypeAliasSymbol): void;
        public getAliasSymbolForAST(ast: TypeScript.IAST): TypeScript.PullTypeAliasSymbol;
        public getCallResolutionDataForAST(ast: TypeScript.AST): TypeScript.PullAdditionalCallResolutionData;
        public setCallResolutionDataForAST(ast: TypeScript.AST, callResolutionData: TypeScript.PullAdditionalCallResolutionData): void;
        public getDiagnostics(semanticErrors: TypeScript.Diagnostic[]): void;
    }
    class SemanticInfoChain {
        public units: SemanticInfo[];
        private declCache;
        private symbolCache;
        private unitCache;
        private topLevelDecls;
        public anyTypeSymbol: TypeScript.PullTypeSymbol;
        public booleanTypeSymbol: TypeScript.PullTypeSymbol;
        public numberTypeSymbol: TypeScript.PullTypeSymbol;
        public stringTypeSymbol: TypeScript.PullTypeSymbol;
        public nullTypeSymbol: TypeScript.PullTypeSymbol;
        public undefinedTypeSymbol: TypeScript.PullTypeSymbol;
        public voidTypeSymbol: TypeScript.PullTypeSymbol;
        public addPrimitiveType(name: string, globalDecl: TypeScript.PullDecl): TypeScript.PullPrimitiveTypeSymbol;
        public addPrimitiveValue(name: string, type: TypeScript.PullTypeSymbol, globalDecl: TypeScript.PullDecl): void;
        public getGlobalDecl(): TypeScript.PullDecl;
        constructor();
        public addUnit(unit: SemanticInfo): void;
        public getUnit(compilationUnitPath: string);
        public updateUnit(oldUnit: SemanticInfo, newUnit: SemanticInfo): void;
        private collectAllTopLevelDecls();
        private collectAllSynthesizedDecls();
        private getDeclPathCacheID(declPath, declKind);
        public findTopLevelSymbol(name: string, kind: TypeScript.PullElementKind, stopAtFile: string): TypeScript.PullSymbol;
        public findDecls(declPath: string[], declKind: TypeScript.PullElementKind): TypeScript.PullDecl[];
        public findDeclsFromPath(declPath: TypeScript.PullDecl[], declKind: TypeScript.PullElementKind): TypeScript.PullDecl[];
        public findSymbol(declPath: string[], declType: TypeScript.PullElementKind): TypeScript.PullSymbol;
        public cacheGlobalSymbol(symbol: TypeScript.PullSymbol, kind: TypeScript.PullElementKind): void;
        private cleanDecl(decl);
        private cleanAllDecls();
        private cleanAllSynthesizedDecls();
        public update(): void;
        public invalidateUnit(compilationUnitPath: string): void;
        public forceTypeCheck(compilationUnitPath: string): void;
        public getDeclForAST(ast: TypeScript.AST, unitPath: string): TypeScript.PullDecl;
        public getASTForDecl(decl: TypeScript.PullDecl): TypeScript.AST;
        public getSymbolForAST(ast: TypeScript.IAST, unitPath: string): TypeScript.PullSymbol;
        public getASTForSymbol(symbol: TypeScript.PullSymbol, unitPath: string): TypeScript.AST;
        public setSymbolForAST(ast: TypeScript.AST, symbol: TypeScript.PullSymbol, unitPath: string): void;
        public getAliasSymbolForAST(ast: TypeScript.IAST, unitPath: string): TypeScript.PullTypeAliasSymbol;
        public removeSymbolFromCache(symbol: TypeScript.PullSymbol): void;
        public postDiagnostics(): TypeScript.Diagnostic[];
    }
}
declare module TypeScript {
    class DeclCollectionContext {
        public semanticInfo: TypeScript.SemanticInfo;
        public scriptName: string;
        public isDeclareFile: boolean;
        public parentChain: TypeScript.PullDecl[];
        public containingModuleHasExportAssignmentArray: boolean[];
        public isParsingAmbientModuleArray: boolean[];
        constructor(semanticInfo: TypeScript.SemanticInfo, scriptName: string);
        public getParent(): TypeScript.PullDecl;
        public pushParent(parentDecl: TypeScript.PullDecl): void;
        public popParent(): void;
        public foundValueDecl: boolean;
        public containingModuleHasExportAssignment(): boolean;
        public isParsingAmbientModule(): boolean;
    }
    function preCollectDecls(ast: AST, parentAST: AST, walker: IAstWalker): AST;
    function postCollectDecls(ast: AST, parentAST: AST, walker: IAstWalker): AST;
}
declare module TypeScript {
    function getPathToDecl(decl: PullDecl): PullDecl[];
    class PullSymbolBinder {
        public semanticInfoChain: TypeScript.SemanticInfoChain;
        private functionTypeParameterCache;
        private findTypeParameterInCache(name);
        private addTypeParameterToCache(typeParameter);
        public resetTypeParameterCache(): void;
        public semanticInfo: TypeScript.SemanticInfo;
        constructor(semanticInfoChain: TypeScript.SemanticInfoChain);
        public setUnit(fileName: string): void;
        public getParent(decl: TypeScript.PullDecl, returnInstanceType?: boolean): TypeScript.PullTypeSymbol;
        public findDeclsInContext(startingDecl: TypeScript.PullDecl, declKind: TypeScript.PullElementKind, searchGlobally: boolean): TypeScript.PullDecl[];
        public bindModuleDeclarationToPullSymbol(moduleContainerDecl: TypeScript.PullDecl): void;
        public bindImportDeclaration(importDeclaration: TypeScript.PullDecl): void;
        public bindClassDeclarationToPullSymbol(classDecl: TypeScript.PullDecl): void;
        public bindInterfaceDeclarationToPullSymbol(interfaceDecl: TypeScript.PullDecl): void;
        public bindObjectTypeDeclarationToPullSymbol(objectDecl: TypeScript.PullDecl): void;
        public bindConstructorTypeDeclarationToPullSymbol(constructorTypeDeclaration: TypeScript.PullDecl): void;
        public bindVariableDeclarationToPullSymbol(variableDeclaration: TypeScript.PullDecl): void;
        public bindPropertyDeclarationToPullSymbol(propertyDeclaration: TypeScript.PullDecl): void;
        public bindParameterSymbols(funcDecl: TypeScript.FunctionDeclaration, funcType: TypeScript.PullTypeSymbol, signatureSymbol: TypeScript.PullSignatureSymbol): void;
        public bindFunctionDeclarationToPullSymbol(functionDeclaration: TypeScript.PullDecl): void;
        public bindFunctionExpressionToPullSymbol(functionExpressionDeclaration: TypeScript.PullDecl): void;
        public bindFunctionTypeDeclarationToPullSymbol(functionTypeDeclaration: TypeScript.PullDecl): void;
        public bindMethodDeclarationToPullSymbol(methodDeclaration: TypeScript.PullDecl): void;
        public bindConstructorDeclarationToPullSymbol(constructorDeclaration: TypeScript.PullDecl): void;
        public bindConstructSignatureDeclarationToPullSymbol(constructSignatureDeclaration: TypeScript.PullDecl): void;
        public bindCallSignatureDeclarationToPullSymbol(callSignatureDeclaration: TypeScript.PullDecl): void;
        public bindIndexSignatureDeclarationToPullSymbol(indexSignatureDeclaration: TypeScript.PullDecl): void;
        public bindGetAccessorDeclarationToPullSymbol(getAccessorDeclaration: TypeScript.PullDecl): void;
        public bindSetAccessorDeclarationToPullSymbol(setAccessorDeclaration: TypeScript.PullDecl): void;
        public bindDeclToPullSymbol(decl: TypeScript.PullDecl): void;
        public bindDeclsForUnit(filePath: string): void;
    }
}
declare module TypeScript {
    function getDiagnosticsFromEnclosingDecl(enclosingDecl: PullDecl, errors: Diagnostic[]): void;
}
declare module TypeScript.PullHelpers {
    interface SignatureInfoForFuncDecl {
        signature: TypeScript.PullSignatureSymbol;
        allSignatures: TypeScript.PullSignatureSymbol[];
    }
    function getSignatureForFuncDecl(funcDecl: TypeScript.FunctionDeclaration, semanticInfo: TypeScript.SemanticInfo): {
        signature: TypeScript.PullSignatureSymbol;
        allSignatures: TypeScript.PullSignatureSymbol[];
    };
    function getAccessorSymbol(getterOrSetter: TypeScript.FunctionDeclaration, semanticInfoChain: TypeScript.SemanticInfoChain, unitPath: string): TypeScript.PullAccessorSymbol;
    function getGetterAndSetterFunction(funcDecl: TypeScript.FunctionDeclaration, semanticInfoChain: TypeScript.SemanticInfoChain, unitPath: string): {
        getter: TypeScript.FunctionDeclaration;
        setter: TypeScript.FunctionDeclaration;
    };
    function symbolIsEnum(source: TypeScript.PullSymbol): boolean;
    function symbolIsModule(symbol: TypeScript.PullSymbol): boolean;
}
declare module TypeScript {
    class SyntaxTreeToAstVisitor implements TypeScript.ISyntaxVisitor {
        private fileName;
        public lineMap: TypeScript.LineMap;
        private compilationSettings;
        public position: number;
        public previousTokenTrailingComments: TypeScript.Comment[];
        private static protoString;
        private static protoSubstitutionString;
        constructor(fileName: string, lineMap: TypeScript.LineMap, compilationSettings: TypeScript.CompilationSettings);
        static visit(syntaxTree: TypeScript.SyntaxTree, fileName: string, compilationSettings: TypeScript.CompilationSettings, incrementalAST: boolean): TypeScript.Script;
        public movePast(element: TypeScript.ISyntaxElement): void;
        private moveTo(element1, element2);
        private setCommentsAndSpan(ast, fullStart, node);
        private copySpan(from, to);
        public setSpan(span: TypeScript.IASTSpan, fullStart: number, element: TypeScript.ISyntaxElement): void;
        public setSpan2(span: TypeScript.IASTSpan, fullStart: number, element: TypeScript.ISyntaxElement, firstToken: TypeScript.ISyntaxToken, lastToken: TypeScript.ISyntaxToken): void;
        public setSpanExplicit(span: TypeScript.IASTSpan, start: number, end: number): void;
        public identifierFromToken(token: TypeScript.ISyntaxToken, isOptional: boolean): TypeScript.Identifier;
        public visitSyntaxList(node: TypeScript.ISyntaxList): TypeScript.ASTList;
        public visitSeparatedSyntaxList(list: TypeScript.ISeparatedSyntaxList): TypeScript.ASTList;
        private createRef(text, minChar);
        private convertComment(trivia, commentStartPosition, hasTrailingNewLine);
        private convertComments(triviaList, commentStartPosition);
        private mergeComments(comments1, comments2);
        private convertTokenLeadingComments(token, commentStartPosition);
        private convertTokenTrailingComments(token, commentStartPosition);
        private convertNodeTrailingComments(node, lastToken, nodeStart);
        public visitToken(token: TypeScript.ISyntaxToken): TypeScript.AST;
        private getLeadingComments(node);
        private hasTopLevelImportOrExport(node);
        private getAmdDependency(comment);
        public visitSourceUnit(node: TypeScript.SourceUnitSyntax): TypeScript.Script;
        public visitExternalModuleReference(node: TypeScript.ExternalModuleReferenceSyntax): any;
        public visitModuleNameModuleReference(node: TypeScript.ModuleNameModuleReferenceSyntax): any;
        public visitClassDeclaration(node: TypeScript.ClassDeclarationSyntax): TypeScript.ClassDeclaration;
        public completeClassDeclaration(node: TypeScript.ClassDeclarationSyntax, result: TypeScript.ClassDeclaration): void;
        public visitInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax): TypeScript.InterfaceDeclaration;
        public completeInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax, result: TypeScript.InterfaceDeclaration): void;
        public visitHeritageClause(node: TypeScript.HeritageClauseSyntax): TypeScript.ASTList;
        private getModuleNames(node);
        private getModuleNamesHelper(name, result);
        public visitModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax): TypeScript.ModuleDeclaration;
        public completeModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax, result: TypeScript.ModuleDeclaration): void;
        private hasDotDotDotParameter(parameters);
        public visitFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax): TypeScript.FunctionDeclaration;
        public completeFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax, result: TypeScript.FunctionDeclaration): void;
        public visitEnumDeclaration(node: TypeScript.EnumDeclarationSyntax): TypeScript.ModuleDeclaration;
        private determineConstantValue(equalsValue, declarators);
        private computeConstantValue(expression, declarators);
        public visitEnumElement(node: TypeScript.EnumElementSyntax): void;
        public visitImportDeclaration(node: TypeScript.ImportDeclarationSyntax): TypeScript.ImportDeclaration;
        public visitExportAssignment(node: TypeScript.ExportAssignmentSyntax): TypeScript.ExportAssignment;
        public visitVariableStatement(node: TypeScript.VariableStatementSyntax): TypeScript.VariableStatement;
        public visitVariableDeclaration(node: TypeScript.VariableDeclarationSyntax): TypeScript.VariableDeclaration;
        public visitVariableDeclarator(node: TypeScript.VariableDeclaratorSyntax): TypeScript.VariableDeclarator;
        public visitEqualsValueClause(node: TypeScript.EqualsValueClauseSyntax): TypeScript.AST;
        private getUnaryExpressionNodeType(kind);
        public visitPrefixUnaryExpression(node: TypeScript.PrefixUnaryExpressionSyntax): TypeScript.UnaryExpression;
        private isOnSingleLine(start, end);
        public visitArrayLiteralExpression(node: TypeScript.ArrayLiteralExpressionSyntax): TypeScript.UnaryExpression;
        public visitOmittedExpression(node: TypeScript.OmittedExpressionSyntax): TypeScript.OmittedExpression;
        public visitParenthesizedExpression(node: TypeScript.ParenthesizedExpressionSyntax): TypeScript.ParenthesizedExpression;
        private getArrowFunctionStatements(body);
        public visitSimpleArrowFunctionExpression(node: TypeScript.SimpleArrowFunctionExpressionSyntax): TypeScript.FunctionDeclaration;
        public visitParenthesizedArrowFunctionExpression(node: TypeScript.ParenthesizedArrowFunctionExpressionSyntax): TypeScript.FunctionDeclaration;
        public visitType(type: TypeScript.ITypeSyntax): TypeScript.TypeReference;
        public visitTypeQuery(node: TypeScript.TypeQuerySyntax): TypeScript.TypeReference;
        public visitQualifiedName(node: TypeScript.QualifiedNameSyntax): TypeScript.TypeReference;
        public visitTypeArgumentList(node: TypeScript.TypeArgumentListSyntax): TypeScript.ASTList;
        public visitConstructorType(node: TypeScript.ConstructorTypeSyntax): TypeScript.TypeReference;
        public visitFunctionType(node: TypeScript.FunctionTypeSyntax): TypeScript.TypeReference;
        public visitObjectType(node: TypeScript.ObjectTypeSyntax): TypeScript.TypeReference;
        public visitArrayType(node: TypeScript.ArrayTypeSyntax): TypeScript.TypeReference;
        public visitGenericType(node: TypeScript.GenericTypeSyntax): TypeScript.TypeReference;
        public visitTypeAnnotation(node: TypeScript.TypeAnnotationSyntax): TypeScript.TypeReference;
        public visitBlock(node: TypeScript.BlockSyntax): TypeScript.Block;
        public visitParameter(node: TypeScript.ParameterSyntax): TypeScript.Parameter;
        public visitMemberAccessExpression(node: TypeScript.MemberAccessExpressionSyntax): TypeScript.BinaryExpression;
        public visitPostfixUnaryExpression(node: TypeScript.PostfixUnaryExpressionSyntax): TypeScript.UnaryExpression;
        public visitElementAccessExpression(node: TypeScript.ElementAccessExpressionSyntax): TypeScript.BinaryExpression;
        private convertArgumentListArguments(node);
        public visitInvocationExpression(node: TypeScript.InvocationExpressionSyntax): TypeScript.InvocationExpression;
        public visitArgumentList(node: TypeScript.ArgumentListSyntax): TypeScript.ASTList;
        private getBinaryExpressionNodeType(node);
        public visitBinaryExpression(node: TypeScript.BinaryExpressionSyntax): TypeScript.BinaryExpression;
        public visitConditionalExpression(node: TypeScript.ConditionalExpressionSyntax): TypeScript.ConditionalExpression;
        public visitConstructSignature(node: TypeScript.ConstructSignatureSyntax): TypeScript.FunctionDeclaration;
        public visitMethodSignature(node: TypeScript.MethodSignatureSyntax): TypeScript.FunctionDeclaration;
        public visitIndexSignature(node: TypeScript.IndexSignatureSyntax): TypeScript.FunctionDeclaration;
        public visitPropertySignature(node: TypeScript.PropertySignatureSyntax): TypeScript.VariableDeclarator;
        public visitParameterList(node: TypeScript.ParameterListSyntax): TypeScript.ASTList;
        public visitCallSignature(node: TypeScript.CallSignatureSyntax): TypeScript.FunctionDeclaration;
        public visitTypeParameterList(node: TypeScript.TypeParameterListSyntax): TypeScript.ASTList;
        public visitTypeParameter(node: TypeScript.TypeParameterSyntax): TypeScript.TypeParameter;
        public visitConstraint(node: TypeScript.ConstraintSyntax): TypeScript.TypeReference;
        public visitIfStatement(node: TypeScript.IfStatementSyntax): TypeScript.IfStatement;
        public visitElseClause(node: TypeScript.ElseClauseSyntax): TypeScript.AST;
        public visitExpressionStatement(node: TypeScript.ExpressionStatementSyntax): TypeScript.ExpressionStatement;
        public visitConstructorDeclaration(node: TypeScript.ConstructorDeclarationSyntax): TypeScript.FunctionDeclaration;
        public visitMemberFunctionDeclaration(node: TypeScript.MemberFunctionDeclarationSyntax): TypeScript.FunctionDeclaration;
        public visitMemberAccessorDeclaration(node: TypeScript.MemberAccessorDeclarationSyntax, typeAnnotation: TypeScript.TypeAnnotationSyntax): TypeScript.FunctionDeclaration;
        public visitGetMemberAccessorDeclaration(node: TypeScript.GetMemberAccessorDeclarationSyntax): TypeScript.FunctionDeclaration;
        public visitSetMemberAccessorDeclaration(node: TypeScript.SetMemberAccessorDeclarationSyntax): TypeScript.FunctionDeclaration;
        public visitMemberVariableDeclaration(node: TypeScript.MemberVariableDeclarationSyntax): TypeScript.VariableDeclarator;
        public visitThrowStatement(node: TypeScript.ThrowStatementSyntax): TypeScript.ThrowStatement;
        public visitReturnStatement(node: TypeScript.ReturnStatementSyntax): TypeScript.ReturnStatement;
        public visitObjectCreationExpression(node: TypeScript.ObjectCreationExpressionSyntax): TypeScript.ObjectCreationExpression;
        public visitSwitchStatement(node: TypeScript.SwitchStatementSyntax): TypeScript.SwitchStatement;
        public visitCaseSwitchClause(node: TypeScript.CaseSwitchClauseSyntax): TypeScript.CaseClause;
        public visitDefaultSwitchClause(node: TypeScript.DefaultSwitchClauseSyntax): TypeScript.CaseClause;
        public visitBreakStatement(node: TypeScript.BreakStatementSyntax): TypeScript.Jump;
        public visitContinueStatement(node: TypeScript.ContinueStatementSyntax): TypeScript.Jump;
        public visitForStatement(node: TypeScript.ForStatementSyntax): TypeScript.ForStatement;
        public visitForInStatement(node: TypeScript.ForInStatementSyntax): TypeScript.ForInStatement;
        public visitWhileStatement(node: TypeScript.WhileStatementSyntax): TypeScript.WhileStatement;
        public visitWithStatement(node: TypeScript.WithStatementSyntax): TypeScript.WithStatement;
        public visitCastExpression(node: TypeScript.CastExpressionSyntax): TypeScript.UnaryExpression;
        public visitObjectLiteralExpression(node: TypeScript.ObjectLiteralExpressionSyntax): TypeScript.UnaryExpression;
        public visitSimplePropertyAssignment(node: TypeScript.SimplePropertyAssignmentSyntax): TypeScript.BinaryExpression;
        public visitFunctionPropertyAssignment(node: TypeScript.FunctionPropertyAssignmentSyntax): TypeScript.BinaryExpression;
        public visitGetAccessorPropertyAssignment(node: TypeScript.GetAccessorPropertyAssignmentSyntax): TypeScript.BinaryExpression;
        public visitSetAccessorPropertyAssignment(node: TypeScript.SetAccessorPropertyAssignmentSyntax): TypeScript.BinaryExpression;
        public visitFunctionExpression(node: TypeScript.FunctionExpressionSyntax): TypeScript.FunctionDeclaration;
        public visitEmptyStatement(node: TypeScript.EmptyStatementSyntax): TypeScript.EmptyStatement;
        public visitTryStatement(node: TypeScript.TryStatementSyntax): TypeScript.TryStatement;
        public visitCatchClause(node: TypeScript.CatchClauseSyntax): TypeScript.CatchClause;
        public visitFinallyClause(node: TypeScript.FinallyClauseSyntax): TypeScript.Block;
        public visitLabeledStatement(node: TypeScript.LabeledStatementSyntax): TypeScript.LabeledStatement;
        public visitDoStatement(node: TypeScript.DoStatementSyntax): TypeScript.DoStatement;
        public visitTypeOfExpression(node: TypeScript.TypeOfExpressionSyntax): TypeScript.UnaryExpression;
        public visitDeleteExpression(node: TypeScript.DeleteExpressionSyntax): TypeScript.UnaryExpression;
        public visitVoidExpression(node: TypeScript.VoidExpressionSyntax): TypeScript.UnaryExpression;
        public visitDebuggerStatement(node: TypeScript.DebuggerStatementSyntax): TypeScript.DebuggerStatement;
    }
}
declare module TypeScript {
    var fileResolutionTime: number;
    var sourceCharactersCompiled: number;
    var syntaxTreeParseTime: number;
    var syntaxDiagnosticsTime: number;
    var astTranslationTime: number;
    var typeCheckTime: number;
    var emitTime: number;
    var emitWriteFileTime: number;
    var emitDirectoryExistsTime: number;
    var emitFileExistsTime: number;
    var emitResolvePathTime: number;
    var declarationEmitTime: number;
    var declarationEmitIsExternallyVisibleTime: number;
    var declarationEmitTypeSignatureTime: number;
    var declarationEmitGetBoundDeclTypeTime: number;
    var declarationEmitIsOverloadedCallSignatureTime: number;
    var declarationEmitFunctionDeclarationGetSymbolTime: number;
    var declarationEmitGetBaseTypeTime: number;
    var declarationEmitGetAccessorFunctionTime: number;
    var declarationEmitGetTypeParameterSymbolTime: number;
    var declarationEmitGetImportDeclarationSymbolTime: number;
    var ioHostResolvePathTime: number;
    var ioHostDirectoryNameTime: number;
    var ioHostCreateDirectoryStructureTime: number;
    var ioHostWriteFileTime: number;
    interface EmitterIOHost {
        writeFile(path: string, contents: string, writeByteOrderMark: boolean): void;
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        resolvePath(path: string): string;
    }
    interface PullTypeInfoAtPositionInfo {
        symbol: TypeScript.PullSymbol;
        ast: TypeScript.IAST;
        enclosingScopeSymbol: TypeScript.PullSymbol;
        candidateSignature: TypeScript.PullSignatureSymbol;
        callSignatures: TypeScript.PullSignatureSymbol[];
        isConstructorCall: boolean;
    }
    interface PullSymbolInfo {
        symbol: TypeScript.PullSymbol;
        ast: TypeScript.AST;
        enclosingScopeSymbol: TypeScript.PullSymbol;
    }
    interface PullCallSymbolInfo {
        targetSymbol: TypeScript.PullSymbol;
        resolvedSignatures: TypeScript.PullSignatureSymbol[];
        candidateSignature: TypeScript.PullSignatureSymbol;
        isConstructorCall: boolean;
        ast: TypeScript.AST;
        enclosingScopeSymbol: TypeScript.PullSymbol;
    }
    interface PullVisibleSymbolsInfo {
        symbols: TypeScript.PullSymbol[];
        enclosingScopeSymbol: TypeScript.PullSymbol;
    }
    class Document {
        public fileName: string;
        private compilationSettings;
        private scriptSnapshot;
        public byteOrderMark: ByteOrderMark;
        public version: number;
        public isOpen: boolean;
        private _diagnostics;
        private _syntaxTree;
        private _bloomFilter;
        public script: TypeScript.Script;
        public lineMap: TypeScript.LineMap;
        constructor(fileName: string, compilationSettings: TypeScript.CompilationSettings, scriptSnapshot: TypeScript.IScriptSnapshot, byteOrderMark: ByteOrderMark, version: number, isOpen: boolean, syntaxTree: TypeScript.SyntaxTree);
        public diagnostics(): TypeScript.Diagnostic[];
        public syntaxTree(): TypeScript.SyntaxTree;
        public bloomFilter(): TypeScript.BloomFilter;
        public update(scriptSnapshot: TypeScript.IScriptSnapshot, version: number, isOpen: boolean, textChangeRange: TypeScript.TextChangeRange, settings: TypeScript.CompilationSettings): Document;
        static create(fileName: string, scriptSnapshot: TypeScript.IScriptSnapshot, byteOrderMark: ByteOrderMark, version: number, isOpen: boolean, referencedFiles: string[], compilationSettings: TypeScript.CompilationSettings): Document;
    }
    var globalSemanticInfoChain: SemanticInfoChain;
    var globalBinder: PullSymbolBinder;
    var globalLogger: ILogger;
    var useDirectTypeStorage: boolean;
    class TypeScriptCompiler {
        public logger: TypeScript.ILogger;
        public settings: TypeScript.CompilationSettings;
        public resolver: TypeScript.PullTypeResolver;
        public semanticInfoChain: TypeScript.SemanticInfoChain;
        public emitOptions: TypeScript.EmitOptions;
        public fileNameToDocument: TypeScript.StringHashTable<Document>;
        constructor(logger?: TypeScript.ILogger, settings?: TypeScript.CompilationSettings);
        public getDocument(fileName: string): Document;
        public timeFunction(funcDescription: string, func: () => any): any;
        public addSourceUnit(fileName: string, scriptSnapshot: TypeScript.IScriptSnapshot, byteOrderMark: ByteOrderMark, version: number, isOpen: boolean, referencedFiles?: string[]): Document;
        public updateSourceUnit(fileName: string, scriptSnapshot: TypeScript.IScriptSnapshot, version: number, isOpen: boolean, textChangeRange: TypeScript.TextChangeRange): Document;
        private isDynamicModuleCompilation();
        private updateCommonDirectoryPath();
        private convertToDirectoryPath(dirPath);
        public setEmitOptions(ioHost: EmitterIOHost): TypeScript.Diagnostic;
        public getScripts(): TypeScript.Script[];
        public getDocuments(): Document[];
        private writeByteOrderMarkForDocument(document);
        static mapToDTSFileName(fileName: string, wholeFileNameReplaced: boolean): string;
        private canEmitDeclarations(script?);
        private emitDeclarations(document, declarationEmitter?);
        public emitAllDeclarations(): TypeScript.Diagnostic[];
        public emitUnitDeclarations(fileName: string): TypeScript.Diagnostic[];
        static mapToFileNameExtension(extension: string, fileName: string, wholeFileNameReplaced: boolean): string;
        static mapToJSFileName(fileName: string, wholeFileNameReplaced: boolean): string;
        private emit(document, inputOutputMapper?, emitter?);
        public emitAll(ioHost: EmitterIOHost, inputOutputMapper?: (inputFile: string, outputFile: string) => void): TypeScript.Diagnostic[];
        public emitUnit(fileName: string, ioHost: EmitterIOHost, inputOutputMapper?: (inputFile: string, outputFile: string) => void): TypeScript.Diagnostic[];
        private createFile(fileName, writeByteOrderMark);
        public pullResolveFile(fileName: string): boolean;
        public getSyntacticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        private getSyntaxTree(fileName);
        private getScript(fileName);
        public getSemanticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        public resolveAllFiles(): void;
        public setUnit(unitPath: string): void;
        public pullTypeCheck(): void;
        private pullUpdateScript(oldDocument, newDocument);
        public getSymbolOfDeclaration(decl: TypeScript.PullDecl): TypeScript.PullSymbol;
        public resolvePosition(pos: number, document: Document): PullTypeInfoAtPositionInfo;
        private extractResolutionContextFromPath(path, document, propagateContextualTypes);
        public pullGetSymbolInformationFromPath(path: TypeScript.AstPath, document: Document): PullSymbolInfo;
        public pullGetDeclarationSymbolInformation(path: TypeScript.AstPath, document: Document): PullSymbolInfo;
        public pullGetCallInformationFromPath(path: TypeScript.AstPath, document: Document): PullCallSymbolInfo;
        public pullGetVisibleMemberSymbolsFromPath(path: TypeScript.AstPath, document: Document): PullVisibleSymbolsInfo;
        public pullGetVisibleDeclsFromPath(path: TypeScript.AstPath, document: Document): TypeScript.PullDecl[];
        public pullGetContextualMembersFromPath(path: TypeScript.AstPath, document: Document): PullVisibleSymbolsInfo;
        public pullGetDeclInformation(decl: TypeScript.PullDecl, path: TypeScript.AstPath, document: Document): PullSymbolInfo;
        public pullGetTypeInfoAtPosition(pos: number, document: Document): PullTypeInfoAtPositionInfo;
        public getTopLevelDeclarations(scriptName: string): TypeScript.PullDecl[];
        public reportDiagnostics(errors: TypeScript.Diagnostic[], errorReporter: TypeScript.IDiagnosticReporter): void;
    }
}
declare module TypeScript {
    class CompilationSettings {
        public propagateEnumConstants: boolean;
        public removeComments: boolean;
        public watch: boolean;
        public noResolve: boolean;
        public allowAutomaticSemicolonInsertion: boolean;
        public noImplicitAny: boolean;
        public noLib: boolean;
        public codeGenTarget: TypeScript.LanguageVersion;
        public moduleGenTarget: TypeScript.ModuleGenTarget;
        public outFileOption: string;
        public outDirOption: string;
        public mapSourceFiles: boolean;
        public mapRoot: string;
        public sourceRoot: string;
        public generateDeclarationFiles: boolean;
        public useCaseSensitiveFileResolution: boolean;
        public gatherDiagnostics: boolean;
        public updateTC: boolean;
    }
    interface IPreProcessedFileInfo {
        settings: CompilationSettings;
        referencedFiles: TypeScript.IFileReference[];
        importedFiles: TypeScript.IFileReference[];
        isLibFile: boolean;
    }
    function getImplicitImport(comment: string): boolean;
    function getReferencedFiles(fileName: string, sourceText: IScriptSnapshot): IFileReference[];
    function preProcessFile(fileName: string, sourceText: IScriptSnapshot, settings?: CompilationSettings, readImportFiles?: boolean): IPreProcessedFileInfo;
    function getParseOptions(settings: CompilationSettings): ParseOptions;
}
declare module Services {
    enum EndOfLineState {
        Start,
        InMultiLineCommentTrivia,
        InSingleQuoteStringLiteral,
        InDoubleQuoteStringLiteral,
    }
    enum TokenClass {
        Punctuation,
        Keyword,
        Operator,
        Comment,
        Whitespace,
        Identifier,
        NumberLiteral,
        StringLiteral,
        RegExpLiteral,
    }
    class Classifier {
        public host: IClassifierHost;
        private scanner;
        private characterWindow;
        private diagnostics;
        constructor(host: IClassifierHost);
        public getClassificationsForLine(text: string, lexState: EndOfLineState): ClassificationResult;
        private processToken(text, offset, token, result);
        private processTriviaList(text, offset, triviaList, result);
        private addResult(text, offset, result, length, kind);
        private classFromKind(kind);
    }
    interface IClassifierHost extends TypeScript.ILogger {
    }
    class ClassificationResult {
        public finalLexState: EndOfLineState;
        public entries: ClassificationInfo[];
        constructor();
    }
    class ClassificationInfo {
        public length: number;
        public classification: TokenClass;
        constructor(length: number, classification: TokenClass);
    }
}
declare module TypeScript.Formatting {
    interface ITextSnapshot {
        getText(span: TypeScript.TextSpan): string;
        getLineNumberFromPosition(position: number): number;
        getLineFromPosition(position: number): Formatting.ITextSnapshotLine;
        getLineFromLineNumber(lineNumber: number): Formatting.ITextSnapshotLine;
    }
    class TextSnapshot implements ITextSnapshot {
        private snapshot;
        private lines;
        constructor(snapshot: TypeScript.ISimpleText);
        public getText(span: TypeScript.TextSpan): string;
        public getLineNumberFromPosition(position: number): number;
        public getLineFromPosition(position: number): Formatting.ITextSnapshotLine;
        public getLineFromLineNumber(lineNumber: number): Formatting.ITextSnapshotLine;
        private getLineFromLineNumberWorker(lineNumber);
    }
}
declare module TypeScript.Formatting {
    interface ITextSnapshotLine {
        snapshot(): Formatting.ITextSnapshot;
        start(): Formatting.SnapshotPoint;
        startPosition(): number;
        end(): Formatting.SnapshotPoint;
        endPosition(): number;
        endIncludingLineBreak(): Formatting.SnapshotPoint;
        endIncludingLineBreakPosition(): number;
        length(): number;
        lineNumber(): number;
        getText(): string;
    }
    class TextSnapshotLine implements ITextSnapshotLine {
        private _snapshot;
        private _lineNumber;
        private _start;
        private _end;
        private _lineBreak;
        constructor(_snapshot: Formatting.ITextSnapshot, _lineNumber: number, _start: number, _end: number, _lineBreak: string);
        public snapshot(): Formatting.ITextSnapshot;
        public start(): Formatting.SnapshotPoint;
        public startPosition(): number;
        public end(): Formatting.SnapshotPoint;
        public endPosition(): number;
        public endIncludingLineBreak(): Formatting.SnapshotPoint;
        public endIncludingLineBreakPosition(): number;
        public length(): number;
        public lineNumber(): number;
        public getText(): string;
    }
}
declare module TypeScript.Formatting {
    class SnapshotPoint {
        public snapshot: Formatting.ITextSnapshot;
        public position: number;
        constructor(snapshot: Formatting.ITextSnapshot, position: number);
        public getContainingLine(): Formatting.ITextSnapshotLine;
        public add(offset: number): SnapshotPoint;
    }
}
declare module TypeScript.Formatting {
    class FormattingContext {
        private snapshot;
        public formattingRequestKind: Formatting.FormattingRequestKind;
        public currentTokenSpan: Formatting.TokenSpan;
        public nextTokenSpan: Formatting.TokenSpan;
        public contextNode: Formatting.IndentationNodeContext;
        public currentTokenParent: Formatting.IndentationNodeContext;
        public nextTokenParent: Formatting.IndentationNodeContext;
        private contextNodeAllOnSameLine;
        private nextNodeAllOnSameLine;
        private tokensAreOnSameLine;
        private contextNodeBlockIsOnOneLine;
        private nextNodeBlockIsOnOneLine;
        constructor(snapshot: Formatting.ITextSnapshot, formattingRequestKind: Formatting.FormattingRequestKind);
        public updateContext(currentTokenSpan: Formatting.TokenSpan, currentTokenParent: Formatting.IndentationNodeContext, nextTokenSpan: Formatting.TokenSpan, nextTokenParent: Formatting.IndentationNodeContext, commonParent: Formatting.IndentationNodeContext): void;
        public ContextNodeAllOnSameLine(): boolean;
        public NextNodeAllOnSameLine(): boolean;
        public TokensAreOnSameLine(): boolean;
        public ContextNodeBlockIsOnOneLine(): boolean;
        public NextNodeBlockIsOnOneLine(): boolean;
        public NodeIsOnOneLine(node: Formatting.IndentationNodeContext): boolean;
        public BlockIsOnOneLine(node: Formatting.IndentationNodeContext): boolean;
    }
}
declare module TypeScript.Formatting {
    class FormattingManager {
        private syntaxTree;
        private snapshot;
        private rulesProvider;
        private options;
        constructor(syntaxTree: TypeScript.SyntaxTree, snapshot: Formatting.ITextSnapshot, rulesProvider: Formatting.RulesProvider, editorOptions: Services.EditorOptions);
        public formatSelection(minChar: number, limChar: number): Services.TextEdit[];
        public formatDocument(minChar: number, limChar: number): Services.TextEdit[];
        public formatOnPaste(minChar: number, limChar: number): Services.TextEdit[];
        public formatOnSemicolon(caretPosition: number): Services.TextEdit[];
        public formatOnClosingCurlyBrace(caretPosition: number): Services.TextEdit[];
        public formatOnEnter(caretPosition: number): Services.TextEdit[];
        private formatSpan(span, formattingRequestKind);
    }
}
declare module TypeScript.Formatting {
    enum FormattingRequestKind {
        FormatDocument,
        FormatSelection,
        FormatOnEnter,
        FormatOnSemicolon,
        FormatOnClosingCurlyBrace,
        FormatOnPaste,
    }
}
declare module TypeScript.Formatting {
    class Rule {
        public Descriptor: Formatting.RuleDescriptor;
        public Operation: Formatting.RuleOperation;
        public Flag: Formatting.RuleFlags;
        constructor(Descriptor: Formatting.RuleDescriptor, Operation: Formatting.RuleOperation, Flag?: Formatting.RuleFlags);
        public toString(): string;
    }
}
declare module TypeScript.Formatting {
    enum RuleAction {
        Ignore,
        Space,
        NewLine,
        Delete,
    }
}
declare module TypeScript.Formatting {
    class RuleDescriptor {
        public LeftTokenRange: Formatting.Shared.TokenRange;
        public RightTokenRange: Formatting.Shared.TokenRange;
        constructor(LeftTokenRange: Formatting.Shared.TokenRange, RightTokenRange: Formatting.Shared.TokenRange);
        public toString(): string;
        static create1(left: TypeScript.SyntaxKind, right: TypeScript.SyntaxKind): RuleDescriptor;
        static create2(left: Formatting.Shared.TokenRange, right: TypeScript.SyntaxKind): RuleDescriptor;
        static create3(left: TypeScript.SyntaxKind, right: Formatting.Shared.TokenRange): RuleDescriptor;
        static create4(left: Formatting.Shared.TokenRange, right: Formatting.Shared.TokenRange): RuleDescriptor;
    }
}
declare module TypeScript.Formatting {
    enum RuleFlags {
        None,
        CanDeleteNewLines,
    }
}
declare module TypeScript.Formatting {
    class RuleOperation {
        public Context: Formatting.RuleOperationContext;
        public Action: Formatting.RuleAction;
        constructor();
        public toString(): string;
        static create1(action: Formatting.RuleAction): RuleOperation;
        static create2(context: Formatting.RuleOperationContext, action: Formatting.RuleAction): RuleOperation;
    }
}
declare module TypeScript.Formatting {
    class RuleOperationContext {
        private customContextChecks;
        constructor(...funcs: {
            (context: Formatting.FormattingContext): boolean;
        }[]);
        static Any: RuleOperationContext;
        public IsAny(): boolean;
        public InContext(context: Formatting.FormattingContext): boolean;
    }
}
declare module TypeScript.Formatting {
    class Rules {
        public getRuleName(rule: Formatting.Rule);
        public IgnoreBeforeComment: Formatting.Rule;
        public IgnoreAfterLineComment: Formatting.Rule;
        public NoSpaceBeforeSemicolon: Formatting.Rule;
        public NoSpaceBeforeColon: Formatting.Rule;
        public NoSpaceBeforeQMark: Formatting.Rule;
        public SpaceAfterColon: Formatting.Rule;
        public SpaceAfterQMark: Formatting.Rule;
        public SpaceAfterSemicolon: Formatting.Rule;
        public SpaceAfterCloseBrace: Formatting.Rule;
        public SpaceBetweenCloseBraceAndElse: Formatting.Rule;
        public SpaceBetweenCloseBraceAndWhile: Formatting.Rule;
        public NoSpaceAfterCloseBrace: Formatting.Rule;
        public NoSpaceBeforeDot: Formatting.Rule;
        public NoSpaceAfterDot: Formatting.Rule;
        public NoSpaceBeforeOpenBracket: Formatting.Rule;
        public NoSpaceAfterOpenBracket: Formatting.Rule;
        public NoSpaceBeforeCloseBracket: Formatting.Rule;
        public NoSpaceAfterCloseBracket: Formatting.Rule;
        public SpaceAfterOpenBrace: Formatting.Rule;
        public SpaceBeforeCloseBrace: Formatting.Rule;
        public NoSpaceBetweenEmptyBraceBrackets: Formatting.Rule;
        public NewLineAfterOpenBraceInBlockContext: Formatting.Rule;
        public NewLineBeforeCloseBraceInBlockContext: Formatting.Rule;
        public NoSpaceAfterUnaryPrefixOperator: Formatting.Rule;
        public NoSpaceAfterUnaryPreincrementOperator: Formatting.Rule;
        public NoSpaceAfterUnaryPredecrementOperator: Formatting.Rule;
        public NoSpaceBeforeUnaryPostincrementOperator: Formatting.Rule;
        public NoSpaceBeforeUnaryPostdecrementOperator: Formatting.Rule;
        public SpaceAfterPostincrementWhenFollowedByAdd: Formatting.Rule;
        public SpaceAfterAddWhenFollowedByUnaryPlus: Formatting.Rule;
        public SpaceAfterAddWhenFollowedByPreincrement: Formatting.Rule;
        public SpaceAfterPostdecrementWhenFollowedBySubtract: Formatting.Rule;
        public SpaceAfterSubtractWhenFollowedByUnaryMinus: Formatting.Rule;
        public SpaceAfterSubtractWhenFollowedByPredecrement: Formatting.Rule;
        public NoSpaceBeforeComma: Formatting.Rule;
        public SpaceAfterCertainKeywords: Formatting.Rule;
        public NoSpaceBeforeOpenParenInFuncCall: Formatting.Rule;
        public SpaceAfterFunctionInFuncDecl: Formatting.Rule;
        public NoSpaceBeforeOpenParenInFuncDecl: Formatting.Rule;
        public SpaceAfterVoidOperator: Formatting.Rule;
        public NoSpaceBetweenReturnAndSemicolon: Formatting.Rule;
        public SpaceBetweenStatements: Formatting.Rule;
        public SpaceAfterTryFinally: Formatting.Rule;
        public SpaceAfterGetSetInMember: Formatting.Rule;
        public SpaceBeforeBinaryKeywordOperator: Formatting.Rule;
        public SpaceAfterBinaryKeywordOperator: Formatting.Rule;
        public NoSpaceAfterConstructor: Formatting.Rule;
        public NoSpaceAfterModuleImport: Formatting.Rule;
        public SpaceAfterCertainTypeScriptKeywords: Formatting.Rule;
        public SpaceBeforeCertainTypeScriptKeywords: Formatting.Rule;
        public SpaceAfterModuleName: Formatting.Rule;
        public SpaceAfterArrow: Formatting.Rule;
        public NoSpaceAfterEllipsis: Formatting.Rule;
        public NoSpaceAfterOptionalParameters: Formatting.Rule;
        public NoSpaceBeforeOpenAngularBracket: Formatting.Rule;
        public NoSpaceBetweenCloseParenAndAngularBracket: Formatting.Rule;
        public NoSpaceAfterOpenAngularBracket: Formatting.Rule;
        public NoSpaceBeforeCloseAngularBracket: Formatting.Rule;
        public NoSpaceAfterCloseAngularBracket: Formatting.Rule;
        public NoSpaceBetweenEmptyInterfaceBraceBrackets: Formatting.Rule;
        public HighPriorityCommonRules: Formatting.Rule[];
        public LowPriorityCommonRules: Formatting.Rule[];
        public SpaceAfterComma: Formatting.Rule;
        public NoSpaceAfterComma: Formatting.Rule;
        public SpaceBeforeBinaryOperator: Formatting.Rule;
        public SpaceAfterBinaryOperator: Formatting.Rule;
        public NoSpaceBeforeBinaryOperator: Formatting.Rule;
        public NoSpaceAfterBinaryOperator: Formatting.Rule;
        public SpaceAfterKeywordInControl: Formatting.Rule;
        public NoSpaceAfterKeywordInControl: Formatting.Rule;
        public FunctionOpenBraceLeftTokenRange: Formatting.Shared.TokenRange;
        public SpaceBeforeOpenBraceInFunction: Formatting.Rule;
        public NewLineBeforeOpenBraceInFunction: Formatting.Rule;
        public TypeScriptOpenBraceLeftTokenRange: Formatting.Shared.TokenRange;
        public SpaceBeforeOpenBraceInTypeScriptDeclWithBlock: Formatting.Rule;
        public NewLineBeforeOpenBraceInTypeScriptDeclWithBlock: Formatting.Rule;
        public ControlOpenBraceLeftTokenRange: Formatting.Shared.TokenRange;
        public SpaceBeforeOpenBraceInControl: Formatting.Rule;
        public NewLineBeforeOpenBraceInControl: Formatting.Rule;
        public SpaceAfterSemicolonInFor: Formatting.Rule;
        public NoSpaceAfterSemicolonInFor: Formatting.Rule;
        public SpaceAfterOpenParen: Formatting.Rule;
        public SpaceBeforeCloseParen: Formatting.Rule;
        public NoSpaceBetweenParens: Formatting.Rule;
        public NoSpaceAfterOpenParen: Formatting.Rule;
        public NoSpaceBeforeCloseParen: Formatting.Rule;
        public SpaceAfterAnonymousFunctionKeyword: Formatting.Rule;
        public NoSpaceAfterAnonymousFunctionKeyword: Formatting.Rule;
        constructor();
        static IsForContext(context: Formatting.FormattingContext): boolean;
        static IsNotForContext(context: Formatting.FormattingContext): boolean;
        static IsBinaryOpContext(context: Formatting.FormattingContext): boolean;
        static IsNotBinaryOpContext(context: Formatting.FormattingContext): boolean;
        static IsSameLineTokenOrBeforeMultilineBlockContext(context: Formatting.FormattingContext): boolean;
        static IsBeforeMultilineBlockContext(context: Formatting.FormattingContext): boolean;
        static IsMultilineBlockContext(context: Formatting.FormattingContext): boolean;
        static IsSingleLineBlockContext(context: Formatting.FormattingContext): boolean;
        static IsBlockContext(context: Formatting.FormattingContext): boolean;
        static IsBeforeBlockContext(context: Formatting.FormattingContext): boolean;
        static NodeIsBlockContext(node: Formatting.IndentationNodeContext): boolean;
        static IsFunctionDeclContext(context: Formatting.FormattingContext): boolean;
        static IsTypeScriptDeclWithBlockContext(context: Formatting.FormattingContext): boolean;
        static NodeIsTypeScriptDeclWithBlockContext(node: Formatting.IndentationNodeContext): boolean;
        static IsAfterCodeBlockContext(context: Formatting.FormattingContext): boolean;
        static IsControlDeclContext(context: Formatting.FormattingContext): boolean;
        static IsObjectContext(context: Formatting.FormattingContext): boolean;
        static IsFunctionCallContext(context: Formatting.FormattingContext): boolean;
        static IsNewContext(context: Formatting.FormattingContext): boolean;
        static IsFunctionCallOrNewContext(context: Formatting.FormattingContext): boolean;
        static IsSameLineTokenContext(context: Formatting.FormattingContext): boolean;
        static IsNotFormatOnEnter(context: Formatting.FormattingContext): boolean;
        static IsModuleDeclContext(context: Formatting.FormattingContext): boolean;
        static IsObjectTypeContext(context: Formatting.FormattingContext): boolean;
        static IsTypeArgumentOrParameter(tokenKind: TypeScript.SyntaxKind, parentKind: TypeScript.SyntaxKind): boolean;
        static IsTypeArgumentOrParameterContext(context: Formatting.FormattingContext): boolean;
        static IsVoidOpContext(context: Formatting.FormattingContext): boolean;
    }
}
declare module TypeScript.Formatting {
    class RulesMap {
        public map: RulesBucket[];
        public mapRowLength: number;
        constructor();
        static create(rules: Formatting.Rule[]): RulesMap;
        public Initialize(rules: Formatting.Rule[]): RulesBucket[];
        public FillRules(rules: Formatting.Rule[], rulesBucketConstructionStateList: RulesBucketConstructionState[]): void;
        private GetRuleBucketIndex(row, column);
        private FillRule(rule, rulesBucketConstructionStateList);
        public GetRule(context: Formatting.FormattingContext): Formatting.Rule;
    }
    enum RulesPosition {
        IgnoreRulesSpecific,
        IgnoreRulesAny,
        ContextRulesSpecific,
        ContextRulesAny,
        NoContextRulesSpecific,
        NoContextRulesAny,
    }
    class RulesBucketConstructionState {
        private rulesInsertionIndexBitmap;
        constructor();
        public GetInsertionIndex(maskPosition: RulesPosition): number;
        public IncreaseInsertionIndex(maskPosition: RulesPosition): void;
    }
    class RulesBucket {
        private rules;
        constructor();
        public Rules(): Formatting.Rule[];
        public AddRule(rule: Formatting.Rule, specificTokens: boolean, constructionState: RulesBucketConstructionState[], rulesBucketIndex: number): void;
    }
}
declare module TypeScript.Formatting {
    class RulesProvider {
        private logger;
        private globalRules;
        private options;
        private activeRules;
        private rulesMap;
        constructor(logger: TypeScript.ILogger);
        public getRuleName(rule: Formatting.Rule): string;
        public getRuleByName(name: string): Formatting.Rule;
        public getRulesMap(): Formatting.RulesMap;
        public ensureUpToDate(options: Services.FormatCodeOptions): void;
        private createActiveRules(options);
    }
}
declare module TypeScript.Formatting {
    class TextEditInfo {
        public position: number;
        public length: number;
        public replaceWith: string;
        constructor(position: number, length: number, replaceWith: string);
        public toString(): string;
    }
}
declare module TypeScript.Formatting.Shared {
    interface ITokenAccess {
        GetTokens(): TypeScript.SyntaxKind[];
        Contains(token: TypeScript.SyntaxKind): boolean;
    }
    class TokenRangeAccess implements ITokenAccess {
        private tokens;
        constructor(from: TypeScript.SyntaxKind, to: TypeScript.SyntaxKind, except: TypeScript.SyntaxKind[]);
        public GetTokens(): TypeScript.SyntaxKind[];
        public Contains(token: TypeScript.SyntaxKind): boolean;
        public toString(): string;
    }
    class TokenValuesAccess implements ITokenAccess {
        private tokens;
        constructor(tks: TypeScript.SyntaxKind[]);
        public GetTokens(): TypeScript.SyntaxKind[];
        public Contains(token: TypeScript.SyntaxKind): boolean;
    }
    class TokenSingleValueAccess implements ITokenAccess {
        public token: TypeScript.SyntaxKind;
        constructor(token: TypeScript.SyntaxKind);
        public GetTokens(): TypeScript.SyntaxKind[];
        public Contains(tokenValue: TypeScript.SyntaxKind): boolean;
        public toString(): string;
    }
    class TokenAllAccess implements ITokenAccess {
        public GetTokens(): TypeScript.SyntaxKind[];
        public Contains(tokenValue: TypeScript.SyntaxKind): boolean;
        public toString(): string;
    }
    class TokenRange {
        public tokenAccess: ITokenAccess;
        constructor(tokenAccess: ITokenAccess);
        static FromToken(token: TypeScript.SyntaxKind): TokenRange;
        static FromTokens(tokens: TypeScript.SyntaxKind[]): TokenRange;
        static FromRange(f: TypeScript.SyntaxKind, to: TypeScript.SyntaxKind, except?: TypeScript.SyntaxKind[]): TokenRange;
        static AllTokens(): TokenRange;
        public GetTokens(): TypeScript.SyntaxKind[];
        public Contains(token: TypeScript.SyntaxKind): boolean;
        public toString(): string;
        static Any: TokenRange;
        static AnyIncludingMultilineComments: TokenRange;
        static Keywords: TokenRange;
        static Operators: TokenRange;
        static BinaryOperators: TokenRange;
        static BinaryKeywordOperators: TokenRange;
        static ReservedKeywords: TokenRange;
        static UnaryPrefixOperators: TokenRange;
        static UnaryPrefixExpressions: TokenRange;
        static UnaryPreincrementExpressions: TokenRange;
        static UnaryPostincrementExpressions: TokenRange;
        static UnaryPredecrementExpressions: TokenRange;
        static UnaryPostdecrementExpressions: TokenRange;
        static Comments: TokenRange;
        static TypeNames: TokenRange;
    }
}
declare module TypeScript.Formatting {
    class TokenSpan extends TypeScript.TextSpan {
        private _kind;
        constructor(kind: TypeScript.SyntaxKind, start: number, length: number);
        public kind(): TypeScript.SyntaxKind;
    }
}
declare module TypeScript.Formatting {
    class IndentationNodeContext {
        private _node;
        private _parent;
        private _fullStart;
        private _indentationAmount;
        private _childIndentationAmountDelta;
        private _depth;
        private _hasSkippedOrMissingTokenChild;
        constructor(parent: IndentationNodeContext, node: TypeScript.SyntaxNode, fullStart: number, indentationAmount: number, childIndentationAmountDelta: number);
        public parent(): IndentationNodeContext;
        public node(): TypeScript.SyntaxNode;
        public fullStart(): number;
        public fullWidth(): number;
        public start(): number;
        public end(): number;
        public indentationAmount(): number;
        public childIndentationAmountDelta(): number;
        public depth(): number;
        public kind(): TypeScript.SyntaxKind;
        public hasSkippedOrMissingTokenChild(): boolean;
        public clone(pool: Formatting.IndentationNodeContextPool): IndentationNodeContext;
        public update(parent: IndentationNodeContext, node: TypeScript.SyntaxNode, fullStart: number, indentationAmount: number, childIndentationAmountDelta: number): void;
    }
}
declare module TypeScript.Formatting {
    class IndentationNodeContextPool {
        private nodes;
        public getNode(parent: Formatting.IndentationNodeContext, node: TypeScript.SyntaxNode, fullStart: number, indentationLevel: number, childIndentationLevelDelta: number): Formatting.IndentationNodeContext;
        public releaseNode(node: Formatting.IndentationNodeContext, recursive?: boolean): void;
    }
}
declare module TypeScript.Formatting {
    class IndentationTrackingWalker extends TypeScript.SyntaxWalker {
        public options: FormattingOptions;
        private _position;
        private _parent;
        private _textSpan;
        private _snapshot;
        private _lastTriviaWasNewLine;
        private _indentationNodeContextPool;
        constructor(textSpan: TypeScript.TextSpan, sourceUnit: TypeScript.SourceUnitSyntax, snapshot: Formatting.ITextSnapshot, indentFirstToken: boolean, options: FormattingOptions);
        public position(): number;
        public parent(): Formatting.IndentationNodeContext;
        public textSpan(): TypeScript.TextSpan;
        public snapshot(): Formatting.ITextSnapshot;
        public indentationNodeContextPool(): Formatting.IndentationNodeContextPool;
        public forceIndentNextToken(tokenStart: number): void;
        public forceSkipIndentingNextToken(tokenStart: number): void;
        public indentToken(token: TypeScript.ISyntaxToken, indentationAmount: number, commentIndentationAmount: number): void;
        public visitTokenInSpan(token: TypeScript.ISyntaxToken): void;
        public visitToken(token: TypeScript.ISyntaxToken): void;
        public visitNode(node: TypeScript.SyntaxNode): void;
        private getTokenIndentationAmount(token);
        private getCommentIndentationAmount(token);
        private getNodeIndentation(node, newLineInsertedByFormatting?);
        private forceRecomputeIndentationOfParent(tokenStart, newLineAdded);
    }
}
declare module TypeScript.Formatting {
    class MultipleTokenIndenter extends Formatting.IndentationTrackingWalker {
        private _edits;
        constructor(textSpan: TypeScript.TextSpan, sourceUnit: TypeScript.SourceUnitSyntax, snapshot: Formatting.ITextSnapshot, indentFirstToken: boolean, options: FormattingOptions);
        public indentToken(token: TypeScript.ISyntaxToken, indentationAmount: number, commentIndentationAmount: number): void;
        public edits(): Formatting.TextEditInfo[];
        public recordEdit(position: number, length: number, replaceWith: string): void;
        private recordIndentationEditsForToken(token, indentationString, commentIndentationString);
        private recordIndentationEditsForSingleLineOrSkippedText(trivia, fullStart, indentationString);
        private recordIndentationEditsForWhitespace(trivia, fullStart, indentationString);
        private recordIndentationEditsForMultiLineComment(trivia, fullStart, indentationString, leadingWhiteSpace, firstLineAlreadyIndented);
        private recordIndentationEditsForSegment(segment, fullStart, indentationColumns, whiteSpaceColumnsInFirstSegment);
    }
}
declare module TypeScript.Formatting {
    class SingleTokenIndenter extends Formatting.IndentationTrackingWalker {
        private indentationAmount;
        private indentationPosition;
        constructor(indentationPosition: number, sourceUnit: TypeScript.SourceUnitSyntax, snapshot: Formatting.ITextSnapshot, indentFirstToken: boolean, options: FormattingOptions);
        static getIndentationAmount(position: number, sourceUnit: TypeScript.SourceUnitSyntax, snapshot: Formatting.ITextSnapshot, options: FormattingOptions): number;
        public indentToken(token: TypeScript.ISyntaxToken, indentationAmount: number, commentIndentationAmount: number): void;
    }
}
declare module TypeScript.Formatting {
    class Formatter extends Formatting.MultipleTokenIndenter {
        private previousTokenSpan;
        private previousTokenParent;
        private scriptHasErrors;
        private rulesProvider;
        private formattingRequestKind;
        private formattingContext;
        constructor(textSpan: TypeScript.TextSpan, sourceUnit: TypeScript.SourceUnitSyntax, indentFirstToken: boolean, options: FormattingOptions, snapshot: Formatting.ITextSnapshot, rulesProvider: Formatting.RulesProvider, formattingRequestKind: Formatting.FormattingRequestKind);
        static getEdits(textSpan: TypeScript.TextSpan, sourceUnit: TypeScript.SourceUnitSyntax, options: FormattingOptions, indentFirstToken: boolean, snapshot: Formatting.ITextSnapshot, rulesProvider: Formatting.RulesProvider, formattingRequestKind: Formatting.FormattingRequestKind): Formatting.TextEditInfo[];
        public visitTokenInSpan(token: TypeScript.ISyntaxToken): void;
        private processToken(token);
        private processTrivia(triviaList, fullStart);
        private findCommonParents(parent1, parent2);
        private formatPair(t1, t1Parent, t2, t2Parent);
        private getLineNumber(span);
        private trimWhitespaceInLineRange(startLine, endLine, token?);
        private trimWhitespace(line, token?);
        private RecordRuleEdits(rule, t1, t2);
    }
}
declare var debugObjectHost;
declare module Services {
    interface ICoreServicesHost {
        logger: TypeScript.ILogger;
    }
    class CoreServices {
        public host: ICoreServicesHost;
        constructor(host: ICoreServicesHost);
        public getPreProcessedFileInfo(fileName: string, sourceText: TypeScript.IScriptSnapshot): TypeScript.IPreProcessedFileInfo;
        public getDefaultCompilationSettings(): TypeScript.CompilationSettings;
        public dumpMemory(): string;
        public getMemoryInfo(): any[];
        public collectGarbage(): void;
    }
}
declare module Services {
    class HostCacheEntry {
        public fileName: string;
        private host;
        public version: number;
        public isOpen: boolean;
        public byteOrderMark: ByteOrderMark;
        private _sourceText;
        constructor(fileName: string, host: Services.ILanguageServiceHost, version: number, isOpen: boolean, byteOrderMark: ByteOrderMark);
        public getScriptSnapshot(): TypeScript.IScriptSnapshot;
    }
    class HostCache {
        public host: Services.ILanguageServiceHost;
        private map;
        constructor(host: Services.ILanguageServiceHost);
        public contains(fileName: string): boolean;
        public getHostFileName(fileName: string): string;
        public getFileNames(): string[];
        public getVersion(fileName: string): number;
        public isOpen(fileName: string): boolean;
        public getByteOrderMark(fileName: string): ByteOrderMark;
        public getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot;
    }
    class CompilerState {
        private host;
        private logger;
        private diagnostics;
        private compiler;
        private hostCache;
        private _compilationSettings;
        constructor(host: Services.ILanguageServiceHost);
        public compilationSettings(): TypeScript.CompilationSettings;
        public getHostFileName(fileName: string): string;
        public getFileNames(): string[];
        public getScript(fileName: string): TypeScript.Script;
        public getScripts(): TypeScript.Script[];
        public getScriptVersion(fileName: string): number;
        public getSemanticInfoChain(): TypeScript.SemanticInfoChain;
        private addCompilerUnit(compiler, fileName);
        public getHostCompilationSettings(): TypeScript.CompilationSettings;
        private createCompiler();
        public minimalRefresh(): void;
        public refresh(): void;
        private fullRefresh();
        private partialRefresh();
        public getDocument(fileName: string): TypeScript.Document;
        public getSyntacticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        public getSemanticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        private getAllSyntacticDiagnostics();
        private getAllSemanticDiagnostics();
        public getEmitOutput(fileName: string): Services.EmitOutput;
        private containErrors(diagnostics);
        public getScriptTextChangeRangeSinceVersion(fileName: string, lastKnownVersion: number): TypeScript.TextChangeRange;
        public getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot;
        public getDeclarationSymbolInformation(path: TypeScript.AstPath, document: TypeScript.Document): TypeScript.PullSymbolInfo;
        public getSymbolInformationFromPath(path: TypeScript.AstPath, document: TypeScript.Document): TypeScript.PullSymbolInfo;
        public getCallInformationFromPath(path: TypeScript.AstPath, document: TypeScript.Document): TypeScript.PullCallSymbolInfo;
        public getVisibleMemberSymbolsFromPath(path: TypeScript.AstPath, document: TypeScript.Document): TypeScript.PullVisibleSymbolsInfo;
        public getVisibleDeclsFromPath(path: TypeScript.AstPath, document: TypeScript.Document): TypeScript.PullDecl[];
        public geContextualMembersFromPath(path: TypeScript.AstPath, document: TypeScript.Document): TypeScript.PullVisibleSymbolsInfo;
        public pullGetDeclInformation(decl: TypeScript.PullDecl, path: TypeScript.AstPath, document: TypeScript.Document): TypeScript.PullSymbolInfo;
        public getTopLevelDeclarations(fileName: string): TypeScript.PullDecl[];
        private updateCompilerUnit(compiler, fileName);
        private getDocCommentsOfDecl(decl);
        private getDocCommentArray(symbol);
        static getDefaultConstructorSymbolForDocComments(classSymbol: TypeScript.PullTypeSymbol);
        public getDocComments(symbol: TypeScript.PullSymbol, useConstructorAsClass?: boolean): string;
    }
}
declare module Services {
    class CompletionHelpers {
        static filterContextualMembersList(contextualMemberSymbols: TypeScript.PullSymbol[], existingMembers: TypeScript.PullVisibleSymbolsInfo): TypeScript.PullSymbol[];
        static isRightOfDot(path: TypeScript.AstPath, position: number): boolean;
        static isCompletionListBlocker(sourceUnit: TypeScript.SourceUnitSyntax, position: number): boolean;
        static getContainingObjectLiteralApplicableForCompletion(sourceUnit: TypeScript.SourceUnitSyntax, position: number): TypeScript.PositionedElement;
        static isIdentifierDefinitionLocation(sourceUnit: TypeScript.SourceUnitSyntax, position: number): boolean;
        static getNonIdentifierCompleteTokenOnLeft(sourceUnit: TypeScript.SourceUnitSyntax, position: number): TypeScript.PositionedToken;
        static isRightOfIllegalDot(sourceUnit: TypeScript.SourceUnitSyntax, position: number): boolean;
        static getValidCompletionEntryDisplayName(displayName: string, languageVersion: TypeScript.LanguageVersion): string;
    }
}
declare module Services {
    class KeywordCompletions {
        private static keywords;
        private static keywordCompletions;
        static getKeywordCompltions(): Services.ResolvedCompletionEntry[];
    }
}
declare module Services {
    interface IPartiallyWrittenTypeArgumentListInformation {
        genericIdentifer: TypeScript.PositionedToken;
        lessThanToken: TypeScript.PositionedToken;
        argumentIndex: number;
    }
    class SignatureInfoHelpers {
        static isInPartiallyWrittenTypeArgumentList(syntaxTree: TypeScript.SyntaxTree, position: number): IPartiallyWrittenTypeArgumentListInformation;
        static getSignatureInfoFromSignatureSymbol(symbol: TypeScript.PullSymbol, signatures: TypeScript.PullSignatureSymbol[], enclosingScopeSymbol: TypeScript.PullSymbol, compilerState: Services.CompilerState): Services.FormalSignatureItemInfo[];
        static getSignatureInfoFromGenericSymbol(symbol: TypeScript.PullSymbol, enclosingScopeSymbol: TypeScript.PullSymbol, compilerState: Services.CompilerState): Services.FormalSignatureItemInfo[];
        static getActualSignatureInfoFromCallExpression(ast: TypeScript.ICallExpression, caretPosition: number, typeParameterInformation: IPartiallyWrittenTypeArgumentListInformation): Services.ActualSignatureInfo;
        static getActualSignatureInfoFromPartiallyWritenGenericExpression(caretPosition: number, typeParameterInformation: IPartiallyWrittenTypeArgumentListInformation): Services.ActualSignatureInfo;
        static isSignatureHelpBlocker(sourceUnit: TypeScript.SourceUnitSyntax, position: number): boolean;
        static isTargetOfObjectCreationExpression(positionedToken: TypeScript.PositionedToken): boolean;
        private static moveBackUpTillMatchingTokenKind(token, tokenKind, matchingTokenKind);
    }
}
declare module Services {
    interface CachedCompletionEntryDetails extends Services.CompletionEntryDetails {
        isResolved(): boolean;
    }
    class ResolvedCompletionEntry implements CachedCompletionEntryDetails {
        public name: string;
        public kind: string;
        public kindModifiers: string;
        public type: string;
        public fullSymbolName: string;
        public docComment: string;
        constructor(name: string, kind: string, kindModifiers: string, type: string, fullSymbolName: string, docComment: string);
        public isResolved(): boolean;
    }
    class DeclReferenceCompletionEntry implements CachedCompletionEntryDetails {
        public name: string;
        public kind: string;
        public kindModifiers: string;
        public decl: TypeScript.PullDecl;
        public type: string;
        public fullSymbolName: string;
        public docComment: string;
        private hasBeenResolved;
        constructor(name: string, kind: string, kindModifiers: string, decl: TypeScript.PullDecl);
        public isResolved(): boolean;
        public resolve(type: string, fullSymbolName: string, docComments: string): void;
    }
    class CompletionSession {
        public fileName: string;
        public position: number;
        public entries: TypeScript.IdentiferNameHashTable<CachedCompletionEntryDetails>;
        constructor(fileName: string, position: number, entries: TypeScript.IdentiferNameHashTable<CachedCompletionEntryDetails>);
    }
}
declare module Services {
    class LanguageService implements Services.ILanguageService {
        public host: Services.ILanguageServiceHost;
        private logger;
        private compilerState;
        private formattingRulesProvider;
        private currentFileName;
        private currentFileVersion;
        private currentFileSyntaxTree;
        private activeCompletionSession;
        constructor(host: Services.ILanguageServiceHost);
        public refresh(): void;
        private minimalRefresh();
        public getReferencesAtPosition(fileName: string, pos: number): Services.ReferenceEntry[];
        public getOccurrencesAtPosition(fileName: string, pos: number): Services.ReferenceEntry[];
        public getImplementorsAtPosition(fileName: string, pos: number): Services.ReferenceEntry[];
        public getOverrides(container: TypeScript.PullTypeSymbol, memberSym: TypeScript.PullSymbol): TypeScript.PullTypeSymbol[];
        private getImplementorsInFile(fileName, symbol);
        private getReferencesInFile(fileName, symbol);
        private isWriteAccess(current, parent);
        private getPossibleSymbolReferencePositions(fileName, symbolName);
        public getSignatureAtPosition(fileName: string, position: number): Services.SignatureInfo;
        private getTypeParameterSignatureFromPartiallyWrittenExpression(document, position, genericTypeArgumentListInfo);
        public getDefinitionAtPosition(fileName: string, position: number): Services.DefinitionInfo[];
        public getNavigateToItems(searchValue: string): Services.NavigateToItem[];
        public getSyntacticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        public getSemanticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        public getEmitOutput(fileName: string): Services.EmitOutput;
        private getAstPathToPosition(script, pos, useTrailingTriviaAsLimChar?);
        private getFullNameOfSymbol(symbol, enclosingScopeSymbol);
        private getTypeInfoEligiblePath(fileName, position, isConstructorValidPosition);
        public getTypeAtPosition(fileName: string, position: number): Services.TypeInfo;
        public getCompletionsAtPosition(fileName: string, position: number, isMemberCompletion: boolean): Services.CompletionInfo;
        private getCompletionEntriesFromSymbols(symbolInfo, result);
        private getCompletionEntriesFromDecls(decls, result);
        private getCompletionEntriesForKeywords(keywords, result);
        public getCompletionEntryDetails(fileName: string, position: number, entryName: string): Services.CompletionEntryDetails;
        private isLocal(symbol);
        private getModuleOrEnumKind(symbol);
        private mapPullElementKind(kind, symbol?, useConstructorAsClass?, varIsFunction?, functionIsConstructor?);
        private getScriptElementKindModifiers(symbol);
        private getScriptElementKindModifiersFromFlgas(flags);
        public getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): Services.SpanInfo;
        public getBreakpointStatementAtPosition(fileName: string, pos: number): Services.SpanInfo;
        public getFormattingEditsForRange(fileName: string, minChar: number, limChar: number, options: Services.FormatCodeOptions): Services.TextEdit[];
        public getFormattingEditsForDocument(fileName: string, minChar: number, limChar: number, options: Services.FormatCodeOptions): Services.TextEdit[];
        public getFormattingEditsOnPaste(fileName: string, minChar: number, limChar: number, options: Services.FormatCodeOptions): Services.TextEdit[];
        public getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: Services.FormatCodeOptions): Services.TextEdit[];
        private getFormattingManager(fileName, options);
        public getOutliningRegions(fileName: string): TypeScript.TextSpan[];
        public getIndentationAtPosition(fileName: string, position: number, editorOptions: Services.EditorOptions): number;
        public getBraceMatchingAtPosition(fileName: string, position: number): TypeScript.TextSpan[];
        public getScriptLexicalStructure(fileName: string): Services.NavigateToItem[];
        public getSyntaxTree(fileName: string): TypeScript.SyntaxTree;
        private getSyntaxTreeInternal(fileName);
        private createSyntaxTree(fileName);
        private updateSyntaxTree(fileName, previousSyntaxTree, previousFileVersion);
    }
}
declare module Services {
    class FindReferenceHelpers {
        static getCorrectASTForReferencedSymbolName(matchingAST: TypeScript.AST, symbolName: string): TypeScript.AST;
        static compareSymbolsForLexicalIdentity(firstSymbol: TypeScript.PullSymbol, secondSymbol: TypeScript.PullSymbol): boolean;
        private static checkSymbolsForDeclarationEquality(firstSymbol, secondSymbol);
        private static declarationsAreSameOrParents(firstDecl, secondDecl);
    }
}
declare module Services {
    interface IScriptSnapshotShim {
        getText(start: number, end: number): string;
        getLength(): number;
        getLineStartPositions(): string;
        getTextChangeRangeSinceVersion(scriptVersion: number): string;
    }
    interface ILanguageServiceShimHost extends TypeScript.ILogger {
        getCompilationSettings(): string;
        getScriptFileNames(): string;
        getScriptVersion(fileName: string): number;
        getScriptIsOpen(fileName: string): boolean;
        getScriptByteOrderMark(fileName: string): number;
        getScriptSnapshot(fileName: string): IScriptSnapshotShim;
        resolveRelativePath(path: string, directory: string): string;
        fileExists(path: string): boolean;
        directoryExists(path: string): boolean;
        getParentDirectory(path: string): string;
        getDiagnosticsObject(): Services.ILanguageServicesDiagnostics;
        getLocalizedDiagnosticMessages(): string;
    }
    interface IShimFactory {
        registerShim(shim: IShim): void;
        unregisterShim(shim: IShim): void;
    }
    interface IShim {
        dispose(dummy: any): void;
    }
    class ShimBase implements IShim {
        private factory;
        constructor(factory: IShimFactory);
        public dispose(dummy: any): void;
    }
    interface ILanguageServiceShim extends IShim {
        languageService: Services.ILanguageService;
        dispose(dummy: any): void;
        refresh(throwOnError: boolean): void;
        getSyntacticDiagnostics(fileName: string): string;
        getSemanticDiagnostics(fileName: string): string;
        getCompletionsAtPosition(fileName: string, position: number, isMemberCompletion: boolean): string;
        getCompletionEntryDetails(fileName: string, position: number, entryName: string): string;
        getTypeAtPosition(fileName: string, position: number): string;
        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): string;
        getBreakpointStatementAtPosition(fileName: string, position: number): string;
        getSignatureAtPosition(fileName: string, position: number): string;
        getDefinitionAtPosition(fileName: string, position: number): string;
        getReferencesAtPosition(fileName: string, position: number): string;
        getOccurrencesAtPosition(fileName: string, position: number): string;
        getImplementorsAtPosition(fileName: string, position: number): string;
        getNavigateToItems(searchValue: string): string;
        getScriptLexicalStructure(fileName: string): string;
        getOutliningRegions(fileName: string): string;
        getBraceMatchingAtPosition(fileName: string, position: number): string;
        getIndentationAtPosition(fileName: string, position: number, options: string): string;
        getFormattingEditsForRange(fileName: string, minChar: number, limChar: number, options: string): string;
        getFormattingEditsForDocument(fileName: string, minChar: number, limChar: number, options: string): string;
        getFormattingEditsOnPaste(fileName: string, minChar: number, limChar: number, options: string): string;
        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: string): string;
        getEmitOutput(fileName: string): string;
    }
    class LanguageServiceShimHostAdapter implements Services.ILanguageServiceHost {
        private shimHost;
        constructor(shimHost: ILanguageServiceShimHost);
        public information(): boolean;
        public debug(): boolean;
        public warning(): boolean;
        public error(): boolean;
        public fatal(): boolean;
        public log(s: string): void;
        public getCompilationSettings(): TypeScript.CompilationSettings;
        public getScriptFileNames(): string[];
        public getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot;
        public getScriptVersion(fileName: string): number;
        public getScriptIsOpen(fileName: string): boolean;
        public getScriptByteOrderMark(fileName: string): ByteOrderMark;
        public getDiagnosticsObject(): Services.ILanguageServicesDiagnostics;
        public getLocalizedDiagnosticMessages(): any;
        public resolveRelativePath(path: string, directory: string): string;
        public fileExists(path: string): boolean;
        public directoryExists(path: string): boolean;
        public getParentDirectory(path: string): string;
    }
    function simpleForwardCall(logger: TypeScript.ILogger, actionDescription: string, action: () => any): any;
    function forwardJSONCall(logger: TypeScript.ILogger, actionDescription: string, action: () => any): string;
    class LanguageServiceShim extends ShimBase implements ILanguageServiceShim {
        private host;
        public languageService: Services.ILanguageService;
        private logger;
        constructor(factory: IShimFactory, host: ILanguageServiceShimHost, languageService: Services.ILanguageService);
        public forwardJSONCall(actionDescription: string, action: () => any): string;
        public dispose(dummy: any): void;
        public refresh(throwOnError: boolean): void;
        private static realizeDiagnosticCategory(category);
        private static realizeDiagnostic(diagnostic);
        public getSyntacticDiagnostics(fileName: string): string;
        public getSemanticDiagnostics(fileName: string): string;
        public getTypeAtPosition(fileName: string, position: number): string;
        public getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): string;
        public getBreakpointStatementAtPosition(fileName: string, position: number): string;
        public getSignatureAtPosition(fileName: string, position: number): string;
        public getDefinitionAtPosition(fileName: string, position: number): string;
        public getBraceMatchingAtPosition(fileName: string, position: number): string;
        public getIndentationAtPosition(fileName: string, position: number, options: string): string;
        public getReferencesAtPosition(fileName: string, position: number): string;
        public getOccurrencesAtPosition(fileName: string, position: number): string;
        public getImplementorsAtPosition(fileName: string, position: number): string;
        public getCompletionsAtPosition(fileName: string, position: number, isMemberCompletion: boolean): string;
        public getCompletionEntryDetails(fileName: string, position: number, entryName: string): string;
        public getFormattingEditsForRange(fileName: string, minChar: number, limChar: number, options: string): string;
        public getFormattingEditsForDocument(fileName: string, minChar: number, limChar: number, options: string): string;
        public getFormattingEditsOnPaste(fileName: string, minChar: number, limChar: number, options: string): string;
        public getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: string): string;
        public getNavigateToItems(searchValue: string): string;
        public getScriptLexicalStructure(fileName: string): string;
        public getOutliningRegions(fileName: string): string;
        public getEmitOutput(fileName: string): string;
        private _navigateToItemsToString(items);
    }
    class ClassifierShim extends ShimBase {
        public host: Services.IClassifierHost;
        public classifier: Services.Classifier;
        constructor(factory: IShimFactory, host: Services.IClassifierHost);
        public getClassificationsForLine(text: string, lexState: Services.EndOfLineState): string;
    }
    class CoreServicesShim extends ShimBase {
        public host: Services.ICoreServicesHost;
        public logger: TypeScript.ILogger;
        public services: Services.CoreServices;
        constructor(factory: IShimFactory, host: Services.ICoreServicesHost);
        private forwardJSONCall(actionDescription, action);
        public getPreProcessedFileInfo(fileName: string, sourceText: TypeScript.IScriptSnapshot): string;
        public getDefaultCompilationSettings(): string;
        public dumpMemory(dummy: any): string;
        public getMemoryInfo(dummy: any): string;
    }
}
declare module Services {
    class OutliningElementsCollector extends TypeScript.DepthLimitedWalker {
        private static MaximumDepth;
        private elements;
        constructor();
        public visitClassDeclaration(node: TypeScript.ClassDeclarationSyntax): void;
        public visitInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax): void;
        public visitModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax): void;
        public visitEnumDeclaration(node: TypeScript.EnumDeclarationSyntax): void;
        public visitFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax): void;
        public visitFunctionExpression(node: TypeScript.FunctionExpressionSyntax): void;
        public visitConstructorDeclaration(node: TypeScript.ConstructorDeclarationSyntax): void;
        public visitMemberFunctionDeclaration(node: TypeScript.MemberFunctionDeclarationSyntax): void;
        public visitGetMemberAccessorDeclaration(node: TypeScript.GetMemberAccessorDeclarationSyntax): void;
        public visitSetMemberAccessorDeclaration(node: TypeScript.SetMemberAccessorDeclarationSyntax): void;
        private addOutlineRange(node, startElement, endElement);
        static collectElements(node: TypeScript.SourceUnitSyntax): TypeScript.TextSpan[];
    }
}
declare module Services {
    class BraceMatcher {
        static getMatchSpans(syntaxTree: TypeScript.SyntaxTree, position: number): TypeScript.TextSpan[];
        private static getMatchingCloseBrace(currentToken, position, result);
        private static getMatchingOpenBrace(currentToken, position, result);
        private static getMatchingCloseBraceTokenKind(positionedElement);
        private static getMatchingOpenBraceTokenKind(positionedElement);
    }
}
declare module Services {
    class Indenter {
        static getIndentation(node: TypeScript.SourceUnitSyntax, soruceText: TypeScript.IScriptSnapshot, position: number, editorOptions: Services.EditorOptions): number;
        private static belongsToBracket(sourceText, token, position);
        private static isInContainerNode(parent, element);
        private static getCustomListIndentation(list, element);
        private static getListItemIndentation(list, elementIndex);
    }
}
declare module Services.Breakpoints {
    function getBreakpointLocation(syntaxTree: TypeScript.SyntaxTree, askedPos: number): Services.SpanInfo;
}
declare module Services {
    class GetScriptLexicalStructureWalker extends TypeScript.PositionTrackingWalker {
        private items;
        private fileName;
        private nameStack;
        private kindStack;
        private currentMemberVariableDeclaration;
        private currentVariableStatement;
        private currentInterfaceDeclaration;
        constructor(items: Services.NavigateToItem[], fileName: string);
        private createItem(node, modifiers, kind, name);
        private getKindModifiers(modifiers);
        public visitModuleDeclaration(node: TypeScript.ModuleDeclarationSyntax): void;
        private visitModuleDeclarationWorker(node, names, nameIndex);
        private getModuleNames(node);
        private getModuleNamesHelper(name, result);
        public visitClassDeclaration(node: TypeScript.ClassDeclarationSyntax): void;
        public visitInterfaceDeclaration(node: TypeScript.InterfaceDeclarationSyntax): void;
        public visitObjectType(node: TypeScript.ObjectTypeSyntax): void;
        public visitEnumDeclaration(node: TypeScript.EnumDeclarationSyntax): void;
        public visitConstructorDeclaration(node: TypeScript.ConstructorDeclarationSyntax): void;
        public visitMemberFunctionDeclaration(node: TypeScript.MemberFunctionDeclarationSyntax): void;
        public visitGetMemberAccessorDeclaration(node: TypeScript.GetMemberAccessorDeclarationSyntax): void;
        public visitSetMemberAccessorDeclaration(node: TypeScript.SetMemberAccessorDeclarationSyntax): void;
        public visitMemberVariableDeclaration(node: TypeScript.MemberVariableDeclarationSyntax): void;
        public visitVariableStatement(node: TypeScript.VariableStatementSyntax): void;
        public visitVariableDeclarator(node: TypeScript.VariableDeclaratorSyntax): void;
        public visitIndexSignature(node: TypeScript.IndexSignatureSyntax): void;
        public visitEnumElement(node: TypeScript.EnumElementSyntax): void;
        public visitCallSignature(node: TypeScript.CallSignatureSyntax): void;
        public visitConstructSignature(node: TypeScript.ConstructSignatureSyntax): void;
        public visitMethodSignature(node: TypeScript.MethodSignatureSyntax): void;
        public visitPropertySignature(node: TypeScript.PropertySignatureSyntax): void;
        public visitFunctionDeclaration(node: TypeScript.FunctionDeclarationSyntax): void;
        public visitBlock(node: TypeScript.BlockSyntax): void;
        public visitIfStatement(node: TypeScript.IfStatementSyntax): void;
        public visitExpressionStatement(node: TypeScript.ExpressionStatementSyntax): void;
        public visitThrowStatement(node: TypeScript.ThrowStatementSyntax): void;
        public visitReturnStatement(node: TypeScript.ReturnStatementSyntax): void;
        public visitSwitchStatement(node: TypeScript.SwitchStatementSyntax): void;
        public visitWithStatement(node: TypeScript.WithStatementSyntax): void;
        public visitTryStatement(node: TypeScript.TryStatementSyntax): void;
        public visitLabeledStatement(node: TypeScript.LabeledStatementSyntax): void;
    }
}
declare module Services {
    function copyDataObject(dst: any, src: any): any;
    function compareDataObjects(dst: any, src: any): boolean;
    class TypeScriptServicesFactory implements Services.IShimFactory {
        private _shims;
        public createPullLanguageService(host: Services.ILanguageServiceHost): Services.ILanguageService;
        public createLanguageServiceShim(host: Services.ILanguageServiceShimHost): Services.ILanguageServiceShim;
        public createClassifier(host: Services.IClassifierHost): Services.Classifier;
        public createClassifierShim(host: Services.IClassifierHost): Services.ClassifierShim;
        public createCoreServices(host: Services.ICoreServicesHost): Services.CoreServices;
        public createCoreServicesShim(host: Services.ICoreServicesHost): Services.CoreServicesShim;
        public close(): void;
        public registerShim(shim: Services.IShim): void;
        public unregisterShim(shim: Services.IShim): void;
    }
}
declare module Services {
    interface ILanguageServicesDiagnostics {
        log(content: string): void;
    }
    interface ICompilerDiagnostics {
        isLoggingEdits(): boolean;
    }
    class CompilerDiagnostics implements ICompilerDiagnostics {
        private host;
        private openEditTag;
        private closeEditTag;
        constructor(host: Services.ILanguageServiceHost);
        public isLoggingEdits(): boolean;
    }
    class DiagnosticService implements Services.ILanguageService {
        private internal;
        private host;
        private diagnostics;
        constructor(internal: Services.ILanguageService, host: Services.ILanguageServiceHost);
        private writeFile(content);
        public refresh(): void;
        public getSyntacticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        public getSemanticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        public getCompletionsAtPosition(fileName: string, pos: number, isMemberCompletion: boolean): Services.CompletionInfo;
        public getCompletionEntryDetails(fileName: string, position: number, entryName: string): Services.CompletionEntryDetails;
        public getTypeAtPosition(fileName: string, pos: number): Services.TypeInfo;
        public getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): Services.SpanInfo;
        public getBreakpointStatementAtPosition(fileName: string, pos: number): Services.SpanInfo;
        public getSignatureAtPosition(fileName: string, pos: number): Services.SignatureInfo;
        public getDefinitionAtPosition(fileName: string, pos: number): Services.DefinitionInfo[];
        public getReferencesAtPosition(fileName: string, pos: number): Services.ReferenceEntry[];
        public getOccurrencesAtPosition(fileName: string, pos: number): Services.ReferenceEntry[];
        public getImplementorsAtPosition(fileName: string, pos: number): Services.ReferenceEntry[];
        public getNavigateToItems(searchValue: string): Services.NavigateToItem[];
        public getScriptLexicalStructure(fileName: string): Services.NavigateToItem[];
        public getOutliningRegions(fileName: string): TypeScript.TextSpan[];
        public getFormattingEditsForRange(fileName: string, minChar: number, limChar: number, options: Services.FormatCodeOptions): Services.TextEdit[];
        public getFormattingEditsForDocument(fileName: string, minChar: number, limChar: number, options: Services.FormatCodeOptions): Services.TextEdit[];
        public getFormattingEditsOnPaste(fileName: string, minChar: number, limChar: number, options: Services.FormatCodeOptions): Services.TextEdit[];
        public getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: Services.FormatCodeOptions): Services.TextEdit[];
        public getBraceMatchingAtPosition(fileName: string, position: number): TypeScript.TextSpan[];
        public getIndentationAtPosition(fileName: string, position: number, options: Services.EditorOptions): number;
        public getEmitOutput(fileName: string): Services.EmitOutput;
        public getSyntaxTree(fileName: string): TypeScript.SyntaxTree;
        private stringify(object);
    }
}
declare module Services {
    interface ILanguageServiceHost extends TypeScript.ILogger, TypeScript.IReferenceResolverHost {
        getCompilationSettings(): TypeScript.CompilationSettings;
        getScriptFileNames(): string[];
        getScriptVersion(fileName: string): number;
        getScriptIsOpen(fileName: string): boolean;
        getScriptByteOrderMark(fileName: string): ByteOrderMark;
        getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot;
        getDiagnosticsObject(): Services.ILanguageServicesDiagnostics;
        getLocalizedDiagnosticMessages(): any;
    }
    interface ILanguageService {
        refresh(): void;
        getSyntacticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        getSemanticDiagnostics(fileName: string): TypeScript.Diagnostic[];
        getCompletionsAtPosition(fileName: string, position: number, isMemberCompletion: boolean): CompletionInfo;
        getCompletionEntryDetails(fileName: string, position: number, entryName: string): CompletionEntryDetails;
        getTypeAtPosition(fileName: string, position: number): TypeInfo;
        getNameOrDottedNameSpan(fileName: string, startPos: number, endPos: number): SpanInfo;
        getBreakpointStatementAtPosition(fileName: string, position: number): SpanInfo;
        getSignatureAtPosition(fileName: string, position: number): SignatureInfo;
        getDefinitionAtPosition(fileName: string, position: number): DefinitionInfo[];
        getReferencesAtPosition(fileName: string, position: number): ReferenceEntry[];
        getOccurrencesAtPosition(fileName: string, position: number): ReferenceEntry[];
        getImplementorsAtPosition(fileName: string, position: number): ReferenceEntry[];
        getNavigateToItems(searchValue: string): NavigateToItem[];
        getScriptLexicalStructure(fileName: string): NavigateToItem[];
        getOutliningRegions(fileName: string): TypeScript.TextSpan[];
        getBraceMatchingAtPosition(fileName: string, position: number): TypeScript.TextSpan[];
        getIndentationAtPosition(fileName: string, position: number, options: EditorOptions): number;
        getFormattingEditsForRange(fileName: string, minChar: number, limChar: number, options: FormatCodeOptions): TextEdit[];
        getFormattingEditsForDocument(fileName: string, minChar: number, limChar: number, options: FormatCodeOptions): TextEdit[];
        getFormattingEditsOnPaste(fileName: string, minChar: number, limChar: number, options: FormatCodeOptions): TextEdit[];
        getFormattingEditsAfterKeystroke(fileName: string, position: number, key: string, options: FormatCodeOptions): TextEdit[];
        getEmitOutput(fileName: string): EmitOutput;
        getSyntaxTree(fileName: string): TypeScript.SyntaxTree;
    }
    function logInternalError(logger: TypeScript.ILogger, err: Error): void;
    class ReferenceEntry {
        public fileName: string;
        public minChar: number;
        public limChar: number;
        public isWriteAccess: boolean;
        constructor(fileName: string, minChar: number, limChar: number, isWriteAccess: boolean);
    }
    class NavigateToItem {
        public name: string;
        public kind: string;
        public kindModifiers: string;
        public matchKind: string;
        public fileName: string;
        public minChar: number;
        public limChar: number;
        public containerName: string;
        public containerKind: string;
    }
    class NavigateToContext {
        public options: TypeScript.AstWalkOptions;
        public fileName: string;
        public containerKinds: string[];
        public containerASTs: TypeScript.AST[];
        public path: TypeScript.AstPath;
        public result: NavigateToItem[];
    }
    class TextEdit {
        public minChar: number;
        public limChar: number;
        public text: string;
        constructor(minChar: number, limChar: number, text: string);
        static createInsert(pos: number, text: string): TextEdit;
        static createDelete(minChar: number, limChar: number): TextEdit;
        static createReplace(minChar: number, limChar: number, text: string): TextEdit;
    }
    class EditorOptions {
        public IndentSize: number;
        public TabSize: number;
        public NewLineCharacter: string;
        public ConvertTabsToSpaces: boolean;
        static clone(objectToClone: EditorOptions): EditorOptions;
    }
    class FormatCodeOptions extends EditorOptions {
        public InsertSpaceAfterCommaDelimiter: boolean;
        public InsertSpaceAfterSemicolonInForStatements: boolean;
        public InsertSpaceBeforeAndAfterBinaryOperators: boolean;
        public InsertSpaceAfterKeywordsInControlFlowStatements: boolean;
        public InsertSpaceAfterFunctionKeywordForAnonymousFunctions: boolean;
        public InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: boolean;
        public PlaceOpenBraceOnNewLineForFunctions: boolean;
        public PlaceOpenBraceOnNewLineForControlBlocks: boolean;
        static clone(objectToClone: FormatCodeOptions): FormatCodeOptions;
    }
    class DefinitionInfo {
        public fileName: string;
        public minChar: number;
        public limChar: number;
        public kind: string;
        public name: string;
        public containerKind: string;
        public containerName: string;
        constructor(fileName: string, minChar: number, limChar: number, kind: string, name: string, containerKind: string, containerName: string);
    }
    class TypeInfo {
        public memberName: TypeScript.MemberName;
        public docComment: string;
        public fullSymbolName: string;
        public kind: string;
        public minChar: number;
        public limChar: number;
        constructor(memberName: TypeScript.MemberName, docComment: string, fullSymbolName: string, kind: string, minChar: number, limChar: number);
    }
    class SpanInfo {
        public minChar: number;
        public limChar: number;
        public text: string;
        constructor(minChar: number, limChar: number, text?: string);
    }
    class SignatureInfo {
        public actual: ActualSignatureInfo;
        public formal: FormalSignatureItemInfo[];
        public activeFormal: number;
    }
    class FormalSignatureItemInfo {
        public signatureInfo: string;
        public typeParameters: FormalTypeParameterInfo[];
        public parameters: FormalParameterInfo[];
        public docComment: string;
    }
    class FormalTypeParameterInfo {
        public name: string;
        public docComment: string;
        public minChar: number;
        public limChar: number;
    }
    class FormalParameterInfo {
        public name: string;
        public isVariable: boolean;
        public docComment: string;
        public minChar: number;
        public limChar: number;
    }
    class ActualSignatureInfo {
        public parameterMinChar: number;
        public parameterLimChar: number;
        public currentParameterIsTypeParameter: boolean;
        public currentParameter: number;
    }
    class CompletionInfo {
        public maybeInaccurate: boolean;
        public isMemberCompletion: boolean;
        public entries: CompletionEntry[];
    }
    interface CompletionEntry {
        name: string;
        kind: string;
        kindModifiers: string;
    }
    interface CompletionEntryDetails {
        name: string;
        kind: string;
        kindModifiers: string;
        type: string;
        fullSymbolName: string;
        docComment: string;
    }
    class ScriptElementKind {
        static unknown: string;
        static keyword: string;
        static scriptElement: string;
        static moduleElement: string;
        static classElement: string;
        static interfaceElement: string;
        static enumElement: string;
        static variableElement: string;
        static localVariableElement: string;
        static functionElement: string;
        static localFunctionElement: string;
        static memberFunctionElement: string;
        static memberGetAccessorElement: string;
        static memberSetAccessorElement: string;
        static memberVariableElement: string;
        static constructorImplementationElement: string;
        static callSignatureElement: string;
        static indexSignatureElement: string;
        static constructSignatureElement: string;
        static parameterElement: string;
        static typeParameterElement: string;
        static primitiveType: string;
    }
    class ScriptElementKindModifier {
        static none: string;
        static publicMemberModifier: string;
        static privateMemberModifier: string;
        static exportedModifier: string;
        static ambientModifier: string;
        static staticModifier: string;
    }
    class MatchKind {
        static none: string;
        static exact: string;
        static subString: string;
        static prefix: string;
    }
    class DiagnosticCategory {
        static none: string;
        static error: string;
        static warning: string;
        static message: string;
    }
    class ScriptSyntaxASTState {
        public version: number;
        public syntaxTree: TypeScript.SyntaxTree;
        public fileName: string;
        constructor();
    }
    class EmitOutput {
        public outputFiles: IOutputFile[];
        public diagnostics: TypeScript.Diagnostic[];
    }
    interface IOutputFile {
        name: string;
        writeByteOrderMark: boolean;
        text: string;
    }
}
declare module Lint {
    class LanguageServiceHost extends TypeScript.NullLogger implements Services.ILanguageServiceHost {
        private compilationSettings;
        private diagnostics;
        private fileName;
        private scriptSnapshot;
        constructor(fileName: string, contents: string);
        public getCompilationSettings(): TypeScript.CompilationSettings;
        public getScriptFileNames(): string[];
        public getScriptVersion(fileName: string): number;
        public getScriptIsOpen(fileName: string): boolean;
        public getScriptSnapshot(fileName: string): TypeScript.IScriptSnapshot;
        public getScriptByteOrderMark(fileName: string): ByteOrderMark;
        public getDiagnosticsObject(): Services.ILanguageServicesDiagnostics;
        public getLocalizedDiagnosticMessages(): any;
        public resolveRelativePath(path: string, directory: string): string;
        public fileExists(path: string): boolean;
        public directoryExists(path: string): boolean;
        public getParentDirectory(path: string): string;
        private createCompilationSettings();
    }
}
declare module Lint.Rules {
    class AbstractRule implements Lint.Rule {
        private value;
        constructor(value: any);
        public getOptions(): any[];
        public apply(syntaxTree: TypeScript.SyntaxTree): Lint.RuleFailure[];
        public applyWithWalker(walker: Lint.RuleWalker): Lint.RuleFailure[];
        public isEnabled(): boolean;
    }
}
declare module Lint.Formatters {
    class AbstractFormatter implements Lint.Formatter {
        public format(failures: Lint.RuleFailure[]): string;
    }
}
declare module Lint {
    class ScopeAwareRuleWalker<T> extends Lint.RuleWalker {
        private scopeStack;
        constructor(syntaxTree: TypeScript.SyntaxTree, options?: any);
        public visitNode(node: TypeScript.SyntaxNode): void;
        public createScope(): T;
        public getCurrentScope(): T;
        private isScopeBoundary(node);
    }
}
declare module Lint {
    interface RuleWalkerState {
        position: number;
        token: TypeScript.ISyntaxToken;
    }
    class StateAwareRuleWalker extends Lint.RuleWalker {
        private lastState;
        public visitToken(token: TypeScript.ISyntaxToken): void;
        public getLastState(): RuleWalkerState;
    }
}
declare module Lint {
    interface LintResult {
        failureCount: number;
        format: string;
        output: string;
    }
    class Linter {
        private fileName;
        private source;
        private options;
        constructor(fileName: string, source: string, options: any);
        public lint(): LintResult;
        private getRelativePath(directory);
        private containsRule(rules, rule);
    }
}
