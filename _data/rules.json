[
  {
    "ruleName": "adjacent-overload-signatures",
    "description": "Enforces function overloads to be consecutive.",
    "optionsDescription": "\nIf `ignore-accessors` is specified, then getters and setters are not considered to be overloads\nof function with the same signature.",
    "options": {
      "type": "object",
      "properties": {
        "ignore-accessors": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "OPTION_IGNORE_ACCESSORS": true
        }
      ]
    ],
    "rationale": "Improves readability and organization by grouping naturally related items together.",
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "align",
    "description": "Enforces vertical alignment.",
    "hasFix": true,
    "rationale": "\nHelps maintain a readable, consistent style in your codebase.\n\nConsistent alignment for code statements helps keep code readable and clear.\nStatements misaligned from the standard can be harder to read and understand.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"parameters\"` checks alignment of function parameters.\n* `\"arguments\"` checks alignment of function call arguments.\n* `\"statements\"` checks alignment of statements.\n* `\"members\"` checks alignment of members of classes, interfaces, type literal, object literals and\nobject destructuring.\n* `\"elements\"` checks alignment of elements of array literals, array destructuring and tuple types.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "arguments",
          "elements",
          "members",
          "parameters",
          "statements"
        ]
      },
      "minLength": 1,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "parameters",
        "statements"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "array-type",
    "description": "Requires using either 'T[]' or 'Array<T>' for arrays.",
    "hasFix": true,
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `\"array\"` enforces use of `T[]` for all types T.\n* `\"generic\"` enforces use of `Array<T>` for all types T.\n* `\"array-simple\"` enforces use of `T[]` if `T` is a simple type (primitive or type reference).",
    "options": {
      "type": "string",
      "enum": [
        "array",
        "generic",
        "array-simple"
      ]
    },
    "optionExamples": [
      [
        true,
        "array"
      ],
      [
        true,
        "generic"
      ],
      [
        true,
        "array-simple"
      ]
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "arrow-parens",
    "description": "Requires parentheses around the parameters of arrow function definitions.",
    "hasFix": true,
    "rationale": "Maintains stylistic consistency with other arrow function definitions.",
    "optionsDescription": "\nIf `ban-single-arg-parens` is specified, then arrow functions with one parameter\nmust not have parentheses if removing them is allowed by TypeScript.",
    "options": {
      "type": "string",
      "enum": [
        "ban-single-arg-parens"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ban-single-arg-parens"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "arrow-return-shorthand",
    "description": "Suggests to convert `() => { return x; }` to `() => x`.",
    "hasFix": true,
    "optionsDescription": "\nIf `multiline` is specified, then this will warn even if the function spans multiple lines.",
    "options": {
      "type": "string",
      "enum": [
        "multiline"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "multiline"
      ]
    ],
    "rationale": "\nIt's unnecessary to include `return` and `{}` brackets in arrow lambdas.\nLeaving them out results in simpler and easier to read code.\n        ",
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Enforces usage of the shorthand return syntax when an arrow function's body does not span multiple lines.",
        "config": "```json\n\"rules\": { \"arrow-return-shorthand\": true }\n```",
        "pass": "```ts\nconst calc = (x: number, y: number) => ({ add: x + y, sub: x - y, mul: x * y });\nconst calc2 = (x: number, y: number) => {\n    return { add: x + y, sub: x - y, mul: x * y }\n};\n```",
        "fail": "```ts\nconst calc = (x: number, y: number) => { return { add: x + y, sub: x - y, mul: x * y } };\nconst calc2 = (x: number, y: number) => {\n    return { add: x + y, sub: x - y, mul: x * y }\n};\n```"
      },
      {
        "description": "Enforces usage of the shorthand return syntax even when an arrow function's body spans multiple lines.",
        "config": "```json\n\"rules\": { \"arrow-return-shorthand\": [true, \"multiline\"] }\n```",
        "pass": "```ts\nconst calc = (x: number, y: number) => ({ add: x + y, sub: x - y, mul: x * y });\nconst calc2 = (x: number, y: number) =>\n    ({ add: x + y, sub: x - y, mul: x * y });\n```",
        "fail": "```ts\nconst calc = (x: number, y: number) => { return { add: x + y, sub: x - y, mul: x * y } };\nconst calc2 = (x: number, y: number) => {\n    return { add: x + y, sub: x - y, mul: x * y }\n};\n```"
      }
    ]
  },
  {
    "ruleName": "await-promise",
    "description": "Warns for an awaited value that is not a Promise.",
    "optionsDescription": "\nA list of 'string' names of any additional classes that should also be treated as Promises.\nFor example, if you are using a class called 'Future' that implements the Thenable interface,\nyou might tell the rule to consider type references with the name 'Future' as valid Promise-like\ntypes. Note that this rule doesn't check for type assignability or compatibility; it just checks\ntype reference names.\n        ",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "Thenable"
      ]
    ],
    "rationale": "\nWhile it is valid JavaScript to await a non-Promise-like value (it will resolve immediately),\nthis pattern is often a programmer error and the resulting semantics can be unintuitive.\n\nAwaiting non-Promise-like values often is an indication of programmer error, such as\nforgetting to add parenthesis to call a function that returns a Promise.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "ban-comma-operator",
    "description": "Disallows the comma operator to be used.",
    "descriptionDetails": "[Read more about the comma operator here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator).",
    "rationale": "\nUsing the comma operator can create a potential for many non-obvious bugs or lead to misunderstanding of code.\n\n### Examples\n```\nfoo((bar, baz)); // evaluates to 'foo(baz)' because of the extra parens - confusing and not obvious\n```\n\n```\nswitch (foo) {\n    case 1, 2: // equals 'case 2' - probably intended 'case 1: case2:'\n        return true;\n    case 3:\n        return false;\n}\n```\n\n```\nlet x = (y = 1, z = 2); // x is equal to 2 - this may not be immediately obvious.\n```\n        ",
    "options": null,
    "optionsDescription": "",
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "ban",
    "description": "Bans the use of specific functions or global methods.",
    "optionsDescription": "\nA list of banned functions or methods in the following format:\n\n* banning functions:\n  * just the name of the function: `\"functionName\"`\n  * the name of the function in an array with one element: `[\"functionName\"]`\n  * an object in the following format: `{\"name\": \"functionName\", \"message\": \"optional explanation message\"}`\n* banning methods:\n  * an array with the object name, method name and optional message: `[\"objectName\", \"methodName\", \"optional message\"]`\n  * an object in the following format: `{\"name\": [\"objectName\", \"methodName\"], \"message\": \"optional message\"}`\n    * you can also ban deeply nested methods: `{\"name\": [\"foo\", \"bar\", \"baz\"]}` bans `foo.bar.baz()`\n    * the first element can contain a wildcard (`*`) that matches everything. `{\"name\": [\"*\", \"forEach\"]}` bans                  `[].forEach(...)`, `$(...).forEach(...)`, `arr.forEach(...)`, etc.\n",
    "options": {
      "type": "list",
      "listType": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minLength": 1,
            "maxLength": 3
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "minLength": 1
                  }
                ]
              },
              "message": {
                "type": "string"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      }
    },
    "optionExamples": [
      [
        true,
        "eval",
        {
          "name": "$",
          "message": "please don't"
        },
        [
          "describe",
          "only"
        ],
        {
          "name": [
            "it",
            "only"
          ],
          "message": "don't focus tests"
        },
        {
          "name": [
            "chai",
            "assert",
            "equal"
          ],
          "message": "Use 'strictEqual' instead."
        },
        {
          "name": [
            "*",
            "forEach"
          ],
          "message": "Use a regular for loop instead."
        },
        {
          "name": [
            "*",
            "_id",
            "toString"
          ],
          "message": "Use 'toHexString' instead."
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "ban-ts-ignore",
    "description": "Bans \"// @ts-ignore\" comments from being used.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "codeExamples": [
      {
        "description": "Disallows the use of \"@ts-ignore\"",
        "config": "```json\n\"rules\": { \"ban-ts-ignore\": true }\n```",
        "pass": "```ts\nif (false) {\n    // Compiler warns about unreachable code error\n    console.log(\"hello\");\n}\n```",
        "fail": "```ts\nif (false) {\n    // @ts-ignore: Unreachable code error\n    console.log(\"hello\");\n}\n```"
      }
    ]
  },
  {
    "ruleName": "ban-types",
    "description": "\nBans specific types from being used. Does not ban the\ncorresponding runtime objects from being used.",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "minLength": 1,
        "maxLength": 2
      }
    },
    "optionsDescription": "\nA list of `[\"regex\", \"optional explanation here\"]`, which bans\ntypes that match `regex`",
    "optionExamples": [
      [
        true,
        [
          "Object",
          "Use {} instead."
        ],
        [
          "String"
        ]
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "binary-expression-operand-order",
    "description": "\nIn a binary expression, a literal should always be on the right-hand side if possible.\nFor example, prefer 'x + 1' over '1 + x'.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nExpressions like `1 + x` are sometimes referred to as \"Yoda\" expressions because they read\nopposite to how we would normally speak the expression.\n\nSticking to a consistent grammar for conditions helps keep code readable and understandable.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "callable-types",
    "description": "An interface or literal type with just a call signature can be written as a function type.",
    "rationale": "style",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "style",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "class-name",
    "description": "Enforces PascalCased class and interface names.",
    "rationale": "\nMakes it easy to differentiate classes from regular variables at a glance.\n\nJavaScript and general programming convention is to refer to classes in PascalCase.\nIt's confusing to use camelCase or other conventions for class names.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Enforces PascalCased class and interface names.",
        "config": "```json\n\"rules\": { \"class-name\": true }\n```",
        "pass": "```ts\nclass MyClass { }\ninterface MyInterface { }\n```",
        "fail": "```ts\nclass myClass { }\ninterface myInterface { }\n```"
      }
    ]
  },
  {
    "ruleName": "comment-format",
    "description": "Enforces formatting rules for single-line comments.",
    "rationale": "Helps maintain a consistent, readable style in your codebase.",
    "optionsDescription": "\nFour arguments may be optionally provided:\n\n* `\"check-space\"` requires that all single-line comments must begin with a space, as in `// comment`\n    * note that for comments starting with multiple slashes, e.g. `///`, leading slashes are ignored\n    * TypeScript reference comments are ignored completely\n* `\"check-lowercase\"` requires that the first non-whitespace character of a comment must be lowercase, if applicable.\n* `\"check-uppercase\"` requires that the first non-whitespace character of a comment must be uppercase, if applicable.\n* `\"allow-trailing-lowercase\"` allows that only the first comment of a series of comments needs to be uppercase.\n    * requires `\"check-uppercase\"`\n    * comments must start at the same position\n\nExceptions to `\"check-lowercase\"` or `\"check-uppercase\"` can be managed with object that may be passed as last\nargument.\n\nOne of two options can be provided in this object:\n\n* `\"ignore-words\"`  - array of strings - words that will be ignored at the beginning of the comment.\n* `\"ignore-pattern\"` - string - RegExp pattern that will be ignored at the beginning of the comment.\n",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "check-space",
              "check-lowercase",
              "check-uppercase",
              "allow-trailing-lowercase"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ignore-words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "ignore-pattern": {
                "type": "string"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "minLength": 1,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "check-space",
        "check-uppercase",
        "allow-trailing-lowercase"
      ],
      [
        true,
        "check-lowercase",
        {
          "ignore-words": [
            "TODO",
            "HACK"
          ]
        }
      ],
      [
        true,
        "check-lowercase",
        {
          "ignore-pattern": "STD\\w{2,3}\\b"
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "comment-type",
    "description": "Allows a limited set of comment types",
    "optionsDescription": "\nOne or more of the following mutually exclusive comment types may be provided:\n\n* `singleline`: Comments starting with `//`\n* `multiline`:  Comments between `/*` and `*/` but are not doc comments\n* `doc`:        Multiline comments that start with `/**`\n* 'directive':  Triple-slash directives that are singleline comments starting with `///`",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "singleline",
          "multiline",
          "doc",
          "directive"
        ]
      },
      "uniqueItems": true
    },
    "optionExamples": [
      [
        true,
        "doc",
        "singleline"
      ],
      [
        true,
        "singleline"
      ],
      [
        true,
        "multiline"
      ]
    ],
    "hasFix": false,
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "completed-docs",
    "description": "Enforces JSDoc comments for important items be filled out.",
    "optionsDescription": "\n`true` to enable for `[classes, functions, methods, properties]`,\nor an array with each item in one of two formats:\n\n* `string` to enable for that type\n* `object` keying types to when their documentation is required:\n    * `\"methods\"` and `\"properties\"` may specify:\n        * `\"privacies\"`:\n            * `\"all\"`\n            * `\"private\"`\n            * `\"protected\"`\n            * `\"public\"`\n        * `\"locations\"`:\n            * `\"all\"`\n            * `\"instance\"`\n            * `\"static\"`\n    * Other types may specify `\"visibilities\"`:\n        * `\"all\"`\n        * `\"exported\"`\n        * `\"internal\"`\n    * `\"functions\"` `\"methods\"` may also specify `\"overloads\"`\n      to indicate that each overload should have its own documentation, which is `false` by default.\n    * All types may also provide `\"tags\"`\n      with members specifying tags that allow the docs to not have a body.\n        * `\"content\"`: Object mapping tags to `RegExp` bodies content allowed to count as complete docs.\n        * `\"existence\"`: Array of tags that must only exist to count as complete docs.\n\nTypes that may be enabled are:\n\n* `\"classes\"`\n* `\"enums\"`\n* `\"enum-members\"`\n* `\"functions\"`\n* `\"interfaces\"`\n* `\"methods\"`\n* `\"namespaces\"`\n* `\"properties\"`\n* `\"types\"`\n* `\"variables\"`",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "options": [
              "classes",
              "enums",
              "functions",
              "interfaces",
              "methods",
              "namespaces",
              "properties",
              "types",
              "variables"
            ],
            "type": "string"
          },
          {
            "type": "object",
            "properties": {
              "classes": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "enums": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "enum-members": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "functions": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  },
                  "overloads": {
                    "type": "boolean"
                  }
                },
                "type": "object"
              },
              "interfaces": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "methods": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "locations": {
                    "enum": [
                      "all",
                      "instance",
                      "static"
                    ],
                    "type": "string"
                  },
                  "privacies": {
                    "enum": [
                      "all",
                      "private",
                      "protected",
                      "public"
                    ],
                    "type": "string"
                  },
                  "overloads": {
                    "type": "boolean"
                  }
                },
                "type": "object"
              },
              "namespaces": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "properties": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "locations": {
                    "enum": [
                      "all",
                      "instance",
                      "static"
                    ],
                    "type": "string"
                  },
                  "privacies": {
                    "enum": [
                      "all",
                      "private",
                      "protected",
                      "public"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "types": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "variables": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "enums",
        "functions",
        "methods"
      ],
      [
        true,
        {
          "enums": true,
          "functions": {
            "visibilities": [
              "exported"
            ]
          },
          "methods": {
            "locations": "instance",
            "privacies": [
              "public",
              "protected"
            ]
          },
          "properties": {
            "tags": {
              "content": {
                "see": [
                  "#.*"
                ]
              },
              "existence": [
                "inheritdoc"
              ]
            }
          }
        }
      ]
    ],
    "rationale": "\nHelps ensure important components are documented.\n\nNote: use this rule sparingly. It's better to have self-documenting names on components with single, concise responsibilities.\nComments that only restate the names of variables add nothing to code, and can easily become outdated.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "curly",
    "description": "Enforces braces for `if`/`for`/`do`/`while` statements.",
    "rationale": "\n```ts\nif (foo === bar)\n    foo++;\n    bar++;\n```\n\nIn the code above, the author almost certainly meant for both `foo++` and `bar++`\nto be executed only if `foo === bar`. However, they forgot braces and `bar++` will be executed\nno matter what. This rule could prevent such a mistake.",
    "optionsDescription": "\nOne of the following options may be provided:\n\n* `\"as-needed\"` forbids any unnecessary curly braces.\n* `\"ignore-same-line\"` skips checking braces for control-flow statements\nthat are on one line and start on the same line as their control-flow keyword\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "as-needed",
          "ignore-same-line"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-same-line"
      ],
      [
        true,
        "as-needed"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true,
    "codeExamples": [
      {
        "description": "Require curly braces whenever possible (default)",
        "config": "```json\n\"rules\": { \"curly\": true }\n```",
        "pass": "```ts\nif (x > 0) {\n    doStuff();\n}\n```",
        "fail": "```ts\nif (x > 0)\n    doStuff();\n\nif (x > 0) doStuff();\n```"
      },
      {
        "description": "Make an exception for single-line instances",
        "config": "```json\n\"rules\": { \"curly\": [true, \"ignore-same-line\"] }\n```",
        "pass": "```ts\nif (x > 0) doStuff();\n```",
        "fail": "```ts\nif (x > 0)\n    doStuff()\n```"
      },
      {
        "description": "Error on unnecessary curly braces",
        "config": "```json\n\"rules\": { \"curly\": [true, \"as-needed\"] }\n```",
        "pass": "```ts\nif (x > 0)\n    doStuff();\n\nif (x > 0) {\n    customerUpdates.push(getInfo(customerId));\n    return customerUpdates;\n}\n```",
        "fail": "```ts\nif (x > 0) {\n    doStuff();\n}\n```"
      }
    ]
  },
  {
    "ruleName": "cyclomatic-complexity",
    "description": "Enforces a threshold of cyclomatic complexity.",
    "descriptionDetails": "\nCyclomatic complexity is assessed for each function of any type. A starting value of 0\nis assigned and this value is then incremented for every statement which can branch the\ncontrol flow within the function. The following statements and expressions contribute\nto cyclomatic complexity:\n* `catch`\n* `if` and `? :`\n* `||` and `&&` due to short-circuit evaluation\n* `for`, `for in` and `for of` loops\n* `while` and `do while` loops\n* `case` clauses that contain statements",
    "rationale": "\nCyclomatic complexity is a code metric which indicates the level of complexity in a\nfunction. High cyclomatic complexity indicates confusing code which may be prone to\nerrors or difficult to modify.\n\nIt's better to have smaller, single-purpose functions with self-documenting names.",
    "optionsDescription": "\nAn optional upper limit for cyclomatic complexity can be specified. If no limit option\nis provided a default value of 20 will be used.",
    "options": {
      "type": "number",
      "minimum": 2
    },
    "optionExamples": [
      true,
      [
        true,
        20
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "deprecation",
    "description": "Warns when deprecated APIs are used.",
    "descriptionDetails": "Any usage of an identifier\n            with the @deprecated JSDoc annotation will trigger a warning.\n            See http://usejsdoc.org/tags-deprecated.html",
    "rationale": "Deprecated APIs should be avoided, and usage updated.",
    "optionsDescription": "",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "encoding",
    "description": "Enforces UTF-8 file encoding.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      "true"
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "eofline",
    "description": "Ensures the file ends with a newline.",
    "descriptionDetails": "Fix for single-line files is not supported.",
    "rationale": "It is a [standard convention](https://stackoverflow.com/q/729692/3124288) to end files with a newline.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "hasFix": true,
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "file-header",
    "description": "Enforces a certain header comment for all files, matched by a regular expression.",
    "optionsDescription": "\nA single object may be passed in for configuration that must contain:\n\n* `match`: a regular expression that all headers should match\n\nAny of the following optional fields may also be provided:\n\n* `allow-single-line-comments`: a boolean for whether `//` should be considered file headers in addition to `/*` comments\n* `default`: text to add for file headers when running in `--fix` mode\n* `enforce-trailing-newline`: a boolean for whether a newline must follow the header\n\nThe rule will also accept array of strings as a legacy form of options, though the object form is recommended.\nThe first option, which is mandatory, is a regular expression that all headers should match.\nThe second argument, which is optional, is a string that should be inserted as a header comment\nif fixing is enabled and no header that matches the first argument is found.\nThe third argument, which is optional, is a string that denotes whether or not a newline should\nexist on the header.",
    "options": {
      "oneOf": [
        {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "match": {
                "type": "string"
              },
              "allow-single-line-comments": {
                "type": "boolean"
              },
              "default": {
                "type": "string"
              },
              "enforce-trailing-newline": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        },
        {
          "type": "array",
          "items": [
            {
              "type": "string"
            },
            {
              "type": "string"
            },
            {
              "type": "string"
            }
          ],
          "additionalItems": false,
          "minLength": 1,
          "maxLength": 3
        }
      ]
    },
    "optionExamples": [
      [
        true,
        {
          "match": "Copyright \\d{4}",
          "allow-single-line-comments": true,
          "default": "Copyright 2018",
          "enforce-trailing-newline": true
        }
      ],
      [
        true,
        "Copyright \\d{4}",
        "Copyright 2018",
        "enforce-trailing-newline"
      ]
    ],
    "hasFix": true,
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "file-name-casing",
    "description": "Enforces a consistent file naming convention",
    "rationale": "Helps maintain a consistent style across a file hierarchy",
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `camel-case`: File names must be camel-cased: `fileName.ts`.\n* `pascal-case`: File names must be Pascal-cased: `FileName.ts`.\n* `kebab-case`: File names must be kebab-cased: `file-name.ts`.\n* `snake-case`: File names must be snake-cased: `file_name.ts`.\n* `ignore`: File names are ignored _(useful for the object configuration)_.\n\nOr an object, where the key represents a regular expression that\nmatches the file name, and the value is the file name rule from\nthe previous list.\n\n* { \".tsx\": \"pascal-case\", \".ts\": \"camel-case\" }\n        ",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "type": "array",
            "items": [
              {
                "type": "string",
                "enum": [
                  "camel-case",
                  "ignore",
                  "pascal-case",
                  "kebab-case",
                  "snake-case"
                ]
              }
            ]
          },
          {
            "type": "object",
            "additionalProperties": {
              "type": "string",
              "enum": [
                "camel-case",
                "ignore",
                "pascal-case",
                "kebab-case",
                "snake-case"
              ]
            },
            "minProperties": 1
          }
        ]
      }
    },
    "optionExamples": [
      [
        true,
        "camel-case"
      ],
      [
        true,
        "pascal-case"
      ],
      [
        true,
        "kebab-case"
      ],
      [
        true,
        "snake-case"
      ],
      [
        true,
        {
          ".tsx": "pascal-case",
          ".ts": "camel-case"
        }
      ],
      [
        true,
        {
          ".style.ts": "kebab-case",
          ".tsx": "pascal-case",
          ".*": "camel-case"
        }
      ],
      [
        true,
        {
          ".ts": "ignore",
          ".tsx": "pascal-case"
        }
      ]
    ],
    "hasFix": false,
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "forin",
    "description": "Requires a `for ... in` statement to be filtered with an `if` statement.",
    "rationale": "\n```ts\nfor (let key in someObject) {\n    if (someObject.hasOwnProperty(key)) {\n        // code here\n    }\n}\n```\nPrevents accidental iteration over properties inherited from an object's prototype.\nSee [MDN's `for...in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)\ndocumentation for more information about `for...in` loops.\n\nAlso consider using a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nor [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nif you're storing collections of objects.\nUsing `Object`s can cause occasional edge case bugs, such as if a key is named \"hasOwnProperty\".\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "codeExamples": [
      {
        "config": "```json\n\"rules\": { \"function-constructor\": true }\n```",
        "description": "Use inline lambdas instead of calling Function",
        "fail": "```ts\nlet doesNothing = new Function();\n```",
        "pass": "```ts\nlet doesNothing = () => {};\n```"
      },
      {
        "config": "```json\n\"rules\": { \"function-constructor\": true }\n```",
        "description": "Use parameters instead of constructor strings",
        "fail": "```ts\nlet addNumbers = new Function(\"a\", \"b\", \"return a + b\");\n```",
        "pass": "```ts\nlet addNumbers = (a, b) => a + b;\n```"
      }
    ],
    "description": "\nPrevents using the built-in Function constructor.\n        ",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "Not configurable.",
    "rationale": "\nCalling the constructor directly is similar to `eval`, which is a symptom of design issues.\nString inputs don't receive type checking and can cause performance issues, particularly when dynamically created.\n\nIf you need to dynamically create functions, use \"factory\" functions that themselves return functions.\n        ",
    "ruleName": "function-constructor",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "import-blacklist",
    "description": "\nDisallows importing the specified modules via `import` and `require`,\nor importing specific named exports of the specified modules,\nor using imports matching specified regular expression patterns.",
    "rationale": "\nFor some libraries, importing the library directly can cause unused\nsubmodules to be loaded, so you may want to block these imports and\nrequire that users directly import only the submodules they need.\nIn other cases, you may simply want to ban an import because using\nit is undesirable or unsafe.",
    "optionsDescription": "A list of blacklisted modules, named imports, or regular expression patterns.",
    "options": {
      "type": "array",
      "items": {
        "oneOf": [
          {
            "type": "string",
            "minLength": 1
          },
          {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "minItems": 1,
              "items": {
                "type": "string",
                "minLength": 1
              }
            }
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minLength": 1
          }
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "rxjs",
        "lodash"
      ],
      [
        true,
        "lodash",
        {
          "lodash": [
            "pull",
            "pullAll"
          ]
        }
      ],
      [
        true,
        "rxjs",
        {
          "lodash": [
            "pull",
            "pullAll"
          ]
        },
        [
          ".*\\.temp$",
          ".*\\.tmp$"
        ]
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "import-spacing",
    "description": "Ensures proper spacing between import statement keywords",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "description": "Enforces using explicit += 1 or -= 1 operators.",
    "optionExamples": [
      true,
      [
        true,
        "allow-post"
      ]
    ],
    "options": {
      "items": {
        "enum": [
          "allow-post"
        ],
        "type": "string"
      },
      "maxLength": 1,
      "minLength": 0,
      "type": "array"
    },
    "optionsDescription": "\nIf no arguments are provided, both pre- and post-unary operators are banned.\nIf `\"allow-post\"` is provided, post-unary operators will be allowed.\n        ",
    "rationale": "\nIt's easy to type +i or -i instead of --i or ++i, and won't always result in invalid code.\nPrefer standardizing small arithmetic operations with the explicit += and -= operators.\n        ",
    "ruleName": "increment-decrement",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "indent",
    "description": "Enforces indentation with tabs or spaces.",
    "rationale": "\nUsing only one of tabs or spaces for indentation leads to more consistent editor behavior,\ncleaner diffs in version control, and easier programmatic manipulation.",
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `spaces` enforces consistent spaces.\n* `tabs` enforces consistent tabs.\n\nA second optional argument specifies indentation size:\n\n* `2` enforces 2 space indentation.\n* `4` enforces 4 space indentation.\n\nIndentation size is **required** for auto-fixing, but not for rule checking.\n\n**NOTE**: auto-fixing will only convert invalid indent whitespace to the desired type, it will not fix invalid whitespace sizes.\n",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "tabs",
            "spaces"
          ]
        },
        {
          "type": "number",
          "enum": [
            2,
            4
          ]
        }
      ],
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "spaces"
      ],
      [
        true,
        "spaces",
        4
      ],
      [
        true,
        "tabs",
        2
      ]
    ],
    "hasFix": true,
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "interface-name",
    "description": "Requires interface names to begin with a capital 'I'",
    "rationale": "Makes it easy to differentiate interfaces from regular classes at a glance.",
    "optionsDescription": "\nOne of the following two options must be provided:\n\n* `\"always-prefix\"` requires interface names to start with an \"I\"\n* `\"never-prefix\"` requires interface names to not have an \"I\" prefix",
    "options": {
      "type": "string",
      "enum": [
        "always-prefix",
        "never-prefix"
      ]
    },
    "optionExamples": [
      [
        true,
        "always-prefix"
      ],
      [
        true,
        "never-prefix"
      ]
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "interface-over-type-literal",
    "description": "Prefer an interface declaration over a type literal (`type T = { ... }`)",
    "rationale": "Interfaces are generally preferred over type literals because interfaces can be implemented, extended and merged.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "invalid-void",
    "description": "\nDisallows usage of `void` type outside of generic or return types.\nIf `void` is used as return type, it shouldn't be a part of intersection/union type.",
    "rationale": "\nThe `void` type means \"nothing\" or that a function does not return any value,\nin contra with implicit `undefined` type which means that a function returns a value `undefined`.\nSo \"nothing\" cannot be mixed with any other types.\nIf you need this - use `undefined` type instead.",
    "hasFix": false,
    "optionsDescription": "\nIf `allow-generics` is specified as `false`, then generic types will no longer be allowed to to be `void`.\nAlternately, provide an array of strings for `allow-generics` to exclusively allow generic types by those names.",
    "options": {
      "type": "object",
      "properties": {
        "allow-generics": {
          "oneOf": [
            {
              "type": "boolean"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minLength": 1
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "allow-generics": false
        }
      ],
      [
        true,
        {
          "allow-generics": [
            "Promise",
            "PromiseLike"
          ]
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": true
  },
  {
    "ruleName": "jsdoc-format",
    "description": "Enforces basic format rules for JSDoc comments.",
    "descriptionDetails": "\nThe following rules are enforced for JSDoc comments (comments starting with `/**`):\n\n* each line contains an asterisk and asterisks must be aligned\n* each asterisk must be followed by either a space or a newline (except for the first and the last)\n* the only characters before the asterisk on each line must be whitespace characters\n* one line comments must start with `/** ` and end with `*/`\n* multiline comments don't allow text after `/** ` in the first line (with option `\"check-multiline-start\"`)\n        ",
    "rationale": "Helps maintain a consistent, readable style for JSDoc comments.",
    "optionsDescription": "\nYou can optionally specify the option `\"check-multiline-start\"` to enforce the first line of a\nmultiline JSDoc comment to be empty.\n        ",
    "options": {
      "type": "array",
      "minItems": 0,
      "maxItems": 1,
      "items": {
        "type": "string",
        "enum": [
          "check-multiline-start"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "check-multiline-start"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "label-position",
    "description": "Only allows labels in sensible locations.",
    "descriptionDetails": "This rule only allows labels to be on `do/for/while/switch` statements.",
    "rationale": "\nLabels in JavaScript only can be used in conjunction with `break` or `continue`,\nconstructs meant to be used for loop flow control. While you can theoretically use\nlabels on any block statement in JS, it is considered poor code structure to do so.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "linebreak-style",
    "description": "Enforces a consistent linebreak style.",
    "optionsDescription": "\nOne of the following options must be provided:\n\n* `\"LF\"` requires LF (`\\n`) linebreaks\n* `\"CRLF\"` requires CRLF (`\\r\\n`) linebreaks",
    "options": {
      "type": "string",
      "enum": [
        "LF",
        "CRLF"
      ]
    },
    "optionExamples": [
      [
        true,
        "LF"
      ],
      [
        true,
        "CRLF"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "match-default-export-name",
    "description": "\nRequires that a default import have the same name as the declaration it imports.\nDoes nothing for anonymous default exports.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "max-classes-per-file",
    "description": "\nA file may not contain more than the specified number of classes",
    "rationale": "\nEnsures that files have a single responsibility so that that classes each exist in their own files",
    "optionsDescription": "\nThe one required argument is an integer indicating the maximum number of classes that can appear in a\nfile. An optional argument `\"exclude-class-expressions\"` can be provided to exclude class expressions\nfrom the overall class count.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "number",
          "minimum": 1
        },
        {
          "type": "string",
          "enum": [
            "exclude-class-expressions"
          ]
        }
      ],
      "additionalItems": false,
      "minLength": 1,
      "maxLength": 2
    },
    "optionExamples": [
      [
        true,
        1
      ],
      [
        true,
        5,
        "exclude-class-expressions"
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "max-file-line-count",
    "description": "Requires files to remain under a certain number of lines",
    "rationale": "\nLimiting the number of lines allowed in a file allows files to remain small,\nsingle purpose, and maintainable.",
    "optionsDescription": "An integer indicating the maximum number of lines.",
    "options": {
      "type": "number",
      "minimum": "1"
    },
    "optionExamples": [
      [
        true,
        300
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "max-line-length",
    "description": "Requires lines to be under a certain max length.",
    "rationale": "\nLimiting the length of a line of code improves code readability.\nIt also makes comparing code side-by-side easier and improves compatibility with\nvarious editors, IDEs, and diff viewers.",
    "optionsDescription": "\nIt can take one argument, which can be any of the following:\n* integer indicating maximum length of lines.\n* object with keys:\n  * `limit` - number greater than 0 defining the max line length\n  * `ignore-pattern` - string defining ignore pattern for this rule, being parsed by `new RegExp()`.\n    For example:\n     * `// ` pattern will ignore all in-line comments.\n     * `^import ` pattern will ignore all import statements.\n     * `^export {(.*?)}` pattern will ignore all multiple export statements.\n     * `class [a-zA-Z]+ implements ` pattern will ignore all class declarations implementing interfaces.\n     * `^import |^export {(.*?)}|class [a-zA-Z]+ implements |// ` pattern will ignore all the cases listed above.\n  * `check-strings` - determines if strings should be checked, `false` by default.\n  * `check-regex` - determines if regular expressions should be checked, `false` by default.\n ",
    "options": {
      "type": "array",
      "items": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "object",
            "properties": {
              "limit": {
                "type": "number"
              },
              "ignore-pattern": {
                "type": "string"
              },
              "check-strings": {
                "type": "boolean"
              },
              "check-regex": {
                "type": "boolean"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "minLength": 1,
      "maxLength": 2
    },
    "optionExamples": [
      [
        true,
        120
      ],
      [
        true,
        {
          "limit": 120,
          "ignore-pattern": "^import |^export {(.*?)}",
          "check-strings": true,
          "check-regex": true
        }
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "member-access",
    "description": "Requires explicit visibility declarations for class members.",
    "rationale": "\nExplicit visibility declarations can make code more readable and accessible for those new to TS.\n\nOther languages such as C# default to `private`, unlike TypeScript's default of `public`.\nMembers lacking a visibility declaration may be an indication of an accidental leak of class internals.\n        ",
    "optionsDescription": "\nThese arguments may be optionally provided:\n\n* `\"no-public\"` forbids public accessibility to be specified, because this is the default.\n* `\"check-accessor\"` enforces explicit visibility on get/set accessors\n* `\"check-constructor\"`  enforces explicit visibility on constructors\n* `\"check-parameter-property\"`  enforces explicit visibility on parameter properties",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "no-public",
          "check-accessor",
          "check-constructor",
          "check-parameter-property"
        ]
      },
      "minLength": 0,
      "maxLength": 4
    },
    "optionExamples": [
      true,
      [
        true,
        "no-public"
      ],
      [
        true,
        "check-accessor"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "member-ordering",
    "description": "Enforces member ordering.",
    "hasFix": true,
    "rationale": "\nA consistent ordering for class members can make classes easier to read, navigate, and edit.\n\nA common opposite practice to `member-ordering` is to keep related groups of classes together.\nInstead of creating classes with multiple separate groups, consider splitting class responsibilities\napart across multiple single-responsibility classes.\n        ",
    "optionsDescription": "\nOne argument, which is an object, must be provided. It should contain an `order` property.\nThe `order` property should have a value of one of the following strings:\n\n* `fields-first`\n* `instance-sandwich`\n* `statics-first`\n\n`fields-first` puts, in order of precedence:\n\n    * fields before constructors before methods\n    * static members before instance members\n    * public members before protected members before private members\n\n`instance-sandwich` puts, in order of precedence:\n\n    * fields before constructors before methods\n    * static fields before instance fields, but static methods *after* instance methods\n    * public members before protected members before private members\n\n`statics-first` puts, in order of precedence:\n\n    * static members before instance members\n        * public members before protected members before private members\n        * fields before methods\n    * instance fields before constructors before instance methods\n        * fields before constructors before methods\n        * public members before protected members before private members\n\nNote that these presets, despite looking similar, can have subtly different behavior due to the order in which these\nrules are specified. A fully expanded ordering can be found in the PRESETS constant in\nhttps://github.com/palantir/tslint/blob/master/src/rules/memberOrderingRule.ts.\n(You may need to check the version of the file corresponding to your version of tslint.)\n\nAlternatively, the value for `order` may be an array consisting of the following strings:\n\n* `public-static-field`\n* `public-static-method`\n* `protected-static-field`\n* `protected-static-method`\n* `private-static-field`\n* `private-static-method`\n* `public-instance-field`\n* `protected-instance-field`\n* `private-instance-field`\n* `public-constructor`\n* `protected-constructor`\n* `private-constructor`\n* `public-instance-method`\n* `protected-instance-method`\n* `private-instance-method`\n\nYou can also omit the access modifier to refer to \"public-\", \"protected-\", and \"private-\" all at once; for example, \"static-field\".\n\nYou can also make your own categories by using an object instead of a string:\n\n    {\n        \"name\": \"static non-private\",\n        \"kinds\": [\n            \"public-static-field\",\n            \"protected-static-field\",\n            \"public-static-method\",\n            \"protected-static-method\"\n        ]\n    }\n\nThe 'alphabetize' option will enforce that members within the same category should be alphabetically sorted by name.",
    "options": {
      "type": "object",
      "properties": {
        "order": {
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "fields-first",
                "instance-sandwich",
                "statics-first"
              ]
            },
            {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "public-static-field",
                  "public-static-method",
                  "protected-static-field",
                  "protected-static-method",
                  "private-static-field",
                  "private-static-method",
                  "public-instance-field",
                  "protected-instance-field",
                  "private-instance-field",
                  "public-constructor",
                  "protected-constructor",
                  "private-constructor",
                  "public-instance-method",
                  "protected-instance-method",
                  "private-instance-method"
                ]
              },
              "maxLength": 13
            }
          ]
        },
        "alphabetize": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      [
        true,
        {
          "order": "fields-first"
        }
      ],
      [
        true,
        {
          "order": [
            "public-static-field",
            "public-instance-field",
            "public-constructor",
            "private-static-field",
            "private-instance-field",
            "private-constructor",
            "public-instance-method",
            "protected-instance-method",
            "private-instance-method"
          ],
          "alphabetize": true
        }
      ],
      [
        true,
        {
          "order": [
            {
              "name": "static non-private",
              "kinds": [
                "public-static-field",
                "protected-static-field",
                "public-static-method",
                "protected-static-method"
              ]
            },
            "constructor"
          ]
        }
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "newline-before-return",
    "description": "Enforces blank line before return when not the only line in the block.",
    "rationale": "Helps maintain a readable style in your codebase.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": {},
    "optionExamples": [
      true
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "newline-per-chained-call",
    "description": "\nRequires that chained method calls be broken apart onto separate lines.",
    "rationale": "\nThis style helps to keep code 'vertical', avoiding the need for side-scrolling in IDEs or text editors.",
    "optionsDescription": "Not configurable",
    "options": null,
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "new-parens",
    "description": "Requires parentheses when invoking a constructor via the `new` keyword.",
    "rationale": "Maintains stylistic consistency with other function calls.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-angle-bracket-type-assertion",
    "description": "Requires the use of `as Type` for type assertions instead of `<Type>`.",
    "hasFix": true,
    "rationale": "\nBoth formats of type assertions have the same effect, but only `as` type assertions\nwork in `.tsx` files. This rule ensures that you have a consistent type assertion style\nacross your codebase.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-any",
    "description": "Disallows usages of `any` as a type declaration.",
    "hasFix": false,
    "rationale": "\nUsing `any` as a type declaration nullifies the compile-time benefits of the type system.\n\nIf you're dealing with data of unknown or \"any\" types, you shouldn't be accessing members of it.\nEither add type annotations for properties that may exist or change the data type to the empty object type `{}`.\n\nAlternately, if you're creating storage or handling for consistent but unknown types, such as in data structures\nor serialization, use `<T>` template types for generic type handling.\n\nAlso see the `no-unsafe-any` rule.\n        ",
    "optionsDescription": "\nIf `\"ignore-rest-args\": true` is provided rest arguments will be ignored.\n        ",
    "options": {
      "type": "object",
      "properties": {
        "ignore-rest-args": {
          "type": "boolean"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "ignore-rest-args": true
        }
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "codeExamples": [
      {
        "description": "Disallows usages of `any` as a type declaration.",
        "config": "```json\n\"rules\": { \"no-any\": true }\n```",
        "pass": "```ts\nlet foo: object;\n```",
        "fail": "```ts\nlet foo: any;\n```"
      },
      {
        "description": "Disallows usages of `any` as a type declaration except rest spread parameters.",
        "config": "```json\n\"rules\": { \"no-any\": [true, { \"ignore-rest-args\": true }] }\n```",
        "pass": "```ts\nfunction foo(a: number, ...rest: any[]): void {\n    return;\n}\n```"
      }
    ]
  },
  {
    "ruleName": "no-arg",
    "description": "Disallows use of `arguments.callee`.",
    "rationale": "\nUsing `arguments.callee` makes various performance optimizations impossible.\nSee [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)\nfor more details on why to avoid `arguments.callee`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "codeExamples": [
      {
        "config": "```json\n\"rules\": { \"no-async-without-await\": true }\n```",
        "description": "Do not use the async keyword if it is not needed",
        "fail": "```ts\nasync function f() {\n    fetch();\n}\n\nasync function f() {\n    async function g() {\n        await h();\n    }\n}\n```",
        "pass": "```ts\nasync function f() {\n    await fetch();\n}\n\nconst f = async () => {\n    await fetch();\n};\n\nconst f = async () => {\n    return 'value';\n};\n```"
      }
    ],
    "description": "Functions marked async must contain an await or return statement.",
    "hasFix": false,
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "Not configurable.",
    "rationale": "\nMarking a function as `async` without using `await` or returning a value inside it can lead to an unintended promise return and a larger transpiled output.\nOften the function can be synchronous and the `async` keyword is there by mistake.\nReturn statements are allowed as sometimes it is desirable to wrap the returned value in a Promise.",
    "ruleName": "no-async-without-await",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-bitwise",
    "description": "Disallows bitwise operators.",
    "descriptionDetails": "\nSpecifically, the following bitwise operators are banned:\n`&`, `&=`, `|`, `|=`,\n`^`, `^=`, `<<`, `<<=`,\n`>>`, `>>=`, `>>>`, `>>>=`, and `~`.\nThis rule does not ban the use of `&` and `|` for intersection and union types.",
    "rationale": "\nBitwise operators are often typos - for example `bool1 & bool2` instead of `bool1 && bool2`.\nThey also can be an indicator of overly clever code which decreases maintainability.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-boolean-literal-compare",
    "description": "Warns on comparison to a boolean literal, as in `x === true`.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nComparing boolean values to boolean literals is unnecessary, as those expressions will result in booleans too.\nJust use the boolean values directly or negate them.\n        ",
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-conditional-assignment",
    "description": "Disallows any type of assignment in conditionals.",
    "descriptionDetails": "This applies to `do-while`, `for`, `if`, and `while` statements and conditional (ternary) expressions.",
    "rationale": "\nAssignments in conditionals are often typos:\nfor example `if (var1 = var2)` instead of `if (var1 == var2)`.\nThey also can be an indicator of overly clever code which decreases maintainability.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-consecutive-blank-lines",
    "description": "Disallows one or more blank lines in a row.",
    "hasFix": true,
    "rationale": "\nHelps maintain a readable style in your codebase.\n\nExtra blank lines take up extra space and add little to a semantic understanding of the code.\nIt can be harder to read through files when fewer components can fit into the screen.\nIf you find a file is so large you feel a need to split them up with extra blank lines or comments,\nconsider splitting your file into smaller files.\n        ",
    "optionsDescription": "\nAn optional number of maximum allowed sequential blanks can be specified. If no value\nis provided, a default of 1 will be used.",
    "options": {
      "type": "number",
      "minimum": "1"
    },
    "optionExamples": [
      true,
      [
        true,
        2
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-console",
    "description": "Bans the use of specified `console` methods.",
    "rationale": "In general, `console` methods aren't appropriate for production code.",
    "optionsDescription": "A list of method names to ban. If no method names are provided, all console methods are banned.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "optionExamples": [
      [
        true,
        "log",
        "error"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-construct",
    "description": "Disallows access to the constructors of `String`, `Number`, and `Boolean`.",
    "descriptionDetails": "Disallows constructor use such as `new Number(foo)` but does not disallow `Number(foo)`.",
    "rationale": "\nThere is little reason to use `String`, `Number`, or `Boolean` as constructors.\nIn almost all cases, the regular function-call version is more appropriate.\n[More details](http://stackoverflow.com/q/4719320/3124288) are available on StackOverflow.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-debugger",
    "description": "Disallows `debugger` statements.",
    "rationale": "In general, `debugger` statements aren't appropriate for production code.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-default-export",
    "description": "Disallows default exports in ES6-style modules.",
    "descriptionDetails": "Use named exports instead.",
    "rationale": "\nNamed imports/exports [promote clarity](https://github.com/palantir/tslint/issues/1182#issue-151780453).\nIn addition, current tooling differs on the correct way to handle default imports/exports.\nAvoiding them all together can help avoid tooling bugs and conflicts.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-default-import",
    "description": "Disallows importing default members from certain ES6-style modules.",
    "descriptionDetails": "Import named members instead.",
    "rationale": "\nNamed imports/exports [promote clarity](https://github.com/palantir/tslint/issues/1182#issue-151780453).\nIn addition, current tooling differs on the correct way to handle default imports/exports.\nAvoiding them all together can help avoid tooling bugs and conflicts.\n\nThe rule supposed to narrow the scope of your changes in the case of monorepo.\nSay, you have packages `A`, `B`, `C` and `utils`, where `A`, `B`, `C` dependends on `utils`,\nwhich is full of default exports.\n`\"no-default-export\"` requires you to remove default _export_ from `utils`, which leads to changes\nin packages `A`, `B`, `C`. It's harder to get merged bigger changeset by various reasons (harder to get your code approved\ndue to a number of required reviewers; longer build time due to a number of affected packages)\nand could result in ignored `\"no-default-export\"` rule in `utils'`.\n\nUnlike `\"no-default-export\"`, the rule requires you to replace default _import_ with named only in `A` you work on,\nand `utils` you import from.",
    "optionsDescription": "optionsDescription",
    "options": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "fromModules": {
            "type": "string"
          }
        },
        "required": [
          "fromModules"
        ]
      }
    },
    "optionExamples": [
      [
        true,
        {
          "fromModules": "^palantir-|^_internal-*|^\\./|^\\.\\./"
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-imports",
    "description": "\nDisallows multiple import statements from the same module.",
    "rationale": "\nUsing a single import statement per module will make the code clearer because you can see everything being imported\nfrom that module on one line.",
    "optionsDescription": "\n\"allow-namespace-imports\" allows you to import namespaces on separate lines.",
    "options": {
      "type": "object",
      "properties": {
        "allow-namespace-imports": {
          "type": "boolean"
        }
      }
    },
    "optionExamples": [
      [
        true,
        {
          "allow-namespace-imports": true
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-super",
    "description": "Warns if 'super()' appears twice in a constructor.",
    "rationale": "The second call to 'super()' will fail at runtime.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Prevents duplicate cases in switch statements.",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "",
    "ruleName": "no-duplicate-switch-case",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-variable",
    "description": "Disallows duplicate variable declarations in the same block scope.",
    "descriptionDetails": "\nThis rule is only useful when using the `var` keyword -\nthe compiler will detect redeclarations of `let` and `const` variables.",
    "rationale": "\nA variable can be reassigned if necessary -\nthere's no good reason to have a duplicate variable declaration.",
    "optionsDescription": "You can specify `\"check-parameters\"` to check for variables with the same name as a parameter.",
    "options": {
      "type": "string",
      "enum": [
        "check-parameters"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "check-parameters"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Bans usage of the delete operator with computed key expressions.",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "Not configurable.",
    "rationale": "\nDeleting dynamically computed keys is dangerous and not well optimized.\n\nAlso consider using a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nor [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nif you're storing collections of objects.\nUsing `Object`s can cause occasional edge case bugs, such as if a key is named \"hasOwnProperty\".\n        ",
    "ruleName": "no-dynamic-delete",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-empty-interface",
    "description": "Forbids empty interfaces.",
    "rationale": "An empty interface is equivalent to its supertype (or `{}`).",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "typescript",
    "typescriptOnly": true,
    "codeExamples": [
      {
        "description": "Disallows empty interfaces.",
        "config": "```json\n\"rules\": { \"no-empty-interface\": true }\n```",
        "pass": "```ts\ninterface I {\n    foo: string;\n}\n```",
        "fail": "```ts\ninterface I { }\n```"
      }
    ]
  },
  {
    "ruleName": "no-empty",
    "description": "Disallows empty blocks.",
    "descriptionDetails": "Blocks with a comment inside are not considered empty.",
    "rationale": "Empty blocks are often indicators of missing code.",
    "optionsDescription": "\nIf `allow-empty-catch` is specified, then catch blocks are allowed to be empty.\nIf `allow-empty-functions` is specified, then function definitions are allowed to be empty.",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "allow-empty-catch"
            ]
          },
          {
            "type": "string",
            "enum": [
              "allow-empty-functions"
            ]
          }
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-empty-catch"
      ],
      [
        true,
        "allow-empty-functions"
      ],
      [
        true,
        "allow-empty-catch",
        "allow-empty-functions"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-eval",
    "description": "Disallows `eval` function invocations.",
    "rationale": "\n`eval()` is dangerous as it allows arbitrary code execution with full privileges. There are\n[alternatives](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)\nfor most of the use cases for `eval()`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-floating-promises",
    "description": "Promises returned by functions must be handled appropriately.",
    "descriptionDetails": "Unhandled Promises can cause unexpected behavior, such as resolving at unexpected times.",
    "optionsDescription": "\nA list of 'string' names of any additional classes that should also be handled as Promises.\n        ",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "JQueryPromise"
      ]
    ],
    "rationale": "\nCreating a Promise and not storing or returning it may let other code run independently of its result.\nThis can cause unexpected and/or non-deterministic behavior depending on external timing factors.\n\nIt's typically better to return Promises from functions that start them, then handle them in calling code.\n\nUse `no-unused-expression` in addition to this rule to reveal even more floating promises.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-for-in-array",
    "description": "Disallows iterating over an array with a for-in loop.",
    "descriptionDetails": "\nA for-in loop (`for (var k in o)`) iterates over the properties of an Object.\n\nWhile it is legal to use for-in loops with array types, it is not common.\nfor-in will iterate over the indices of the array as strings, omitting any \"holes\" in\nthe array.\n\nMore common is to use for-of, which iterates over the values of an array.\nIf you want to iterate over the indices, alternatives include:\n\narray.forEach((value, index) => { ... });\nfor (const [index, value] of array.entries()) { ... }\nfor (let i = 0; i < array.length; i++) { ... }\n",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "requiresTypeInfo": true,
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Ban the usage of for...in statements.",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "Not configurable.",
    "rationale": "for...in statements are legacy JavaScript syntax which usually require a verbose `hasOwnProperty` check inside their loop body. These statements can be fully replaced with for...of statements in modern JS & TS.",
    "ruleName": "no-for-in",
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-implicit-dependencies",
    "description": "Disallows importing modules that are not listed as dependency in the project's package.json",
    "descriptionDetails": "\nDisallows importing transient dependencies and modules installed above your package's root directory.\n        ",
    "optionsDescription": "\nBy default the rule looks at `\"dependencies\"` and `\"peerDependencies\"`.\nBy adding the `\"dev\"` option the rule also looks at `\"devDependencies\"`.\nBy adding the `\"optional\"` option the rule also looks at `\"optionalDependencies\"`.\nAn array of whitelisted modules can be added to skip checking their existence in package.json.\n        ",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "dev",
            "optional"
          ]
        },
        {
          "type": "array"
        }
      ],
      "minItems": 0,
      "maxItems": 3
    },
    "optionExamples": [
      true,
      [
        true,
        "dev"
      ],
      [
        true,
        "optional"
      ],
      [
        true,
        [
          "src",
          "app"
        ]
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Avoid import statements with side-effect.",
    "optionExamples": [
      true,
      [
        true,
        {
          "ignore-module": "(\\.html|\\.css)$"
        }
      ]
    ],
    "options": {
      "items": {
        "properties": {
          "ignore-module": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "maxLength": 1,
      "minLength": 0,
      "type": "array"
    },
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `ignore-module` allows to specify a regex and ignore modules which it matches.",
    "rationale": "Imports with side effects may have behavior which is hard for static verification.",
    "ruleName": "no-import-side-effect",
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-inferrable-types",
    "description": "Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean.",
    "rationale": "Explicit types where they can be easily inferred by the compiler make code more verbose.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `ignore-params` allows specifying an inferrable type annotation for function params.\nThis can be useful when combining with the `typedef` rule.\n* `ignore-properties` allows specifying an inferrable type annotation for class properties.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-params",
          "ignore-properties"
        ]
      },
      "minLength": 0,
      "maxLength": 2
    },
    "hasFix": true,
    "optionExamples": [
      true,
      [
        true,
        "ignore-params"
      ],
      [
        true,
        "ignore-params",
        "ignore-properties"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-inferred-empty-object-type",
    "description": "Disallow type inference of {} (empty object type) at function and constructor call sites",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nPrior to TypeScript 3.4, generic type parameters for functions and constructors are inferred as\n`{}` (the empty object type) by default when no type parameter is explicitly supplied or when\nthe compiler cannot infer a more specific type.\nThis is often undesirable as the call is meant to be of a more specific type.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-internal-module",
    "description": "Disallows internal `module`",
    "rationale": "Using `module` leads to a confusion of concepts with external modules. Use the newer `namespace` keyword instead.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "no-invalid-template-strings",
    "description": "Warns on use of `${` in non-template strings.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "Interpolation will only work for template strings.",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-invalid-this",
    "description": "Disallows using the `this` keyword outside of classes.",
    "rationale": "See [the rule's author's rationale here.](https://github.com/palantir/tslint/pull/1105#issue-147549402)",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `check-function-in-method` disallows using the `this` keyword in functions within class methods.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-function-in-method"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "check-function-in-method"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-irregular-whitespace",
    "description": "Disallow irregular whitespace within a file, including strings and comments.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-magic-numbers",
    "description": "\nDisallows the use constant number values outside of variable assignments.\nWhen no list of allowed values is specified, -1, 0 and 1 are allowed by default.",
    "rationale": "\nMagic numbers should be avoided as they often lack documentation.\nForcing them to be stored in variables gives them implicit documentation.\n        ",
    "optionsDescription": "\nOptions may either be a list of numbers to ignore (not consider 'magic'), or an object containing up to two properties:\n* `allowed-numbers` as the list of numbers to ignore.\n* `ignore-jsx` to specify that 'magic' numbers should be allowed as JSX attributes.",
    "options": {
      "type": "array",
      "items": {
        "type": "number"
      },
      "properties": {
        "type": "object",
        "allowed-numbers": {
          "type": "array"
        },
        "ignore-jsx": {
          "type": "boolean"
        }
      },
      "minLength": 1
    },
    "optionExamples": [
      [
        true,
        1,
        2,
        3
      ],
      [
        true,
        {
          "allowed-numbers": [
            1,
            2,
            3
          ],
          "ignore-jsx": true
        }
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-mergeable-namespace",
    "description": "Disallows mergeable namespaces in the same file.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-misused-new",
    "description": "Warns on apparent attempts to define constructors for interfaces or `new` for classes.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nInterfaces in TypeScript aren't meant to describe constructors on their implementations.\nThe `new` descriptor is primarily for describing JavaScript libraries.\nIf you're trying to describe a function known to be a class, it's typically better to `declare class`.\n        ",
    "type": "functionality",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-namespace",
    "description": "Disallows use of internal `module`s and `namespace`s.",
    "descriptionDetails": "This rule still allows the use of `declare module ... {}`",
    "rationale": "\nES6-style external modules are the standard way to modularize code.\nUsing `module {}` and `namespace {}` are outdated ways to organize TypeScript code.",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `allow-declarations` allows `declare namespace ... {}` to describe external APIs.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-declarations"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-declarations"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-non-null-assertion",
    "description": "Disallows non-null assertions using the `!` postfix operator.",
    "rationale": "\nUsing non-null assertion cancels the benefits of the strict null checking mode.\n\nInstead of assuming objects exist:\n\n```\nfunction foo(instance: MyClass | undefined) {\n    instance!.doWork();\n}\n```\n\nEither inform the strict type system that the object must exist:\n\n```\nfunction foo(instance: MyClass) {\n    instance.doWork();\n}\n```\n\nOr verify that the instance exists, which will inform the type checker:\n\n```\nfunction foo(instance: MyClass | undefined) {\n    if (instance !== undefined) {\n        instance.doWork();\n    }\n}\n```\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-null-keyword",
    "description": "Disallows use of the `null` keyword literal.",
    "rationale": "\nInstead of having the dual concepts of `null` and`undefined` in a codebase,\nthis rule ensures that only `undefined` is used.\n\nJavaScript originally intended `undefined` to refer to a value that doesn't yet exist,\nwhile `null` was meant to refer to a value that does exist but points to nothing.\nThat's confusing.\n`undefined` is the default value when object members don't exist, and is the return value\nfor newer native collection APIs such as `Map.get` when collection values don't exist.\n\n```\nconst myObject = {};\nmyObject.doesNotExist; // undefined\n```\n\n```\nconst myMap = new Map<string, number>();\nmyMap.get(\"doesNotExist\"); // undefined\n```\n\nTo remove confusion over the two similar values, it's better to stick with just `undefined`.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-null-undefined-union",
    "description": "\nDisallows explicitly declared or implicitly returned union types with both `null` and\n`undefined` as members.\n        ",
    "rationale": "\nA union type that includes both `null` and `undefined` is either redundant or fragile.\nEnforcing the choice between the two allows the `triple-equals` rule to exist without\nexceptions, and is essentially a more flexible version of the `no-null-keyword` rule.\nOptional parameters are not considered to have the type `undefined`.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-object-literal-type-assertion",
    "description": "\nForbids an object literal to appear in a type assertion expression.\nCasting to `any` or to `unknown` is still allowed.",
    "rationale": "\nAlways prefer `const x: T = { ... };` to `const x = { ... } as T;`.\nThe type assertion in the latter case is either unnecessary or hides an error.\nThe compiler will warn for excess properties with this syntax, but not missing required fields.\nFor example: `const x: { foo: number } = {}` will fail to compile, but\n`const x = {} as { foo: number }` will succeed.\nAdditionally, the const assertion `const x = { foo: 1 } as const`,\nintroduced in TypeScript 3.4, is considered beneficial and is ignored by this rule.",
    "optionsDescription": "\nOne option may be configured:\n\n* `allow-arguments` allows type assertions to be used on object literals inside call expressions.",
    "options": {
      "type": "object",
      "properties": {
        "allow-arguments": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "allow-arguments": true
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "codeExamples": [
      {
        "description": "Disallow object literals to appear in type assertion expressions (default). Casing to `any` and `unknown` is allowed.",
        "config": "```json\n\"rules\": { \"no-object-literal-type-assertion\": true }\n```",
        "pass": "```ts\nlet foo = {} as any;\nlet foo = {} as unknown;\n\nlet foo = {} as any as Foo;\nlet foo = {} as unknown as Foo;\n```",
        "fail": "```ts\nlet foo = {} as Foo;\nlet foo = <Foo>{};\n```"
      },
      {
        "description": "Allow using a type assertion when the object literal is used as an argument.",
        "config": "```json\n\"rules\": { \"no-object-literal-type-assertion\": [true, { \"allow-arguments\": true }] }\n```",
        "pass": "```ts\nbar({} as Foo)\n```"
      }
    ]
  },
  {
    "ruleName": "no-parameter-properties",
    "description": "Disallows parameter properties in class constructors.",
    "rationale": "\nParameter properties can be confusing to those new to TS as they are less explicit\nthan other ways of declaring and initializing class members.\n\nIt can be cleaner to keep member variable declarations in one list directly above the class constructor\n(instead of mixed between direct class members and constructor parameter properties).\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-parameter-reassignment",
    "description": "Disallows reassigning parameters.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-promise-as-boolean",
    "description": "Warns for Promises that are used for boolean conditions.",
    "descriptionDetails": "\nFor the most accurate findings, set `\"strict\": true` in your `tsconfig.json`.\n\nIt's recommended to enable the following rules as well:\n* [`strict-boolean-expressions`](https://palantir.github.io/tslint/rules/strict-boolean-expressions/)\n* [`strict-type-predicates`](https://palantir.github.io/tslint/rules/strict-type-predicates/)\n* [`no-floating-promises`](https://palantir.github.io/tslint/rules/no-floating-promises/)\n        ",
    "optionsDescription": "\nA list of 'string' names of any additional classes that should also be treated as Promises.\nFor example, if you are using a class called 'Future' that implements the Thenable interface,\nyou might tell the rule to consider type references with the name 'Future' as valid Promise-like\ntypes. Note that this rule doesn't check for type assignability or compatibility; it just checks\ntype reference names.\n        ",
    "options": {
      "type": "object",
      "properties": {
        "promise-classes": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "OPTION_PROMISE_CLASSES": [
            "Thenable"
          ]
        }
      ]
    ],
    "rationale": "\nThere are no situations where one would like to check whether a variable's value is truthy if its type\nonly is Promise.\nThis may only occur when the typings are incorrect or the variable has a union type\n(like Promise | undefined), of which the latter is allowed.\n\nThis rule prevents common bugs from forgetting to 'await' a Promise.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true,
    "codeExamples": [
      {
        "description": "Disallows usages of a non-awaited Promise as boolean.",
        "config": "```json\n\"rules\": { \"no-promise-as-boolean\": true }\n```",
        "pass": "```ts\nasync function waiter(custumerDecisionPromise: Promise<any>) {\n    if (await custumerDecisionPromise) {\n        console.log(\"Customer ready to take an order.\")\n    }\n}\n```",
        "fail": "```ts\nasync function waiter(custumerDecisionPromise: Promise<any>) {\n    if (custumerDecisionPromise) {\n        console.log(\"Customer ready to take an order.\")\n    }\n}\n```"
      },
      {
        "description": "Disallows usages of a non-awaited third-party promise as boolean.",
        "config": "```json\n\"rules\": { \"no-promise-as-boolean\": [true, { \"promise-classes\": [\"CustomPromise\"] }] }\n```",
        "pass": "```ts\nfunction printOrdersPerLine(orderId: number, orderedFoodPromise: CustomPromise<string[]>) {\n    orderedFoodPromise.then(orderedFood => {\n        console.log(`${orderId} contains the following items:`);\n\n        for (let index = 0; orderedFood; index++) {\n            console.log(\"orderedFood[index]\");\n        }\n\n        console.log(\"Done.\");\n    })\n}\n```",
        "fail": "```ts\nfunction printOrdersPerLine(orderId: number, orderedFoodPromise: CustomPromise<string[]>) {\n    console.log(`${orderId} contains the following items:`);\n\n    for (let index = 0; orderedFoodPromise; index++) {\n        console.log(\"orderedFoodPromise[index]\");\n    }\n\n    console.log(\"Done.\");\n}\n```"
      }
    ]
  },
  {
    "ruleName": "no-redundant-jsdoc",
    "description": "Forbids JSDoc which duplicates TypeScript functionality.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-reference-import",
    "description": "Don't `<reference types=\"foo\" />` if you import `foo` anyway.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-reference",
    "description": "Disallows `/// <reference path=>` imports (use ES6-style imports instead).",
    "rationale": "\nUsing `/// <reference path=>` comments to load other files is outdated.\nUse ES6-style imports to reference other files.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-require-imports",
    "description": "Disallows invocation of `require()`.",
    "rationale": "Prefer the newer ES6-style imports over `require()`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-restricted-globals",
    "description": "Disallow specific global variables.",
    "rationale": "\n```ts\nfunction broken(evt: Event) {\n    // Meant to do something with `evt` but typed it incorrectly.\n    Event.target;  // compiler error\n    event.target;  // should be a lint failure\n}\n\nEarly Internet Explorer versions exposed the current DOM event as a global variable 'event',\nbut using this variable has been considered a bad practice for a long time.\nRestricting this will make sure this variable isnt used in browser code.\n```\n        ",
    "descriptionDetails": "\nDisallowing usage of specific global variables can be useful if you want to allow\na set of global variables by enabling an environment, but still want to disallow\nsome of those.\n        ",
    "optionsDescription": "\nThis rule takes a list of strings, where each string is a global to be restricted.\n`event`, `name` and `length` are restricted by default.\n        ",
    "options": {
      "type": "list",
      "items": {
        "type": "string"
      }
    },
    "optionExamples": [
      [
        true,
        "name",
        "length",
        "event"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-return-await",
    "description": "Disallows unnecessary `return await`.",
    "rationale": "\nAn async function always wraps the return value in a Promise.\nUsing `return await` just adds extra time before the overreaching promise is resolved without changing the semantics.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-shadowed-variable",
    "description": "Disallows shadowing variable declarations.",
    "rationale": "\nWhen a variable in a local scope and a variable in the containing scope have the same name, shadowing occurs.\nShadowing makes it impossible to access the variable in the containing scope and\nobscures to what value an identifier actually refers. Compare the following snippets:\n\n```\nconst a = 'no shadow';\nfunction print() {\n    console.log(a);\n}\nprint(); // logs 'no shadow'.\n```\n\n```\nconst a = 'no shadow';\nfunction print() {\n    const a = 'shadow'; // TSLint will complain here.\n    console.log(a);\n}\nprint(); // logs 'shadow'.\n```\n\nESLint has [an equivalent rule](https://eslint.org/docs/rules/no-shadow).\nFor more background information, refer to\n[this MDN closure doc](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures#Lexical_scoping).\n        ",
    "optionsDescription": "\nYou can optionally pass an object to disable checking for certain kinds of declarations.\nPossible keys are `\"class\"`, `\"enum\"`, `\"function\"`, `\"import\"`, `\"interface\"`, `\"namespace\"`, `\"typeAlias\"`\nand `\"typeParameter\"`. You can also pass `\"underscore`\" to ignore variable names that begin with `_`.\nJust set the value to `false` for the check you want to disable.\nAll checks default to `true`, i.e. are enabled by default.\nNote that you cannot disable variables and parameters.\n\nThe option `\"temporalDeadZone\"` defaults to `true` which shows errors when shadowing block scoped declarations in their\ntemporal dead zone. When set to `false` parameters, classes, enums and variables declared\nwith `let` or `const` are not considered shadowed if the shadowing occurs within their\n[temporal dead zone](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified).\n\nThe following example shows how the `\"temporalDeadZone\"` option changes the linting result:\n\n```ts\nfunction fn(value) {\n    if (value) {\n        const tmp = value; // no error on this line if \"temporalDeadZone\" is false\n        return tmp;\n    }\n    let tmp = undefined;\n    if (!value) {\n        const tmp = value; // this line always contains an error\n        return tmp;\n    }\n}\n```\n        ",
    "options": {
      "type": "object",
      "properties": {
        "class": {
          "type": "boolean"
        },
        "enum": {
          "type": "boolean"
        },
        "function": {
          "type": "boolean"
        },
        "import": {
          "type": "boolean"
        },
        "interface": {
          "type": "boolean"
        },
        "namespace": {
          "type": "boolean"
        },
        "typeAlias": {
          "type": "boolean"
        },
        "typeParameter": {
          "type": "boolean"
        },
        "temporalDeadZone": {
          "type": "boolean"
        },
        "underscore": {
          "type": "boolean"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "class": true,
          "enum": true,
          "function": true,
          "interface": false,
          "namespace": true,
          "typeAlias": false,
          "typeParameter": false,
          "underscore": false
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-sparse-arrays",
    "description": "Forbids array literals to contain missing elements.",
    "rationale": "Missing elements are probably an accidentally duplicated comma.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Disallows sparse arrays",
        "config": "```json\n\"rules\": { \"no-sparse-arrays\": true }\n```",
        "pass": "```ts\nconst arr: string[] = ['elemenet1', 'element2'];\n```",
        "fail": "```ts\nconst arr: string[] = ['elemenet1',, 'element2'];\n```"
      }
    ]
  },
  {
    "ruleName": "no-string-literal",
    "description": "\nForbids unnecessary string literal property access.\nAllows `obj[\"prop-erty\"]` (can't be a regular property access).\nDisallows `obj[\"property\"]` (should be `obj.property`).",
    "rationale": "\nIf `--noImplicitAny` is turned off,\nproperty access via a string literal will be 'any' if the property does not exist.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-string-throw",
    "description": "Flags throwing plain strings or concatenations of strings.",
    "hasFix": true,
    "options": null,
    "optionExamples": [
      true
    ],
    "optionsDescription": "Not configurable.",
    "rationale": "\nExample  Doing it right\n\n```ts\n// throwing an Error from typical function, whether sync or async\nif (!productToAdd) {\n    throw new Error(\"How can I add new product when no value provided?\");\n}\n```\n\nExample  Anti Pattern\n\n```ts\n// throwing a string lacks any stack trace information and other important data properties\nif (!productToAdd) {\n    throw (\"How can I add new product when no value provided?\");\n}\n```\n\nOnly Error objects contain a `.stack` member equivalent to the current stack trace.\nPrimitives such as strings do not.\n        ",
    "codeExamples": [
      {
        "description": "Flags throwing plain strings or concatenations of strings.",
        "config": "```json\n\"rules\": { \"no-string-throw\": true }\n```",
        "pass": "```ts\ntry {\n    // ...\n} catch (e) {\n    throw e;\n}\n```",
        "fail": "```ts\ntry {\n    // ...\n} catch {\n    throw 'There was a problem.';\n}\n```"
      }
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-submodule-imports",
    "description": "\nDisallows importing any submodule.",
    "rationale": "\nSubmodules of some packages are treated as private APIs and the import\npaths may change without deprecation periods. It's best to stick with\ntop-level package exports.",
    "optionsDescription": "A list of whitelisted package or submodule names.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "rxjs",
        "@angular/platform-browser",
        "@angular/core/testing"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-switch-case-fall-through",
    "description": "Disallows falling through case statements.",
    "descriptionDetails": "\nFor example, the following is not allowed:\n\n```ts\nswitch(foo) {\n    case 1:\n        someFunc(foo);\n    case 2:\n        someOtherFunc(foo);\n}\n```\n\nHowever, fall through is allowed when case statements are consecutive or\na magic `/* falls through */` comment is present. The following is valid:\n\n```ts\nswitch(foo) {\n    case 1:\n        someFunc(foo);\n        /* falls through */\n    case 2:\n    case 3:\n        someOtherFunc(foo);\n}\n```",
    "rationale": "Fall though in switch statements is often unintentional and a bug.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "\nEnforces that relational/equality binary operators does not take two equal variables/literals as operands.\nExpression like 3 === 3, someVar === someVar, \"1\" > \"1\" are either a tautology or contradiction, and will produce an error.\n",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "Not configurable.",
    "rationale": "Clean redundant code and unnecessary comparison of objects and literals.",
    "ruleName": "no-tautology-expression",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Disallows unnecessary references to `this`.",
    "optionExamples": [
      true,
      [
        true,
        {
          "allowed-names": [
            "^self$"
          ],
          "allow-destructuring": true
        }
      ]
    ],
    "options": {
      "additionalProperties": false,
      "properties": {
        "allow-destructuring": {
          "type": "boolean"
        },
        "allowed-names": {
          "listType": "string",
          "type": "list"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nTwo options may be provided on an object:\n\n* `allow-destructuring` allows using destructuring to access members of `this` (e.g. `{ foo, bar } = this;`).\n* `allowed-names` may be specified as a list of regular expressions to match allowed variable names.",
    "rationale": "\nAssigning a variable to `this` instead of properly using arrow lambdas may be a symptom of pre-ES6 practices\nor not managing scope well.\n\nInstead of storing a reference to `this` and using it inside a `function () {`:\n\n```\nconst self = this;\n\nsetTimeout(function () {\n    self.doWork();\n});\n```\n\nUse `() =>` arrow lambdas, as they preserve `this` scope for you:\n\n```\nsetTimeout(() => {\n    this.doWork();\n});\n```\n        ",
    "ruleName": "no-this-assignment",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-trailing-whitespace",
    "description": "Disallows trailing whitespace at the end of a line.",
    "rationale": "Keeps version control diffs clean as it prevents accidental whitespace from being committed.",
    "optionsDescription": "\nPossible settings are:\n\n* `\"ignore-template-strings\"`: Allows trailing whitespace in template strings.\n* `\"ignore-comments\"`: Allows trailing whitespace in comments.\n* `\"ignore-jsdoc\"`: Allows trailing whitespace only in JSDoc comments.\n* `\"ignore-blank-lines\"`: Allows trailing whitespace on empty lines.",
    "hasFix": true,
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-comments",
          "ignore-jsdoc",
          "ignore-template-strings",
          "ignore-blank-lines"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-comments"
      ],
      [
        true,
        "ignore-jsdoc"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unbound-method",
    "description": "Warns when a method is used outside of a method call.",
    "optionsDescription": "\nYou may additionally pass \"ignore-static\" to ignore static methods, or an options object.\n\n The object may have the following properties:\n\n* \"ignore-static\" - to ignore static methods.\n* \"allow-delete\" - ignore methods referenced in a delete expression.\n* \"allow-typeof\" - ignore methods referenced in a typeof expression.\n* \"whitelist\" - ignore method references in parameters of specifed function calls.\n\n",
    "options": {
      "anyOf": [
        {
          "type": "string",
          "enum": [
            "ignore-static"
          ]
        },
        {
          "type": "object",
          "properties": {
            "allow-delete": {
              "type": "boolean"
            },
            "allow-typeof": {
              "type": "boolean"
            },
            "ignore-static": {
              "type": "boolean"
            },
            "whitelist": {
              "type": "array",
              "items": {
                "type": "string"
              },
              "minLength": 1
            }
          }
        }
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-static"
      ],
      [
        true,
        {
          "ignore-static": true,
          "whitelist": [
            "expect"
          ],
          "allow-typeof": true
        }
      ]
    ],
    "rationale": "\nClass functions don't preserve the class scope when passed as standalone variables.\nFor example, this code will log the global scope (`window`/`global`), not the class instance:\n\n```\nclass MyClass {\n    public log(): void {\n        console.log(this);\n    }\n}\n\nconst instance = new MyClass();\nconst log = instance.log;\n\nlog();\n```\n\nYou need to either use an arrow lambda (`() => {...}`) or call the function with the correct scope.\n\n```\nclass MyClass {\n    public logArrowBound = (): void => {\n        console.log(bound);\n    };\n\n    public logManualBind(): void {\n        console.log(this);\n    }\n}\n\nconst instance = new MyClass();\nconst logArrowBound = instance.logArrowBound;\nconst logManualBind = instance.logManualBind.bind(instance);\n\nlogArrowBound();\nlogManualBind();\n```\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unnecessary-callback-wrapper",
    "description": "\nReplaces `x => f(x)` with just `f`.\nTo catch more cases, enable `only-arrow-functions` and `arrow-return-shorthand` too.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nThere's generally no reason to wrap a function with a callback wrapper if it's directly called anyway.\nDoing so creates extra inline lambdas that slow the runtime down.\n        ",
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Disallows unnecessary callback wrappers",
        "config": "```json\n\"rules\": { \"no-unnecessary-callback-wrapper\": true }\n```",
        "pass": "```ts\nconst handleContent = (content) => console.log('Handle content:', content);\nconst handleError = (error) => console.log('Handle error:', error);\npromise.then(handleContent).catch(handleError);\n```",
        "fail": "```ts\nconst handleContent = (content) => console.log('Handle content:', content);\nconst handleError = (error) => console.log('Handle error:', error);\npromise.then((content) => handleContent(content)).catch((error) => handleError(error));\n```"
      }
    ]
  },
  {
    "ruleName": "no-unnecessary-class",
    "description": "\nDisallows classes that are not strictly necessary.",
    "rationale": "\nUsers who come from a Java-style OO language may wrap\ntheir utility functions in an extra class, instead of\nputting them at the top level.",
    "optionsDescription": "\nThree arguments may be optionally provided:\n\n* `\"allow-constructor-only\"` ignores classes whose members are constructors.\n* `\"allow-empty-class\"` ignores `class DemoClass {}`.\n* `\"allow-static-only\"` ignores classes whose members are static.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        "allow-empty-class",
        "allow-constructor-only"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unnecessary-initializer",
    "description": "Forbids a 'var'/'let' statement or destructuring initializer to be initialized to 'undefined'.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nValues in JavaScript default to `undefined`.\nThere's no need to do so manually.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unnecessary-qualifier",
    "description": "Warns when a namespace qualifier (`A.x`) is unnecessary.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unnecessary-type-assertion",
    "description": "Warns if a type assertion does not change the type of an expression.",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionsDescription": "A list of whitelisted assertion types to ignore",
    "type": "typescript",
    "hasFix": true,
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unsafe-any",
    "description": "\nWarns when using an expression of type 'any' in a dynamic way.\nUses are only allowed if they would work for `{} | null | undefined`.\nDowncasting to unknown is always safe.\nType casts and tests are allowed.\nExpressions that work on all values (such as `\"\" + x`) are allowed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nIf you're dealing with data of unknown or \"any\" types, you shouldn't be accessing members of it.\nEither add type annotations for properties that may exist or change the data type to the empty object type `{}`.\n\nAlternately, if you're creating storage or handling for consistent but unknown types, such as in data structures\nor serialization, use `<T>` template types for generic type handling.\n\nAlso see the `no-any` rule.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unsafe-finally",
    "description": "\nDisallows control flow statements, such as `return`, `continue`,\n`break` and `throws` in finally blocks.",
    "descriptionDetails": "",
    "rationale": "\nWhen used inside `finally` blocks, control flow statements,\nsuch as `return`, `continue`, `break` and `throws`\noverride any other control flow statements in the same try/catch scope.\nThis is confusing and unexpected behavior.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unused-expression",
    "description": "Disallows unused expression statements.",
    "descriptionDetails": "\nUnused expressions are expression statements which are not assignments or function calls\n(and thus usually no-ops).",
    "rationale": "\nDetects potential errors where an assignment or function call was intended.",
    "optionsDescription": "\nThree arguments may be optionally provided:\n\n* `allow-fast-null-checks` allows to use logical operators to perform fast null checks and perform\nmethod or function calls for side effects (e.g. `e && e.preventDefault()`).\n* `allow-new` allows 'new' expressions for side effects (e.g. `new ModifyGlobalState();`.\n* `allow-tagged-template` allows tagged templates for side effects (e.g. `this.add\\`foo\\`;`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-fast-null-checks",
          "allow-new",
          "allow-tagged-template"
        ]
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-fast-null-checks"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unused-variable",
    "description": "\nDisallows unused imports, variables, functions and\nprivate class members. Similar to tsc's --noUnusedParameters and --noUnusedLocals\noptions, but does not interrupt code compilation.",
    "descriptionDetails": "\nIn addition to avoiding compilation errors, this rule may still be useful if you\nwish to have `tslint` automatically remove unused imports, variables, functions,\nand private class members, when using TSLint's `--fix` option.",
    "hasFix": true,
    "optionsDescription": "\nTwo optional arguments may be optionally provided:\n\n* `\"check-parameters\"` disallows unused function and constructor parameters.\n    * NOTE: this option is experimental and does not work with classes\n    that use abstract method declarations, among other things.\n* `{\"ignore-pattern\": \"pattern\"}` where pattern is a case-sensitive regexp.\nVariable names and imports that match the pattern will be ignored.",
    "options": {
      "type": "array",
      "items": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "check-parameters"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ignore-pattern": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "minLength": 0,
      "maxLength": 2
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "ignore-pattern": "^_"
        }
      ]
    ],
    "rationale": "\nVariables that are declared and not used anywhere in code are likely an error due to incomplete refactoring.\nSuch variables take up space in the code, are mild performance pains, and can lead to confusion by readers.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true,
    "deprecationMessage": "Since TypeScript 2.9. Please use the built-in compiler checks instead."
  },
  {
    "ruleName": "no-use-before-declare",
    "description": "Disallows usage of variables before their declaration.",
    "descriptionDetails": "\nThis rule is primarily useful when using the `var` keyword since the compiler will\nautomatically detect if a block-scoped `let` and `const` variable is used before\ndeclaration. Since most modern TypeScript doesn't use `var`, this rule is generally\ndiscouraged and is kept around for legacy purposes. It is slow to compute, is not\nenabled in the built-in configuration presets, and should not be used to inform TSLint\ndesign decisions.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true,
    "codeExamples": [
      {
        "description": "Check that referenced variables are declared beforehand (default)",
        "config": "```json\n\"rules\": { \"no-use-before-declare\": true }\n```",
        "pass": "```ts\nvar hello = 'world';\nvar foo;\n\nconsole.log(hello, foo, capitalize(hello));\n// 'world', undefined, 'WORLD'\n\nfunction capitalize(val) {\n    return val.toUpperCase();\n}\n\nimport { default as foo1 } from \"./lib\";\nimport foo2 from \"./lib\";\nimport _, { map, foldl } from \"./underscore\";\nimport * as foo3 from \"./lib\";\nimport \"./lib\";\n\nfunction declaredImports() {\n    console.log(foo1);\n    console.log(foo2);\n    console.log(foo3);\n    map([], (x) => x);\n}\n```",
        "fail": "```ts\nconsole.log(hello, foo);\n\nvar hello = 'world';\nvar foo;\n\nfunction undeclaredImports() {\n    console.log(foo1);\n    console.log(foo2);\n    console.log(foo3);\n    map([], (x) => x);\n}\n\nimport { default as foo1 } from \"./lib\";\nimport foo2 from \"./lib\";\nimport _, { map, foldl } from \"./underscore\";\nimport * as foo3 from \"./lib\";\nimport \"./lib\";\n```"
      }
    ],
    "deprecationMessage": "Since TypeScript 2.9. Please use the built-in compiler checks instead."
  },
  {
    "ruleName": "no-var-keyword",
    "description": "Disallows usage of the `var` keyword.",
    "descriptionDetails": "Use `let` or `const` instead.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nDeclaring variables using `var` has several edge case behaviors that make `var` unsuitable for modern code.\nVariables declared by `var` have their parent function block as their scope, ignoring other control flow statements.\n`var`s have declaration \"hoisting\" (similar to `function`s) and can appear to be used before declaration.\n\nVariables declared by `const` and `let` instead have as their scope the block in which they are defined,\nand are not allowed to used before declaration or be re-declared with another `const` or `let`.\n        ",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-var-requires",
    "description": "Disallows the use of require statements except in import statements.",
    "descriptionDetails": "\nIn other words, the use of forms such as `var module = require(\"module\")` are banned.\nInstead use ES2015-style imports or `import foo = require('foo')` imports.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nAMD-style `require([])` and CommonJS-style `require(\"\")` statements are environment-specific\nand more difficult to statically analyze.\n\nES2015-style `import`s are part of the JavaScript language specfication and recommended as the path going forward.\nTypeScript will compile them to environment-specific forms as needed.\n        ",
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-void-expression",
    "description": "Requires expressions of type `void` to appear in statement position.",
    "optionsDescription": "\nIf `ignore-arrow-function-shorthand` is provided, `() => returnsVoid()` will be allowed.\nOtherwise, it must be written as `() => { returnsVoid(); }`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-arrow-function-shorthand"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "rationale": "\nIt's misleading returning the results of an expression whose type is `void`.\nAttempting to do so is likely a symptom of expecting a different return type from a function.\nFor example, the following code will log `undefined` but looks like it logs a value:\n\n```\nconst performWork = (): void => {\n    workFirst();\n    workSecond();\n};\n\nconsole.log(performWork());\n```\n        ",
    "requiresTypeInfo": true,
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "number-literal-format",
    "hasFix": true,
    "description": "Checks that decimal literals should begin with '0.' instead of just '.', and should not end with a trailing '0'.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nHelps keep a consistent style with numeric literals.\nNon-standard literals are more difficult to scan through and can be a symptom of typos.\n        ",
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-key-quotes",
    "description": "Enforces consistent object literal property quote style.",
    "descriptionDetails": "\nObject literal property names can be defined in two ways: using literals or using strings.\nFor example, these two objects are equivalent:\n\nvar object1 = {\n    property: true\n};\n\nvar object2 = {\n    \"property\": true\n};\n\nIn many cases, it doesnt matter if you choose to use an identifier instead of a string\nor vice-versa. Even so, you might decide to enforce a consistent style in your code.\n\nThis rules lets you enforce consistent quoting of property names. Either they should always\nbe quoted (default behavior) or quoted only as needed (\"as-needed\").",
    "hasFix": true,
    "optionsDescription": "\nPossible settings are:\n\n* `\"always\"`: Property names should always be quoted. (This is the default.)\n* `\"as-needed\"`: Only property names which require quotes may be quoted (e.g. those with spaces in them).\n* `\"consistent\"`: Property names should either all be quoted or unquoted.\n* `\"consistent-as-needed\"`: If any property name requires quotes, then all properties must be quoted. Otherwise, no\nproperty names may be quoted.\n\nFor ES6, computed property names (`{[name]: value}`) and methods (`{foo() {}}`) never need\nto be quoted.",
    "options": {
      "type": "string",
      "enum": [
        "always",
        "as-needed",
        "consistent",
        "consistent-as-needed"
      ]
    },
    "optionExamples": [
      [
        true,
        "as-needed"
      ],
      [
        true,
        "always"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-shorthand",
    "description": "Enforces/disallows use of ES6 object literal shorthand.",
    "hasFix": true,
    "optionsDescription": "\n`\"always\"` assumed to be default option, thus with no options provided\nthe rule enforces object literal methods and properties shorthands.\nWith `\"never\"` option provided, any shorthand object literal syntax causes an error.\n\nThe rule can be configured in a more granular way.\nWith `{\"property\": \"never\"}` provided (which is equivalent to `{\"property\": \"never\", \"method\": \"always\"}`),\nthe rule only flags property shorthand assignments,\nand respectively with `{\"method\": \"never\"}` (equivalent to `{\"property\": \"always\", \"method\": \"never\"}`),\nthe rule fails only on method shorthands.",
    "options": {
      "oneOf": [
        {
          "type": "string",
          "enum": [
            "never"
          ]
        },
        {
          "type": "object",
          "properties": {
            "property": {
              "type": "string",
              "enum": [
                "never"
              ]
            },
            "method": {
              "type": "string",
              "enum": [
                "never"
              ]
            }
          },
          "minProperties": 1,
          "maxProperties": 2
        }
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "never"
      ],
      [
        true,
        {
          "property": "never"
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-sort-keys",
    "description": "\nChecks ordering of keys in object literals.\n\nWhen using the default alphabetical ordering, additional blank lines may be used to group\nobject properties together while keeping the elements within each group in alphabetical order.\nTo opt out of this use ignore-blank-lines option.\n        ",
    "rationale": "Useful in preventing merge conflicts",
    "optionsDescription": "\nBy default, this rule checks that keys are in alphabetical order.\nThe following may optionally be passed:\n\n* `ignore-blank-lines` will enforce alphabetical ordering regardless of blank lines between each key-value pair.\n* `ignore-case` will compare keys in a case insensitive way.\n* `locale-compare` will compare keys using the expected sort order of special characters, such as accents.\n* `match-declaration-order` will prefer to use the key ordering of the contextual type of the object literal, as in:\n\n    ```\n    interface I { foo: number; bar: number; }\n    const obj: I = { foo: 1, bar: 2 };\n    ```\n\nIf a contextual type is not found, alphabetical ordering will be used instead.\n* \"match-declaration-order-only\" exactly like \"match-declaration-order\",\n    but don't fall back to alphabetical if a contextual type is not found.\n\n    Note: If both match-declaration-order-only and match-declaration-order options are present,\n          match-declaration-order-only will take precedence and alphabetical fallback will not occur.\n\n* `shorthand-first` will enforce shorthand properties to appear first, as in:\n\n    ```\n    const obj = { a, c, b: true };\n    ```\n",
    "options": {
      "type": "string",
      "enum": [
        "ignore-blank-lines",
        "ignore-case",
        "locale-compare",
        "match-declaration-order",
        "match-declaration-order-only",
        "shorthand-first"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-blank-lines",
        "ignore-case",
        "locale-compare",
        "match-declaration-order",
        "shorthand-first"
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Requires that an object literal's keys be sorted alphabetically.",
        "config": "```json\n\"rules\": { \"object-literal-sort-keys\": true }\n```",
        "pass": "```ts\nlet o = {\n    bar: 2,\n    foo: 1\n};\n```",
        "fail": "```ts\nlet o = {\n    foo: 1,\n    bar: 2\n};\n```"
      },
      {
        "description": "Requires that an object literal's keys be sorted by interface-definition.\n            If there is no interface fallback to alphabetically.",
        "config": "```json\n\"rules\": {\n    \"object-literal-sort-keys\": {\n        \"options\": \"match-declaration-order\"\n    }\n}\n```",
        "pass": "```ts\ninterface I {\n    foo: number;\n    bar: number;\n}\n\nlet o: I = {\n    foo: 1,\n    bar: 2\n};\n```",
        "fail": "```ts\ninterface I {\n    foo: number;\n    bar: number;\n}\n\nlet o: I = {\n    bar: 2,\n    foo: 1\n};\n```"
      }
    ]
  },
  {
    "ruleName": "one-line",
    "description": "Requires the specified tokens to be on the same line as the expression preceding them.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"check-catch\"` checks that `catch` is on the same line as the closing brace for `try`.\n* `\"check-finally\"` checks that `finally` is on the same line as the closing brace for `catch`.\n* `\"check-else\"` checks that `else` is on the same line as the closing brace for `if`.\n* `\"check-open-brace\"` checks that an open brace falls on the same line as its preceding expression.\n* `\"check-whitespace\"` checks preceding whitespace for the specified tokens.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-catch",
          "check-finally",
          "check-else",
          "check-open-brace",
          "check-whitespace"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "check-catch",
        "check-finally",
        "check-else"
      ]
    ],
    "type": "style",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "one-variable-per-declaration",
    "description": "Disallows multiple variable definitions in the same declaration statement.",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `ignore-for-loop` allows multiple variable definitions in a for loop declaration.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-for-loop"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-for-loop"
      ]
    ],
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Disallows multiple variable definitions in the same declaration statement.",
        "config": "```json\n\"rules\": { \"one-variable-per-declaration\": true }\n```",
        "pass": "```ts\nconst foo = 1;\nconst bar = '2';\n```",
        "fail": "```ts\nconst foo = 1, bar = '2';\n```"
      },
      {
        "description": "Disallows multiple variable definitions in the same declaration statement but allows them in for-loops.",
        "config": "```json\n\"rules\": { \"one-variable-per-declaration\": [true, \"ignore-for-loop\"] }\n```",
        "pass": "```ts\nfor (let i = 0, j = 10; i < 10; i++) {\n    doSomething(j, i);\n}\n```"
      }
    ]
  },
  {
    "ruleName": "only-arrow-functions",
    "description": "Disallows traditional (non-arrow) function expressions.",
    "rationale": "Traditional functions don't bind lexical scope, which can lead to unexpected behavior when accessing 'this'.",
    "descriptionDetails": "\nNote that non-arrow functions are allowed if 'this' appears somewhere in its body\n(as such functions cannot be converted to arrow functions).\n        ",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `\"allow-declarations\"` allows standalone function declarations.\n* `\"allow-named-functions\"` allows the expression `function foo() {}` but not `function() {}`.\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-declarations",
          "allow-named-functions"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-declarations",
        "allow-named-functions"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Disallows functions with the function keyword",
        "config": "```json\n\"rules\": { \"only-arrow-functions\": true }\n```",
        "pass": "```ts\nconst myFunc = () => {\n    // do something ...\n};\n\nconst myFunc = function() {\n    this.doSomething();\n};\n```",
        "fail": "```ts\nfunction myFunc() {\n    // do something ...\n};\n\nconst myFunc = function() {\n    // do something ...\n};\n```"
      }
    ]
  },
  {
    "ruleName": "ordered-imports",
    "description": "Requires that import statements be alphabetized and grouped.",
    "descriptionDetails": "\nEnforce a consistent ordering for ES6 imports:\n- Named imports must be alphabetized (i.e. \"import {A, B, C} from \"foo\";\")\n    - The exact ordering can be controlled by the named-imports-order option.\n    - \"longName as name\" imports are ordered by \"longName\".\n- Import sources must be alphabetized within groups, i.e.:\n        import * as foo from \"a\";\n        import * as bar from \"b\";\n- Groups of imports are delineated by blank lines. You can use this rule to group\n    imports however you like, e.g. by first- vs. third-party or thematically or\n    you can define groups based upon patterns in import path names.",
    "hasFix": true,
    "optionsDescription": "\nYou may set the `\"import-sources-order\"` option to control the ordering of source\nimports (the `\"foo\"` in `import {A, B, C} from \"foo\"`).\n\nPossible values for `\"import-sources-order\"` are:\n\n* `\"case-insensitive'`: Correct order is `\"Bar\"`, `\"baz\"`, `\"Foo\"`. (This is the default.)\n* `\"lowercase-first\"`: Correct order is `\"baz\"`, `\"Bar\"`, `\"Foo\"`.\n* `\"lowercase-last\"`: Correct order is `\"Bar\"`, `\"Foo\"`, `\"baz\"`.\n* `\"any\"`: Allow any order.\n\nYou may set the `\"grouped-imports\"` option to control the grouping of source\nimports (the `\"foo\"` in `import {A, B, C} from \"foo\"`).  The grouping used\nis controlled by the `\"groups\"` option.\n\nPossible values for `\"grouped-imports\"` are:\n\n* `false`: Do not enforce grouping. (This is the default.)\n* `true`: Group source imports using default grouping or groups setting.\n\nThe value of `\"groups\"` is a list of group rules of the form:\n\n    [{\n        \"name\": \"optional rule name\",\n        \"match\": \"regex string\",\n        \"order\": 10\n    }, {\n        \"name\": \"pkga imports\",\n        \"match\": \"^@pkga\",\n        \"order\": 20\n    }]\n\nthere is also a simplified form where you only pass a list of patterns and\nthe order is given by the position in the list\n\n    [\"^@pkga\", \"^\\.\\.\"]\n\nThe first rule in the list to match a given import is the group that is used.\nIf no rule in matched then the import will be put in an `unmatched` group\nat the end of all groups. The groups must be ordered based upon the sequential\nvalue of the `order` value. (ie. order 0 is first)\n\nIf no `\"groups\"` options is set, a default grouping is used of third-party,\nparent directories and the current directory. (`\"bar\"`, `\"../baz\"`, `\"./foo\"`.)\n\nYou may set the `\"named-imports-order\"` option to control the ordering of named\nimports (the `{A, B, C}` in `import {A, B, C} from \"foo\"`).\n\nPossible values for `\"named-imports-order\"` are:\n\n* `\"case-insensitive'`: Correct order is `{A, b, C}`. (This is the default.)\n* `\"lowercase-first\"`: Correct order is `{b, A, C}`.\n* `\"lowercase-last\"`: Correct order is `{A, C, b}`.\n* `\"any\"`: Allow any order.\n\nYou may set the `\"module-source-path\"` option to control the ordering of imports based full path\nor just the module name\n\nPossible values for `\"module-source-path\"` are:\n\n* `\"full'`: Correct order is  `\"./a/Foo\"`, `\"./b/baz\"`, `\"./c/Bar\"`. (This is the default.)\n* `\"basename\"`: Correct order is `\"./c/Bar\"`, `\"./b/baz\"`, `\"./a/Foo\"`.\n\n        ",
    "options": {
      "type": "object",
      "properties": {
        "grouped-imports": {
          "type": "boolean"
        },
        "groups": {
          "type": "list",
          "listType": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "match": {
                    "type": "string"
                  },
                  "order": {
                    "type": "number"
                  }
                },
                "required": [
                  "match",
                  "order"
                ]
              }
            ]
          }
        },
        "import-sources-order": {
          "type": "string",
          "enum": [
            "case-insensitive",
            "lowercase-first",
            "lowercase-last",
            "any"
          ]
        },
        "named-imports-order": {
          "type": "string",
          "enum": [
            "case-insensitive",
            "lowercase-first",
            "lowercase-last",
            "any"
          ]
        },
        "module-source-path": {
          "type": "string",
          "enum": [
            "full",
            "basename"
          ]
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "import-sources-order": "lowercase-last",
          "named-imports-order": "lowercase-first"
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-conditional-expression",
    "description": "\nRecommends to use a conditional expression instead of assigning to the same thing in each branch of an if statement.",
    "rationale": "\nThis reduces duplication and can eliminate an unnecessary variable declaration.",
    "optionsDescription": "If `check-else-if` is specified, the rule also checks nested if-else-if statements.",
    "options": {
      "type": "string",
      "enum": [
        "check-else-if"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "check-else-if"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-const",
    "description": "Requires that variable declarations use `const` instead of `let` and `var` if possible.",
    "descriptionDetails": "\nIf a variable is only assigned to once when it is declared, it should be declared using 'const'",
    "hasFix": true,
    "optionsDescription": "\nAn optional object containing the property \"destructuring\" with two possible values:\n\n* \"any\" (default) - If any variable in destructuring can be const, this rule warns for those variables.\n* \"all\" - Only warns if all variables in destructuring can be const.",
    "options": {
      "type": "object",
      "properties": {
        "destructuring": {
          "type": "string",
          "enum": [
            "all",
            "any"
          ]
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "destructuring": "all"
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-for-of",
    "description": "Recommends a 'for-of' loop over a standard 'for' loop if the index is only used to access the array being iterated.",
    "rationale": "A for(... of ...) loop is easier to implement and read when the index is not needed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-function-over-method",
    "description": "Warns for class methods that do not use 'this'.",
    "optionsDescription": "\n\"allow-public\" excludes checking of public methods.\n\"allow-protected\" excludes checking of protected methods.",
    "options": {
      "type": "string",
      "enum": [
        "allow-public",
        "allow-protected"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-public",
        "allow-protected"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-method-signature",
    "description": "Prefer `foo(): void` over `foo: () => void` in interfaces and types.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-object-spread",
    "description": "Enforces the use of the ES2018 object spread operator over `Object.assign()` where appropriate.",
    "rationale": "Object spread allows for better type checking and inference.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "description": "Requires that private variables are marked as `readonly` if they're never modified outside of the constructor.",
    "descriptionDetails": "\nIf a private variable is only assigned to in the constructor, it should be declared as `readonly`.\n        ",
    "optionExamples": [
      true,
      [
        true,
        "only-inline-lambdas"
      ]
    ],
    "options": {
      "enum": [
        "only-inline-lambdas"
      ],
      "type": "string"
    },
    "optionsDescription": "\nIf `only-inline-lambdas` is specified, only immediately-declared arrow functions are checked.",
    "rationale": "\nMarking never-modified variables as readonly helps enforce the code's intent of keeping them as never-modified.\nIt can also help prevent accidental changes of members not meant to be changed.",
    "requiresTypeInfo": true,
    "ruleName": "prefer-readonly",
    "type": "maintainability",
    "typescriptOnly": true
  },
  {
    "ruleName": "prefer-switch",
    "description": "Prefer a `switch` statement to an `if` statement with simple `===` comparisons.",
    "optionsDescription": "\nAn optional object with the property 'min-cases'.\nThis is the number cases needed before a switch statement is recommended.\nDefaults to 3.",
    "options": {
      "type": "object",
      "properties": {
        "min-cases": {
          "type": "number"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "min-cases": 2
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-template",
    "description": "Prefer a template expression over string literal concatenation.",
    "optionsDescription": "\nIf `allow-single-concat` is specified, then a single concatenation (`x + y`) is allowed, but not more (`x + y + z`).",
    "options": {
      "type": "string",
      "enum": [
        "allow-single-concat"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-single-concat"
      ]
    ],
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Enforces the use of template strings whenever possible.",
        "config": "```json\n\"rules\": { \"prefer-template\": true }\n```",
        "pass": "```ts\nconst x: number = 1;\nconst y: number = 1;\nconst myString: string = `${x} is equals ${y}`;\n```",
        "fail": "```ts\nconst x: number = 1;\nconst y: number = 1;\nconst myString: string = x + ' is equals ' + y;\n```"
      },
      {
        "description": "Enforces the use of template strings, but allows up to one concatenation.",
        "config": "```json\n\"rules\": { \"prefer-template\": [true, \"allow-single-concat\"] }\n```",
        "pass": "```ts\nconst x: number = 1;\nconst y: number = 1;\nconst myString: string = x + ' is equals 1';\nconst myString: string = `${x} is equals ${y}`;\n```",
        "fail": "```ts\nconst x: number = 1;\nconst y: number = 1;\nconst myString: string = x + ' is equals ' + y;\n```"
      }
    ]
  },
  {
    "ruleName": "prefer-while",
    "description": "Prefer `while` loops instead of `for` loops without an initializer and incrementor.",
    "rationale": "Simplifies the readability of the loop statement, while maintaining the same functionality.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "hasFix": true,
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Prefer `while` loops instead of `for` loops without an initializer and incrementor.",
        "config": "```json\n\"rules\": { \"prefer-while\": true }\n```",
        "pass": "```ts\nfor(let i = 1; i < 10; i++) {\n    console.log(i);\n}\n\nfor (let i = 0; i < 10; i+=1) {\n    console.log(i);\n}\n\nfor (let i = 0; i < 10;) {\n    i += 1;\n}\n```",
        "fail": "```ts\nfor(;;) {\n    console.log('Hello World');\n}\n\nfor(;true===true;) {\n    console.log('Hello World');\n}\n```"
      }
    ]
  },
  {
    "ruleName": "promise-function-async",
    "description": "Requires any function or method that returns a promise to be marked async.",
    "rationale": "\nEnsures that each function is only capable of 1) returning a rejected promise, or 2)\nthrowing an Error object. In contrast, non-`async` `Promise`-returning functions\nare technically capable of either. This practice removes a requirement for consuming\ncode to handle both cases.\n\nIf no optional arguments are provided then all function types are checked,\notherwise the specific function types are checked:\n\n* `\"check-function-declaration\"` check function declarations.\n* `\"check-function-expression\"` check function expressions.\n* `\"check-arrow-function\"` check arrow functions.\n* `\"check-method-declaration\"` check method declarations.\n        ",
    "optionsDescription": "Not configurable.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-function-declaration",
          "check-function-expression",
          "check-arrow-function",
          "check-method-declaration"
        ]
      },
      "minLength": 0,
      "maxLength": 4
    },
    "optionExamples": [
      true,
      [
        true,
        "check-function-declaration",
        "check-method-declaration"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "quotemark",
    "description": "Enforces quote character for string literals.",
    "hasFix": true,
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"single\"` enforces single quotes.\n* `\"double\"` enforces double quotes.\n* `\"backtick\"` enforces backticks.\n* `\"jsx-single\"` enforces single quotes for JSX attributes.\n* `\"jsx-double\"` enforces double quotes for JSX attributes.\n* `\"avoid-template\"` forbids single-line untagged template strings that do not contain string interpolations.\n    Note that backticks may still be used if `\"avoid-escape\"` is enabled and both single and double quotes are\n    present in the string (the latter option takes precedence).\n* `\"avoid-escape\"` allows you to use the \"other\" quotemark in cases where escaping would normally be required.\n    For example, `[true, \"double\", \"avoid-escape\"]` would not report a failure on the string literal\n    `'Hello \"World\"'`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "single",
          "double",
          "backtick",
          "jsx-single",
          "jsx-double",
          "avoid-escape",
          "avoid-template"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "single",
        "avoid-escape",
        "avoid-template"
      ],
      [
        true,
        "single",
        "jsx-double"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "radix",
    "description": "Requires the radix parameter to be specified when calling `parseInt`.",
    "rationale": "\nFrom [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt):\n> Always specify this parameter to eliminate reader confusion and to guarantee predictable behavior.\n> Different implementations produce different results when a radix is not specified, usually defaulting the value to 10.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Requires the inclusion of the radix parameter when calling `parseInt`.",
        "config": "```json\n\"rules\": { \"radix\": true }\n```",
        "pass": "```ts\nconst x: string = '11';\nconst dec: number = parseInt(x, 10);\nconst bin: number = parseInt(x, 2);\nconst hex: number = parseInt(x, 16);\n```",
        "fail": "```ts\nconst x: string = '11';\nconst dec: number = parseInt(x);\nconst bin: number = parseInt(x, 2);\nconst hex: number = parseInt(x, 16);\n```"
      }
    ]
  },
  {
    "ruleName": "restrict-plus-operands",
    "description": "When adding two variables, operands must both be of type number or of type string.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "return-undefined",
    "description": "Prefer `return;` in void functions and `return undefined;` in value-returning functions.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "semicolon",
    "description": "Enforces consistent semicolon usage at the end of every statement.",
    "hasFix": true,
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `\"always\"` enforces semicolons at the end of every statement.\n* `\"never\"` disallows semicolons at the end of every statement except for when they are necessary.\n\nThe following arguments may be optionally provided:\n\n* `\"ignore-interfaces\"` skips checking semicolons at the end of interface members.\n* `\"ignore-bound-class-methods\"` skips checking semicolons at the end of bound class methods.\n* `\"strict-bound-class-methods\"` disables any special handling of bound class methods and treats them as any\nother assignment. This option overrides `\"ignore-bound-class-methods\"`.\n        ",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "always",
            "never"
          ]
        },
        {
          "type": "string",
          "enum": [
            "ignore-interfaces"
          ]
        }
      ],
      "additionalItems": false
    },
    "optionExamples": [
      [
        true,
        "always"
      ],
      [
        true,
        "never"
      ],
      [
        true,
        "always",
        "ignore-interfaces"
      ],
      [
        true,
        "always",
        "ignore-bound-class-methods"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "description": "Require or disallow a space before function parenthesis",
    "hasFix": true,
    "optionExamples": [
      true,
      [
        true,
        "always"
      ],
      [
        true,
        "never"
      ],
      [
        true,
        {
          "anonymous": "always",
          "named": "never",
          "asyncArrow": "always"
        }
      ]
    ],
    "options": {
      "properties": {
        "anonymous": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "asyncArrow": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "constructor": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "method": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "named": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nOne argument which is an object which may contain the keys `anonymous`, `named`, and `asyncArrow`\nThese should be set to either `\"always\"` or `\"never\"`.\n\n* `\"anonymous\"` checks before the opening paren in anonymous functions\n* `\"named\"` checks before the opening paren in named functions\n* `\"asyncArrow\"` checks before the opening paren in async arrow functions\n* `\"method\"` checks before the opening paren in class methods\n* `\"constructor\"` checks before the opening paren in class constructors\n        ",
    "ruleName": "space-before-function-paren",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "space-within-parens",
    "description": "Enforces spaces within parentheses or disallow them.  Empty parentheses () are always allowed.",
    "hasFix": true,
    "optionsDescription": "\nYou may enforce the amount of whitespace within parentheses.\n        ",
    "options": {
      "type": "number",
      "min": 0
    },
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "static-this",
    "description": "Ban the use of `this` in static methods.",
    "hasFix": true,
    "options": null,
    "optionsDescription": "",
    "optionExamples": [
      true
    ],
    "rationale": "\nStatic `this` usage can be confusing for newcomers.\nIt can also become imprecise when used with extended classes when a static `this` of a parent class no longer specifically refers to the parent class.\n        ",
    "type": "functionality",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Disallows the `this` keyword usage in static context.",
        "config": "```json\n\"rules\": { \"static-this\": true }\n```",
        "pass": "```ts\nclass Pass {\n    static getName() {\n        return 'name'\n    }\n\n    static getFullname() {\n        return `full ${Pass.getName()}`\n    }\n}\n```",
        "fail": "```ts\nclass Fail {\n    static getName() {\n        return 'name'\n    }\n\n    static getFullname() {\n        return `full ${this.getName()}`\n    }\n}\n```"
      }
    ]
  },
  {
    "ruleName": "strict-boolean-expressions",
    "description": "\nRestricts the types allowed in boolean expressions. By default only booleans are allowed.\n\nThe following nodes are checked:\n\n* Arguments to the `!`, `&&`, and `||` operators\n* The condition in a conditional expression (`cond ? x : y`)\n* Conditions for `if`, `for`, `while`, and `do-while` statements.",
    "optionsDescription": "\nThese options may be provided:\n\n* `allow-null-union` allows union types containing `null`.\n  - It does *not* allow `null` itself.\n  - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\n* `allow-undefined-union` allows union types containing `undefined`.\n  - It does *not* allow `undefined` itself.\n  - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\n* `allow-string` allows strings.\n  - It does *not* allow unions containing `string`.\n  - It does *not* allow string literal types.\n* `allow-enum` allows enums.\n  - It does *not* allow unions containing `enum`.\n* `allow-number` allows numbers.\n  - It does *not* allow unions containing `number`.\n  - It does *not* allow enums or number literal types.\n* `allow-mix` allows multiple of the above to appear together.\n  - For example, `string | number` or `RegExp | null | undefined` would normally not be allowed.\n  - A type like `\"foo\" | \"bar\" | undefined` is always allowed, because it has only one way to be false.\n* `allow-boolean-or-undefined` allows `boolean | undefined`.\n  - Also allows `true | false | undefined`.\n  - Does not allow `false | undefined`.\n  - This option is a subset of `allow-undefined-union`, so you don't need to enable both options at the same time.\n* `ignore-rhs` ignores the right-hand operand of `&&` and `||`.\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-null-union",
          "allow-undefined-union",
          "allow-string",
          "allow-enum",
          "allow-number",
          "allow-boolean-or-undefined",
          "ignore-rhs"
        ]
      },
      "minLength": 0,
      "maxLength": 7
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-null-union",
        "allow-undefined-union",
        "allow-string",
        "allow-enum",
        "allow-number"
      ],
      [
        true,
        "allow-boolean-or-undefined"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "strict-comparisons",
    "description": "Only allow comparisons between primitives.",
    "optionsDescription": "\nOne of the following arguments may be optionally provided:\n* `allow-object-equal-comparison` allows `!=` `==` `!==` `===` comparison between any types.\n* `allow-string-order-comparison` allows `>` `<` `>=` `<=` comparison between strings.",
    "options": {
      "type": "object",
      "properties": {
        "allow-object-equal-comparison": {
          "type": "boolean"
        },
        "allow-string-order-comparison": {
          "type": "boolean"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "allow-object-equal-comparison": false,
          "allow-string-order-comparison": false
        }
      ]
    ],
    "rationale": "\nWhen using comparison operators to compare objects, they compare references and not values.\nThis is often done accidentally.\nWith this rule, `>`, `>=`, `<`, `<=` operators are only allowed when comparing `numbers`.\n`===`, `!==` are allowed for `number` `string` and `boolean` types and if one of the\noperands is `null` or `undefined`.\n            ",
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true,
    "codeExamples": [
      {
        "description": "Disallows usage of comparison operators with non-primitive types.",
        "config": "```json\n\"rules\": { \"strict-comparisons\": true }\n```",
        "pass": "```ts\nconst object1 = {};\nconst object2 = {};\nif (isEqual(object1, object2)) {}\n```",
        "fail": "```ts\nconst object1 = {};\nconst object2 = {};\nif (object1 === object2) {}\n```"
      },
      {
        "description": "Allows equality operators to be used with non-primitive types, while still disallowing the use of greater than and less than.",
        "config": "```json\n\"rules\": { \"strict-comparisons\": [true, {  \"allow-object-equal-comparison\": true }] }\n```",
        "pass": "```ts\nconst object1 = {};\nconst object2 = {};\nif (object1 === object2) {}\n```",
        "fail": "```ts\nconst object1 = {};\nconst object2 = {};\nif (object1 < object2) {}\n```"
      },
      {
        "description": "Allows ordering operators to be used with string types.",
        "config": "```json\n\"rules\": { \"strict-comparisons\": [true, {  \"allow-string-order-comparison\": true }] }\n```",
        "pass": "```ts\nconst string1 = \"\";\nconst string2 = \"\";\nif (string1 < string2) {}\n```",
        "fail": "```ts\nconst object1 = {};\nconst object2 = {};\nif (object1 < object2) {}\n```"
      }
    ]
  },
  {
    "description": "Disable implicit toString() calls",
    "descriptionDetails": "\nRequire explicit toString() call for variables used in strings. By default only strings are allowed.\n\nThe following nodes are checked:\n\n* String literals (\"foo\" + bar)\n* ES6 templates (`foo ${bar}`)",
    "hasFix": true,
    "optionExamples": [
      true,
      [
        true,
        {
          "allow-empty-types": true
        }
      ]
    ],
    "options": {
      "properties": {
        "allow-empty-types": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nFollowing arguments may be optionally provided:\n* `allow-empty-types` allows `null`, `undefined` and `never` to be passed into strings without explicit conversion",
    "requiresTypeInfo": true,
    "ruleName": "strict-string-expressions",
    "type": "functionality",
    "typescriptOnly": true
  },
  {
    "ruleName": "strict-type-predicates",
    "description": "\nWarns for type predicates that are always true or always false.\nWorks for 'typeof' comparisons to constants (e.g. 'typeof foo === \"string\"'), and equality comparison to 'null'/'undefined'.\n(TypeScript won't let you compare '1 === 2', but it has an exception for '1 === undefined'.)\nDoes not yet work for 'instanceof'.\nDoes *not* warn for 'if (x.y)' where 'x.y' is always truthy. For that, see strict-boolean-expressions.\n\nThis rule requires `strictNullChecks` to work properly.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "switch-default",
    "description": "Require a `default` case in all `switch` statements.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Requires a `default` case in `switch` statements.",
        "config": "```json\n\"rules\": { \"switch-default\": true }\n```",
        "pass": "```ts\nlet foo: number = 1;\nswitch (foo) {\n    case 1:\n        doSomething();\n        break;\n    case 2:\n        doSomething2();\n        break;\n    default:\n        console.log('default');\n}\n```",
        "fail": "```ts\nlet foo: number = 1;\nswitch (foo) {\n    case 1:\n        doSomething();\n        break;\n    case 2:\n        doSomething2();\n}\n```"
      }
    ]
  },
  {
    "ruleName": "switch-final-break",
    "description": "Checks whether the final clause of a switch statement ends in `break;`.",
    "hasFix": true,
    "optionsDescription": "\nIf no options are passed, a final 'break;' is forbidden.\nIf the \"always\" option is passed this will require a 'break;' to always be present\nunless control flow is escaped in some other way.",
    "options": {
      "type": "string",
      "enum": [
        "always"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "always"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "trailing-comma",
    "description": "\nRequires or disallows trailing commas in array and object literals, destructuring assignments, function typings,\nnamed imports and exports and function parameters.",
    "hasFix": true,
    "optionsDescription": "\nOne argument which is an object with the keys `multiline` and `singleline`.\nBoth can be set to a string (`\"always\"` or `\"never\"`) or an object.\n\nThe object can contain any of the following keys: `\"arrays\"`, `\"objects\"`, `\"functions\"`,\n`\"imports\"`, `\"exports\"`, and `\"typeLiterals\"`; each key can have one of the following\nvalues: `\"always\"`, `\"never\"`, and `\"ignore\"`. Any missing keys will default to `\"ignore\"`.\n\n* `\"multiline\"` checks multi-line object literals.\n* `\"singleline\"` checks single-line object literals.\n\nAn array is considered \"multiline\" if its closing bracket is on a line\nafter the last array element. The same general logic is followed for\nobject literals, function typings, named import statements\nand function parameters.\n\nTo align this rule with the ECMAScript specification that is implemented in modern JavaScript VMs,\nthere is a third option `esSpecCompliant`. Set this option to `true` to disallow trailing comma on\nobject and array rest and rest parameters.\n        ",
    "options": {
      "type": "object",
      "properties": {
        "multiline": {
          "anyOf": [
            {
              "type": "string",
              "enum": [
                "always",
                "never"
              ]
            },
            {
              "type": "object",
              "properties": {
                "arrays": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "exports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "functions": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "imports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "objects": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "typeLiterals": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                }
              }
            }
          ]
        },
        "singleline": {
          "anyOf": [
            {
              "type": "string",
              "enum": [
                "always",
                "never"
              ]
            },
            {
              "type": "object",
              "properties": {
                "arrays": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "exports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "functions": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "imports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "objects": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "typeLiterals": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                }
              }
            }
          ]
        },
        "esSpecCompliant": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      [
        true,
        {
          "multiline": "always",
          "singleline": "never"
        }
      ],
      [
        true,
        {
          "multiline": {
            "objects": "always",
            "arrays": "always",
            "functions": "never",
            "typeLiterals": "ignore"
          },
          "esSpecCompliant": true
        }
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false
  },
  {
    "ruleName": "triple-equals",
    "description": "Requires `===` and `!==` in place of `==` and `!=`.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `\"allow-null-check\"` allows `==` and `!=` when comparing to `null`.\n* `\"allow-undefined-check\"` allows `==` and `!=` when comparing to `undefined`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-null-check",
          "allow-undefined-check"
        ]
      },
      "minLength": 0,
      "maxLength": 2
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-null-check"
      ],
      [
        true,
        "allow-undefined-check"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "typedef",
    "description": "Requires type definitions to exist.",
    "optionsDescription": "\nSeveral arguments may be optionally provided:\n\n* `\"call-signature\"` checks return type of functions.\n* `\"arrow-call-signature\"` checks return type of arrow functions.\n* `\"parameter\"` checks type specifier of function parameters for non-arrow functions.\n* `\"arrow-parameter\"` checks type specifier of function parameters for arrow functions.\n* `\"property-declaration\"` checks return types of interface properties.\n* `\"variable-declaration\"` checks non-binding variable declarations.\n* `\"variable-declaration-ignore-function\"` ignore variable declarations for non-arrow and arrow functions.\n* `\"member-variable-declaration\"` checks member variable declarations.\n* `\"object-destructuring\"` checks object destructuring declarations.\n* `\"array-destructuring\"` checks array destructuring declarations.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "call-signature",
          "arrow-call-signature",
          "parameter",
          "arrow-parameter",
          "property-declaration",
          "variable-declaration",
          "variable-declaration-ignore-function",
          "member-variable-declaration",
          "object-destructuring",
          "array-destructuring"
        ]
      },
      "minLength": 0,
      "maxLength": 10
    },
    "optionExamples": [
      [
        true,
        "call-signature",
        "parameter",
        "member-variable-declaration"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "codeExamples": [
      {
        "description": "Requires type definitions for call signatures",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"call-signature\"] }\n```",
        "pass": "```ts\nfunction add(x, y): number {\n    return x + y;\n}\n```",
        "fail": "```ts\nfunction add(x, y) {\n    return x + y;\n}\n```"
      },
      {
        "description": "Requires type definitions for arrow call signatures",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"arrow-call-signature\"] }\n```",
        "pass": "```ts\nconst add = (x, y): number => x + y;\n```",
        "fail": "```ts\nconst add = (x, y) => x + y;\n```"
      },
      {
        "description": "Requires type definitions for parameters",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"parameter\"] }\n```",
        "pass": "```ts\nfunction add(x: number, y: number) {\n    return x + y;\n}\n```",
        "fail": "```ts\nfunction add(x, y) {\n    return x + y;\n}\n```"
      },
      {
        "description": "Requires type definitions for arrow function parameters",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"arrow-parameter\"] }\n```",
        "pass": "```ts\nconst add = (x: number, y: number) => x + y;\n```",
        "fail": "```ts\nconst add = (x, y) => x + y;\n```"
      },
      {
        "description": "Requires type definitions for property declarations",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"property-declaration\"] }\n```",
        "pass": "```ts\ninterface I {\n    foo: number;\n    bar: string;\n}\n```",
        "fail": "```ts\ninterface I {\n    foo;\n    bar;\n}\n```"
      },
      {
        "description": "Requires type definitions for variable declarations",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"variable-declaration\"] }\n```",
        "pass": "```ts\nlet x: number;\n```",
        "fail": "```ts\nlet x;\n```"
      },
      {
        "description": "Requires type definitions for member variable declarations",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"member-variable-declaration\"] }\n```",
        "pass": "```ts\nclass MyClass {\n    x: number;\n}\n```",
        "fail": "```ts\nclass MyClass {\n    x;\n}\n```"
      },
      {
        "description": "Requires type definitions when destructuring objects.",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"object-destructuring\"] }\n```",
        "pass": "```ts\ninterface FooBar {\n    foo: number;\n    bar: string;\n}\nconst foobar = { foo: 1, bar: '2' };\nconst { foo, bar }: FooBar = foobar;\n```",
        "fail": "```ts\ninterface FooBar {\n    foo: number;\n    bar: string;\n}\nconst foobar = { foo: 1, bar: '2' };\nconst { foo, bar } = foobar;\n```"
      },
      {
        "description": "Requires type definitions when destructuring arrays.",
        "config": "```json\n\"rules\": { \"typedef\": [true, \"array-destructuring\"] }\n```",
        "pass": "```ts\nconst foobar = [1, '2'];\nconst [foo, bar]: Array<number | string> = foobar;\n```",
        "fail": "```ts\nconst foobar = [1, '2'];\nconst [foo, bar] = foobar;\n```"
      }
    ]
  },
  {
    "ruleName": "typedef-whitespace",
    "description": "Requires or disallows whitespace for type definitions.",
    "descriptionDetails": "Determines if a space is required or not before the colon in a type specifier.",
    "optionsDescription": "\nTwo arguments which are both objects.\nThe first argument specifies how much space should be to the _left_ of a typedef colon.\nThe second argument specifies how much space should be to the _right_ of a typedef colon.\nEach key should have a value of `\"onespace\"`, `\"space\"` or `\"nospace\"`.\nPossible keys are:\n\n* `\"call-signature\"` checks return type of functions.\n* `\"index-signature\"` checks index type specifier of indexers.\n* `\"parameter\"` checks function parameters.\n* `\"property-declaration\"` checks object property declarations.\n* `\"variable-declaration\"` checks variable declaration.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "object",
          "properties": {
            "call-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "index-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "parameter": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "property-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "variable-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "call-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "index-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "parameter": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "property-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "variable-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            }
          },
          "additionalProperties": false
        }
      ],
      "additionalItems": false
    },
    "optionExamples": [
      [
        true,
        {
          "call-signature": "nospace",
          "index-signature": "nospace",
          "parameter": "nospace",
          "property-declaration": "nospace",
          "variable-declaration": "nospace"
        },
        {
          "call-signature": "onespace",
          "index-signature": "onespace",
          "parameter": "onespace",
          "property-declaration": "onespace",
          "variable-declaration": "onespace"
        }
      ]
    ],
    "type": "formatting",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "type-literal-delimiter",
    "description": "\nChecks that type literal members are separated by semicolons.\nEnforces a trailing semicolon for multiline type literals.",
    "optionsDescription": "`{singleLine: \"always\"}` enforces semicolon for one liners",
    "options": {
      "type": "object",
      "properties": {
        "singleLine": {
          "type": "string",
          "enum": [
            "always",
            "never"
          ]
        }
      }
    },
    "hasFix": true,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "typeof-compare",
    "description": "Makes sure result of `typeof` is compared to correct string values",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "deprecationMessage": "Starting from TypeScript 2.2 the compiler includes this check which makes this rule redundant."
  },
  {
    "ruleName": "unified-signatures",
    "description": "Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "description": "Prevents unnecessary and/or misleading scope bindings on functions.",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "Not configurable.",
    "rationale": "\n`function` expressions that are immediately bound to `this` are equivalent to `() =>` arrow lambdas.\nAdditionally, there's no use in binding a scope to an arrow lambda, as it already has one.\n        ",
    "requiresTypeInfo": true,
    "ruleName": "unnecessary-bind",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "description": "Prevents blank constructors, as they are redundant.",
    "optionExamples": [
      true,
      [
        true,
        {
          "check-super-calls": true
        }
      ]
    ],
    "options": {
      "properties": {
        "check-super-calls": {
          "type": "boolean"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nAn optional object with the property 'check-super-calls'.\nThis is to check for unnecessary constructor parameters for super call",
    "rationale": "\nJavaScript implicitly adds a blank constructor when there isn't one.\nIt's not necessary to manually add one in.\n        ",
    "ruleName": "unnecessary-constructor",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "\nDisallows `else` blocks following `if` blocks ending with a `break`, `continue`, `return`, or `throw` statement.",
    "descriptionDetails": "",
    "optionExamples": [
      true,
      [
        true,
        {
          "allow-else-if": true
        }
      ]
    ],
    "options": {
      "type": "object",
      "properties": {
        "allow-else-if": {
          "type": "boolean"
        }
      }
    },
    "optionsDescription": "\nYou can optionally specify the option `\"allow-else-if\"` to allow \"else if\" statements.\n        ",
    "rationale": "\nWhen an `if` block is guaranteed to exit control flow when entered,\nit is unnecessary to add an `else` statement.\nThe contents that would be in the `else` block can be placed after the end of the `if` block.",
    "ruleName": "unnecessary-else",
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Disallows \"else\" following \"if\" blocks ending with \"return\", \"break\", \"continue\" or \"throw\" statement. ",
        "config": "```json\n\"rules\": { \"unnecessary-else\": true }\n```",
        "pass": "```ts\nif (someCondition()) {\n    return;\n}\n// some code here\n\nif (someCondition()) {\n    continue;\n}\n// some code here\n\nif (someCondition()) {\n    throw;\n}\n// some code here\n\nif (someCondition()) {\n    break;\n}\n// some code here\n```",
        "fail": "```ts\nif (someCondition()) {\n    return;\n} else {\n    // some code here\n}\n\nif (someCondition()) {\n    break;\n} else {\n    // some code here\n}\n\nif (someCondition()) {\n    throw;\n} else {\n    // some code here\n}\n\nif (someCondition()) {\n    continue;\n} else {\n    // some code here\n}\n```"
      }
    ]
  },
  {
    "ruleName": "use-default-type-parameter",
    "description": "Warns if an explicitly specified type argument is the default for that type parameter.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      "true"
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "use-isnan",
    "description": "Enforces use of the `isNaN()` function to check for NaN references instead of a comparison to the `NaN` constant.",
    "rationale": "\nSince `NaN !== NaN`, comparisons with regular operators will produce unexpected results.\nSo, instead of `if (myVar === NaN)`, do `if (isNaN(myVar))`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Enforces usage of `isNan()`.",
        "config": "```json\n\"rules\": { \"use-isnan\": true }\n```",
        "pass": "```ts\nif (isNaN(parseInt('_4711'))) {\n    doSomething();\n}\n```",
        "fail": "```ts\nif (parseInt('_4711') === NaN) {\n    doSomething();\n}\n```"
      }
    ]
  },
  {
    "ruleName": "variable-name",
    "description": "Checks variable names for various errors.",
    "optionsDescription": "\nSeveral arguments may be optionally provided:\n\n* `\"check-format\"` enbables enforcement of a certain naming format. By default, the rule only allows only lowerCamelCased or UPPER_CASED variable names.\n  * These additional options make the check stricter:\n    * `\"require-const-for-all-caps\"`: enforces that all variables with UPPER_CASED names should be `const`.\n  * These additional options make the check more permissive:\n    * `\"allow-leading-underscore\"` allows underscores at the beginning (only has an effect if \"check-format\" specified)\n    * `\"allow-pascal-case\"` allows PascalCase in addition to lowerCamelCase.\n    * `\"allow-snake-case\"` allows snake_case in addition to lowerCamelCase.\n    * `\"allow-trailing-underscore\"` allows underscores at the end. (only has an effect if \"check-format\" specified)\n* `\"ban-keywords\"`: disallows the use of certain TypeScript keywords as variable or parameter names.\n  * These are: `any`, `Number`, `number`, `String`, `string`, `Boolean`, `boolean`, `Undefined`, `undefined`",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-format",
          "allow-leading-underscore",
          "allow-pascal-case",
          "allow-snake-case",
          "allow-trailing-underscore",
          "require-const-for-all-caps",
          "ban-keywords"
        ]
      },
      "minLength": 0,
      "maxLength": 6
    },
    "optionExamples": [
      {
        "options": [
          "ban-keywords",
          "check-format",
          "allow-leading-underscore",
          "allow-pascal-case"
        ]
      }
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "whitespace",
    "description": "Enforces whitespace style conventions.",
    "rationale": "Helps maintain a readable, consistent style in your codebase.",
    "optionsDescription": "\nSeveral arguments may be optionally provided:\n\n* `\"check-branch\"` checks branching statements (`if`/`else`/`for`/`while`) are followed by whitespace.\n* `\"check-decl\"`checks that variable declarations have whitespace around the equals token.\n* `\"check-operator\"` checks for whitespace around operator tokens.\n* `\"check-module\"` checks for whitespace in import & export statements.\n* `\"check-separator\"` checks for whitespace after separator tokens (`,`/`;`).\n* `\"check-rest-spread\"` checks that there is no whitespace after rest/spread operator (`...`).\n* `\"check-type\"` checks for whitespace before a variable type specification.\n* `\"check-typecast\"` checks for whitespace between a typecast and its target.\n* `\"check-type-operator\"` checks for whitespace between type operators `|` and `&`.\n* `\"check-preblock\"` checks for whitespace before the opening brace of a block.\n* `\"check-postbrace\"` checks for whitespace after an opening brace.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-branch",
          "check-decl",
          "check-operator",
          "check-module",
          "check-separator",
          "check-rest-spread",
          "check-type",
          "check-typecast",
          "check-type-operator",
          "check-preblock",
          "check-postbrace"
        ]
      },
      "minLength": 0,
      "maxLength": 11
    },
    "optionExamples": [
      [
        true,
        "check-branch",
        "check-operator",
        "check-typecast"
      ]
    ],
    "type": "formatting",
    "typescriptOnly": false,
    "hasFix": true
  }
]