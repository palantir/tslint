[
  {
    "ruleName": "adjacent-overload-signatures",
    "description": "Enforces function overloads to be consecutive.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "Improves readability and organization by grouping naturally related items together.",
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "align",
    "description": "Enforces vertical alignment.",
    "hasFix": true,
    "rationale": "\nHelps maintain a readable, consistent style in your codebase.\n\nConsistent alignment for code statements helps keep code readable and clear.\nStatements misaligned from the standard can be harder to read and understand.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"parameters\"` checks alignment of function parameters.\n* `\"arguments\"` checks alignment of function call arguments.\n* `\"statements\"` checks alignment of statements.\n* `\"members\"` checks alignment of members of classes, interfaces, type literal, object literals and\nobject destructuring.\n* `\"elements\"` checks alignment of elements of array iterals, array destructuring and tuple types.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "arguments",
          "elements",
          "members",
          "parameters",
          "statements"
        ]
      },
      "minLength": 1,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "parameters",
        "statements"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "array-type",
    "description": "Requires using either 'T[]' or 'Array<T>' for arrays.",
    "hasFix": true,
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `\"array\"` enforces use of `T[]` for all types T.\n* `\"generic\"` enforces use of `Array<T>` for all types T.\n* `\"array-simple\"` enforces use of `T[]` if `T` is a simple type (primitive or type reference).",
    "options": {
      "type": "string",
      "enum": [
        "array",
        "generic",
        "array-simple"
      ]
    },
    "optionExamples": [
      [
        true,
        "array"
      ],
      [
        true,
        "generic"
      ],
      [
        true,
        "array-simple"
      ]
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "arrow-parens",
    "description": "Requires parentheses around the parameters of arrow function definitions.",
    "hasFix": true,
    "rationale": "Maintains stylistic consistency with other arrow function definitions.",
    "optionsDescription": "\nIf `ban-single-arg-parens` is specified, then arrow functions with one parameter\nmust not have parentheses if removing them is allowed by TypeScript.",
    "options": {
      "type": "string",
      "enum": [
        "ban-single-arg-parens"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ban-single-arg-parens"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "arrow-return-shorthand",
    "description": "Suggests to convert `() => { return x; }` to `() => x`.",
    "hasFix": true,
    "optionsDescription": "\nIf `multiline` is specified, then this will warn even if the function spans multiple lines.",
    "options": {
      "type": "string",
      "enum": [
        "multiline"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "multiline"
      ]
    ],
    "rationale": "\nIt's unnecessary to include `return` and `{}` brackets in arrow lambdas.\nLeaving them out results in simpler and easier to read code.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "await-promise",
    "description": "Warns for an awaited value that is not a Promise.",
    "optionsDescription": "\nA list of 'string' names of any additional classes that should also be treated as Promises.\nFor example, if you are using a class called 'Future' that implements the Thenable interface,\nyou might tell the rule to consider type references with the name 'Future' as valid Promise-like\ntypes. Note that this rule doesn't check for type assignability or compatibility; it just checks\ntype reference names.\n        ",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "Thenable"
      ]
    ],
    "rationale": "\nWhile it is valid JavaScript to await a non-Promise-like value (it will resolve immediately),\nthis pattern is often a programmer error and the resulting semantics can be unintuitive.\n\nAwaiting non-Promise-like values often is an indication of programmer error, such as\nforgetting to add parenthesis to call a function that returns a Promise.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "ban-comma-operator",
    "description": "Disallows the comma operator to be used.",
    "descriptionDetails": "[Read more about the comma operator here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator).",
    "rationale": "\nUsing the comma operator can create a potential for many non-obvious bugs or lead to misunderstanding of code.\n\n### Examples\n```\nfoo((bar, baz)); // evaluates to 'foo(baz)' because of the extra parens - confusing and not obvious\n```\n\n```\nswitch (foo) {\n    case 1, 2: // equals 'case 2' - probably intended 'case 1: case2:'\n        return true;\n    case 3:\n        return false;\n}\n```\n\n```\nlet x = (y = 1, z = 2); // x is equal to 2 - this may not be immediately obvious.\n```\n        ",
    "options": null,
    "optionsDescription": "",
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "ban",
    "description": "Bans the use of specific functions or global methods.",
    "optionsDescription": "\nA list of banned functions or methods in the following format:\n\n* banning functions:\n  * just the name of the function: `\"functionName\"`\n  * the name of the function in an array with one element: `[\"functionName\"]`\n  * an object in the following format: `{\"name\": \"functionName\", \"message\": \"optional explanation message\"}`\n* banning methods:\n  * an array with the object name, method name and optional message: `[\"functionName\", \"methodName\", \"optional message\"]`\n  * an object in the following format: `{\"name\": [\"objectName\", \"methodName\"], \"message\": \"optional message\"}`\n    * you can also ban deeply nested methods: `{\"name\": [\"foo\", \"bar\", \"baz\"]}` bans `foo.bar.baz()`\n    * the first element can contain a wildcard (`*`) that matches everything. `{\"name\": [\"*\", \"forEach\"]}` bans                  `[].forEach(...)`, `$(...).forEach(...)`, `arr.forEach(...)`, etc.\n",
    "options": {
      "type": "list",
      "listType": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minLength": 1,
            "maxLength": 3
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "minLength": 1
                  }
                ]
              },
              "message": {
                "type": "string"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      }
    },
    "optionExamples": [
      [
        true,
        "eval",
        {
          "name": "$",
          "message": "please don't"
        },
        [
          "describe",
          "only"
        ],
        {
          "name": [
            "it",
            "only"
          ],
          "message": "don't focus tests"
        },
        {
          "name": [
            "chai",
            "assert",
            "equal"
          ],
          "message": "Use 'strictEqual' instead."
        },
        {
          "name": [
            "*",
            "forEach"
          ],
          "message": "Use a regular for loop instead."
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "ban-types",
    "description": "\nBans specific types from being used. Does not ban the\ncorresponding runtime objects from being used.",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "minLength": 1,
        "maxLength": 2
      }
    },
    "optionsDescription": "\nA list of `[\"regex\", \"optional explanation here\"]`, which bans\ntypes that match `regex`",
    "optionExamples": [
      [
        true,
        [
          "Object",
          "Use {} instead."
        ],
        [
          "String"
        ]
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "binary-expression-operand-order",
    "description": "\nIn a binary expression, a literal should always be on the right-hand side if possible.\nFor example, prefer 'x + 1' over '1 + x'.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nExpressions like `1 + x` are sometimes referred to as \"Yoda\" expressions because they read\nopposite to how we would normally speak the expression.\n\nSticking to a consistent grammar for conditions helps keep code readable and understandable.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "callable-types",
    "description": "An interface or literal type with just a call signature can be written as a function type.",
    "rationale": "style",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "style",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "class-name",
    "description": "Enforces PascalCased class and interface names.",
    "rationale": "\nMakes it easy to differentiate classes from regular variables at a glance.\n\nJavaScript and general programming convention is to refer to classes in PascalCase.\nIt's confusing to use camelCase or other conventions for class names.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "comment-format",
    "description": "Enforces formatting rules for single-line comments.",
    "rationale": "Helps maintain a consistent, readable style in your codebase.",
    "optionsDescription": "\nThree arguments may be optionally provided:\n\n* `\"check-space\"` requires that all single-line comments must begin with a space, as in `// comment`\n    * note that for comments starting with multiple slashes, e.g. `///`, leading slashes are ignored\n    * TypeScript reference comments are ignored completely\n* `\"check-lowercase\"` requires that the first non-whitespace character of a comment must be lowercase, if applicable.\n* `\"check-uppercase\"` requires that the first non-whitespace character of a comment must be uppercase, if applicable.\n\nExceptions to `\"check-lowercase\"` or `\"check-uppercase\"` can be managed with object that may be passed as last argument.\n\nOne of two options can be provided in this object:\n\n    * `\"ignore-words\"`  - array of strings - words that will be ignored at the beginning of the comment.\n    * `\"ignore-pattern\"` - string - RegExp pattern that will be ignored at the beginning of the comment.\n",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "check-space",
              "check-lowercase",
              "check-uppercase"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ignore-words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "ignore-pattern": {
                "type": "string"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "minLength": 1,
      "maxLength": 4
    },
    "optionExamples": [
      [
        true,
        "check-space",
        "check-uppercase"
      ],
      [
        true,
        "check-lowercase",
        {
          "ignore-words": [
            "TODO",
            "HACK"
          ]
        }
      ],
      [
        true,
        "check-lowercase",
        {
          "ignore-pattern": "STD\\w{2,3}\\b"
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "completed-docs",
    "description": "Enforces JSDoc comments for important items be filled out.",
    "optionsDescription": "\n`true` to enable for `[classes, functions, methods, properties]`,\nor an array with each item in one of two formats:\n\n* `string` to enable for that type\n* `object` keying types to when their documentation is required:\n    * `\"methods\"` and `\"properties\"` may specify:\n        * `\"privacies\"`:\n            * `\"all\"`\n            * `\"private\"`\n            * `\"protected\"`\n            * `\"public\"`\n        * `\"locations\"`:\n            * `\"all\"`\n            * `\"instance\"`\n            * `\"static\"`\n    * Other types may specify `\"visibilities\"`:\n        * `\"all\"`\n        * `\"exported\"`\n        * `\"internal\"`\n    * All types may also provide `\"tags\"`\n      with members specifying tags that allow the docs to not have a body.\n        * `\"content\"`: Object mapping tags to `RegExp` bodies content allowed to count as complete docs.\n        * `\"existence\"`: Array of tags that must only exist to count as complete docs.\n\nTypes that may be enabled are:\n\n* `\"classes\"`\n* `\"enums\"`\n* `\"enum-members\"`\n* `\"functions\"`\n* `\"interfaces\"`\n* `\"methods\"`\n* `\"namespaces\"`\n* `\"properties\"`\n* `\"types\"`\n* `\"variables\"`",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "options": [
              "classes",
              "enums",
              "functions",
              "interfaces",
              "methods",
              "namespaces",
              "properties",
              "types",
              "variables"
            ],
            "type": "string"
          },
          {
            "type": "object",
            "properties": {
              "classes": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "enums": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "enum-members": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "functions": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "interfaces": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "methods": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "locations": {
                    "enum": [
                      "all",
                      "instance",
                      "static"
                    ],
                    "type": "string"
                  },
                  "privacies": {
                    "enum": [
                      "all",
                      "private",
                      "protected",
                      "public"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "namespaces": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "properties": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "locations": {
                    "enum": [
                      "all",
                      "instance",
                      "static"
                    ],
                    "type": "string"
                  },
                  "privacies": {
                    "enum": [
                      "all",
                      "private",
                      "protected",
                      "public"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "types": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "variables": {
                "properties": {
                  "tags": {
                    "properties": {
                      "content": {
                        "items": {
                          "type": "string"
                        },
                        "type": "object"
                      },
                      "existence": {
                        "items": {
                          "type": "string"
                        },
                        "type": "array"
                      }
                    }
                  },
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "enums",
        "functions",
        "methods"
      ],
      [
        true,
        {
          "enums": true,
          "functions": {
            "visibilities": [
              "exported"
            ]
          },
          "methods": {
            "locations": "instance",
            "privacies": [
              "public",
              "protected"
            ]
          },
          "properties": {
            "tags": {
              "content": {
                "see": [
                  "#.*"
                ]
              },
              "existence": [
                "inheritdoc"
              ]
            }
          }
        }
      ]
    ],
    "rationale": "\nHelps ensure important components are documented.\n\nNote: use this rule sparingly. It's better to have self-documenting names on components with single, consice responsibilities.\nComments that only restate the names of variables add nothing to code, and can easily become outdated.\n        ",
    "type": "style",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "curly",
    "description": "Enforces braces for `if`/`for`/`do`/`while` statements.",
    "rationale": "\n```ts\nif (foo === bar)\n    foo++;\n    bar++;\n```\n\nIn the code above, the author almost certainly meant for both `foo++` and `bar++`\nto be executed only if `foo === bar`. However, they forgot braces and `bar++` will be executed\nno matter what. This rule could prevent such a mistake.",
    "optionsDescription": "\nOne of the following options may be provided:\n\n* `\"as-needed\"` forbids any unnecessary curly braces.\n* `\"ignore-same-line\"` skips checking braces for control-flow statements\nthat are on one line and start on the same line as their control-flow keyword\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "as-needed",
          "ignore-same-line"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-same-line"
      ],
      [
        true,
        "as-needed"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true,
    "codeExamples": [
      {
        "description": "Require curly braces whenever possible (default)",
        "config": "```json\n\"rules\": { \"curly\": true }\n```",
        "pass": "```ts\nif (x > 0) {\n    doStuff();\n}\n```",
        "fail": "```ts\nif (x > 0)\n    doStuff();\n\nif (x > 0) doStuff();\n```"
      },
      {
        "description": "Make an exception for single-line instances",
        "config": "```json\n\"rules\": { \"curly\": [true, \"ignore-same-line\"] }\n```",
        "pass": "```ts\nif (x > 0) doStuff();\n```",
        "fail": "```ts\nif (x > 0)\n    doStuff()\n```"
      },
      {
        "description": "Error on unnecessary curly braces",
        "config": "```json\n\"rules\": { \"curly\": [true, \"as-needed\"] }\n```",
        "pass": "```ts\nif (x > 0)\n    doStuff();\n\nif (x > 0) {\n    customerUpdates.push(getInfo(customerId));\n    return customerUpdates;\n}\n```",
        "fail": "```ts\nif (x > 0) {\n    doStuff();\n}\n```"
      }
    ]
  },
  {
    "ruleName": "cyclomatic-complexity",
    "description": "Enforces a threshold of cyclomatic complexity.",
    "descriptionDetails": "\nCyclomatic complexity is assessed for each function of any type. A starting value of 0\nis assigned and this value is then incremented for every statement which can branch the\ncontrol flow within the function. The following statements and expressions contribute\nto cyclomatic complexity:\n* `catch`\n* `if` and `? :`\n* `||` and `&&` due to short-circuit evaluation\n* `for`, `for in` and `for of` loops\n* `while` and `do while` loops\n* `case` clauses that contain statements",
    "rationale": "\nCyclomatic complexity is a code metric which indicates the level of complexity in a\nfunction. High cyclomatic complexity indicates confusing code which may be prone to\nerrors or difficult to modify.\n\nIt's better to have smaller, single-purpose functions with self-documenting names.",
    "optionsDescription": "\nAn optional upper limit for cyclomatic complexity can be specified. If no limit option\nis provided a default value of 20 will be used.",
    "options": {
      "type": "number",
      "minimum": 2
    },
    "optionExamples": [
      true,
      [
        true,
        20
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "deprecation",
    "description": "Warns when deprecated APIs are used.",
    "descriptionDetails": "Any usage of an identifier\n            with the @deprecated JSDoc annotation will trigger a warning.\n            See http://usejsdoc.org/tags-deprecated.html",
    "rationale": "Deprecated APIs should be avoided, and usage updated.",
    "optionsDescription": "",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "encoding",
    "description": "Enforces UTF-8 file encoding.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      "true"
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "eofline",
    "description": "Ensures the file ends with a newline.",
    "descriptionDetails": "Fix for single-line files is not supported.",
    "rationale": "It is a [standard convention](https://stackoverflow.com/q/729692/3124288) to end files with a newline.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "hasFix": true,
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "file-header",
    "description": "Enforces a certain header comment for all files, matched by a regular expression.",
    "optionsDescription": "\nThe first option, which is mandatory, is a regular expression that all headers should match.\nThe second argument, which is optional, is a string that should be inserted as a header comment\nif fixing is enabled and no header that matches the first argument is found.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string"
        },
        {
          "type": "string"
        }
      ],
      "additionalItems": false,
      "minLength": 1,
      "maxLength": 2
    },
    "optionExamples": [
      [
        true,
        "Copyright \\d{4}",
        "Copyright 2017"
      ]
    ],
    "hasFix": true,
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "file-name-casing",
    "description": "Enforces a consistent file naming convention",
    "rationale": "Helps maintain a consistent style across a file hierarchy",
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `camel-case`: File names must be camel-cased: `fileName.ts`.\n* `pascal-case`: File names must be Pascal-cased: `FileName.ts`.\n* `kebab-case`: File names must be kebab-cased: `file-name.ts`.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "camel-case",
            "pascal-case",
            "kebab-case"
          ]
        }
      ]
    },
    "optionExamples": [
      [
        true,
        "camel-case"
      ],
      [
        true,
        "pascal-case"
      ],
      [
        true,
        "kebab-case"
      ]
    ],
    "hasFix": false,
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "forin",
    "description": "Requires a `for ... in` statement to be filtered with an `if` statement.",
    "rationale": "\n```ts\nfor (let key in someObject) {\n    if (someObject.hasOwnProperty(key)) {\n        // code here\n    }\n}\n```\nPrevents accidental iteration over properties inherited from an object's prototype.\nSee [MDN's `for...in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)\ndocumentation for more information about `for...in` loops.\n\nAlso consider using a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nor [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nif you're storing collections of objects.\nUsing `Object`s can cause occasional edge case bugs, such as if a key is named \"hasOwnProperty\".\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "import-blacklist",
    "description": "\nDisallows importing the specified modules directly via `import` and `require`.\nInstead only sub modules may be imported from that module.",
    "rationale": "\nSome libraries allow importing their submodules instead of the entire module.\nThis is good practise as it avoids loading unused modules.",
    "optionsDescription": "A list of blacklisted modules.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "minLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "rxjs",
        "lodash"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "import-spacing",
    "description": "Ensures proper spacing between import statement keywords",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "indent",
    "description": "Enforces indentation with tabs or spaces.",
    "rationale": "\nUsing only one of tabs or spaces for indentation leads to more consistent editor behavior,\ncleaner diffs in version control, and easier programmatic manipulation.",
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `spaces` enforces consistent spaces.\n* `tabs` enforces consistent tabs.\n\nA second optional argument specifies indentation size:\n\n* `2` enforces 2 space indentation.\n* `4` enforces 4 space indentation.\n\nIndentation size is **required** for auto-fixing, but not for rule checking.\n\n**NOTE**: auto-fixing will only convert invalid indent whitespace to the desired type, it will not fix invalid whitespace sizes.\n",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "tabs",
            "spaces"
          ]
        },
        {
          "type": "number",
          "enum": [
            2,
            4
          ]
        }
      ],
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "spaces"
      ],
      [
        true,
        "spaces",
        4
      ],
      [
        true,
        "tabs",
        2
      ]
    ],
    "hasFix": true,
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "interface-name",
    "description": "Requires interface names to begin with a capital 'I'",
    "rationale": "Makes it easy to differentiate interfaces from regular classes at a glance.",
    "optionsDescription": "\nOne of the following two options must be provided:\n\n* `\"always-prefix\"` requires interface names to start with an \"I\"\n* `\"never-prefix\"` requires interface names to not have an \"I\" prefix",
    "options": {
      "type": "string",
      "enum": [
        "always-prefix",
        "never-prefix"
      ]
    },
    "optionExamples": [
      [
        true,
        "always-prefix"
      ],
      [
        true,
        "never-prefix"
      ]
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "interface-over-type-literal",
    "description": "Prefer an interface declaration over a type literal (`type T = { ... }`)",
    "rationale": "Interfaces are generally preferred over type literals because interfaces can be implemented, extended and merged.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "jsdoc-format",
    "description": "Enforces basic format rules for JSDoc comments.",
    "descriptionDetails": "\nThe following rules are enforced for JSDoc comments (comments starting with `/**`):\n\n* each line contains an asterisk and asterisks must be aligned\n* each asterisk must be followed by either a space or a newline (except for the first and the last)\n* the only characters before the asterisk on each line must be whitespace characters\n* one line comments must start with `/** ` and end with `*/`\n* multiline comments don't allow text after `/** ` in the first line (with option `\"check-multiline-start\"`)\n        ",
    "rationale": "Helps maintain a consistent, readable style for JSDoc comments.",
    "optionsDescription": "\nYou can optionally specify the option `\"check-multiline-start\"` to enforce the first line of a\nmultiline JSDoc comment to be empty.\n        ",
    "options": {
      "type": "array",
      "minItems": 0,
      "maxItems": 1,
      "items": {
        "type": "string",
        "enum": [
          "check-multiline-start"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "check-multiline-start"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "label-position",
    "description": "Only allows labels in sensible locations.",
    "descriptionDetails": "This rule only allows labels to be on `do/for/while/switch` statements.",
    "rationale": "\nLabels in JavaScript only can be used in conjunction with `break` or `continue`,\nconstructs meant to be used for loop flow control. While you can theoretically use\nlabels on any block statement in JS, it is considered poor code structure to do so.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "linebreak-style",
    "description": "Enforces a consistent linebreak style.",
    "optionsDescription": "\nOne of the following options must be provided:\n\n* `\"LF\"` requires LF (`\\n`) linebreaks\n* `\"CRLF\"` requires CRLF (`\\r\\n`) linebreaks",
    "options": {
      "type": "string",
      "enum": [
        "LF",
        "CRLF"
      ]
    },
    "optionExamples": [
      [
        true,
        "LF"
      ],
      [
        true,
        "CRLF"
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "match-default-export-name",
    "description": "\nRequires that a default import have the same name as the declaration it imports.\nDoes nothing for anonymous default exports.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "max-classes-per-file",
    "description": "\nA file may not contain more than the specified number of classes",
    "rationale": "\nEnsures that files have a single responsibility so that that classes each exist in their own files",
    "optionsDescription": "\nThe one required argument is an integer indicating the maximum number of classes that can appear in a\nfile. An optional argument `\"exclude-class-expressions\"` can be provided to exclude class expressions\nfrom the overall class count.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "number",
          "minimum": 1
        },
        {
          "type": "string",
          "enum": [
            "exclude-class-expressions"
          ]
        }
      ],
      "additionalItems": false,
      "minLength": 1,
      "maxLength": 2
    },
    "optionExamples": [
      [
        true,
        1
      ],
      [
        true,
        5,
        "exclude-class-expressions"
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "max-file-line-count",
    "description": "Requires files to remain under a certain number of lines",
    "rationale": "\nLimiting the number of lines allowed in a file allows files to remain small,\nsingle purpose, and maintainable.",
    "optionsDescription": "An integer indicating the maximum number of lines.",
    "options": {
      "type": "number",
      "minimum": "1"
    },
    "optionExamples": [
      [
        true,
        300
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "max-line-length",
    "description": "Requires lines to be under a certain max length.",
    "rationale": "\nLimiting the length of a line of code improves code readability.\nIt also makes comparing code side-by-side easier and improves compatibility with\nvarious editors, IDEs, and diff viewers.",
    "optionsDescription": "\nIt can take one argument, which can be any of the following:\n* integer indicating maximum length of lines.\n* object with keys:\n  * `limit` - number < 0 defining max line length\n  * `ignore-pattern` - string defining ignore pattern for this rule, being parsed by `new RegExp()`.\n    For example:\n     * `// ` pattern will ignore all in-line comments.\n     * `^import ` pattern will ignore all import statements.\n     * `^export {(.*?)}` pattern will ignore all multiple export statements.\n     * `class [a-zA-Z]+ implements ` pattern will ignore all class declarations implementing interfaces.\n     * `^import |^export {(.*?)}|class [a-zA-Z]+ implements |// ` pattern will ignore all the cases listed above.\n ",
    "options": {
      "type": "array",
      "items": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "object",
            "properties": {
              "limit": {
                "type": "number"
              },
              "ignore-pattern": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "minLength": 1,
      "maxLength": 2
    },
    "optionExamples": [
      [
        true,
        120
      ],
      [
        true,
        {
          "limit": 120,
          "ignore-pattern": "^import |^export {(.*?)}"
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "member-access",
    "description": "Requires explicit visibility declarations for class members.",
    "rationale": "\nExplicit visibility declarations can make code more readable and accessible for those new to TS.\n\nOther languages such as C# default to `private`, unlike TypeScript's default of `public`.\nMembers lacking a visibility declaration may be an indication of an accidental leak of class internals.\n        ",
    "optionsDescription": "\nThese arguments may be optionally provided:\n\n* `\"no-public\"` forbids public accessibility to be specified, because this is the default.\n* `\"check-accessor\"` enforces explicit visibility on get/set accessors\n* `\"check-constructor\"`  enforces explicit visibility on constructors\n* `\"check-parameter-property\"`  enforces explicit visibility on parameter properties",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "no-public",
          "check-accessor",
          "check-constructor",
          "check-parameter-property"
        ]
      },
      "minLength": 0,
      "maxLength": 4
    },
    "optionExamples": [
      true,
      [
        true,
        "no-public"
      ],
      [
        true,
        "check-accessor"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "member-ordering",
    "description": "Enforces member ordering.",
    "hasFix": true,
    "rationale": "\nA consistent ordering for class members can make classes easier to read, navigate, and edit.\n\nA common opposite practice to `member-ordering` is to keep related groups of classes together.\nInstead of creating classes with multiple separate groups, consider splitting class responsibilities\napart across multiple single-responsibility classes.\n        ",
    "optionsDescription": "\nOne argument, which is an object, must be provided. It should contain an `order` property.\nThe `order` property should have a value of one of the following strings:\n\n* `fields-first`\n* `instance-sandwich`\n* `statics-first`\n\nAlternatively, the value for `order` maybe be an array consisting of the following strings:\n\n* `public-static-field`\n* `public-static-method`\n* `protected-static-field`\n* `protected-static-method`\n* `private-static-field`\n* `private-static-method`\n* `public-instance-field`\n* `protected-instance-field`\n* `private-instance-field`\n* `public-constructor`\n* `protected-constructor`\n* `private-constructor`\n* `public-instance-method`\n* `protected-instance-method`\n* `private-instance-method`\n\nYou can also omit the access modifier to refer to \"public-\", \"protected-\", and \"private-\" all at once; for example, \"static-field\".\n\nYou can also make your own categories by using an object instead of a string:\n\n    {\n        \"name\": \"static non-private\",\n        \"kinds\": [\n            \"public-static-field\",\n            \"protected-static-field\",\n            \"public-static-method\",\n            \"protected-static-method\"\n        ]\n    }\n\nThe 'alphabetize' option will enforce that members within the same category should be alphabetically sorted by name.",
    "options": {
      "type": "object",
      "properties": {
        "order": {
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "fields-first",
                "instance-sandwich",
                "statics-first"
              ]
            },
            {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "public-static-field",
                  "public-static-method",
                  "protected-static-field",
                  "protected-static-method",
                  "private-static-field",
                  "private-static-method",
                  "public-instance-field",
                  "protected-instance-field",
                  "private-instance-field",
                  "public-constructor",
                  "protected-constructor",
                  "private-constructor",
                  "public-instance-method",
                  "protected-instance-method",
                  "private-instance-method"
                ]
              },
              "maxLength": 13
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      [
        true,
        {
          "order": "fields-first"
        }
      ],
      [
        true,
        {
          "order": [
            "public-static-field",
            "public-instance-field",
            "public-constructor",
            "private-static-field",
            "private-instance-field",
            "private-constructor",
            "public-instance-method",
            "protected-instance-method",
            "private-instance-method"
          ]
        }
      ],
      [
        true,
        {
          "order": [
            {
              "name": "static non-private",
              "kinds": [
                "public-static-field",
                "protected-static-field",
                "public-static-method",
                "protected-static-method"
              ]
            },
            "constructor"
          ]
        }
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "newline-before-return",
    "description": "Enforces blank line before return when not the only line in the block.",
    "rationale": "Helps maintain a readable style in your codebase.",
    "optionsDescription": "Not configurable.",
    "options": {},
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "newline-per-chained-call",
    "description": "\nRequires that chained method calls be broken apart onto separate lines.",
    "rationale": "\nThis style helps to keep code 'vertical', avoiding the need for side-scrolling in IDEs or text editors.",
    "optionsDescription": "Not configurable",
    "options": null,
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "new-parens",
    "description": "Requires parentheses when invoking a constructor via the `new` keyword.",
    "rationale": "Maintains stylistic consistency with other function calls.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-angle-bracket-type-assertion",
    "description": "Requires the use of `as Type` for type assertions instead of `<Type>`.",
    "hasFix": true,
    "rationale": "\nBoth formats of type assertions have the same effect, but only `as` type assertions\nwork in `.tsx` files. This rule ensures that you have a consistent type assertion style\nacross your codebase.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-any",
    "description": "Disallows usages of `any` as a type declaration.",
    "hasFix": false,
    "rationale": "\nUsing `any` as a type declaration nullifies the compile-time benefits of the type system.\n\nIf you're dealing with data of unknown or \"any\" types, you shouldn't be accessing members of it.\nEither add type annotations for properties that may exist or change the data type to the empty object type `{}`.\n\nAlternately, if you're creating storage or handling for consistent but unknown types, such as in data structures\nor serialization, use `<T>` template types for generic type handling.\n\nAlso see the `no-unsafe-any` rule.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-arg",
    "description": "Disallows use of `arguments.callee`.",
    "rationale": "\nUsing `arguments.callee` makes various performance optimizations impossible.\nSee [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)\nfor more details on why to avoid `arguments.callee`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-bitwise",
    "description": "Disallows bitwise operators.",
    "descriptionDetails": "\nSpecifically, the following bitwise operators are banned:\n`&`, `&=`, `|`, `|=`,\n`^`, `^=`, `<<`, `<<=`,\n`>>`, `>>=`, `>>>`, `>>>=`, and `~`.\nThis rule does not ban the use of `&` and `|` for intersection and union types.",
    "rationale": "\nBitwise operators are often typos - for example `bool1 & bool2` instead of `bool1 && bool2`.\nThey also can be an indicator of overly clever code which decreases maintainability.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-boolean-literal-compare",
    "description": "Warns on comparison to a boolean literal, as in `x === true`.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nComparing boolean values to boolean literals is unnecessary, as those expressions will result in booleans too.\nJust use the boolean values directly or negate them.\n        ",
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-conditional-assignment",
    "description": "Disallows any type of assignment in conditionals.",
    "descriptionDetails": "This applies to `do-while`, `for`, `if`, and `while` statements and conditional (ternary) expressions.",
    "rationale": "\nAssignments in conditionals are often typos:\nfor example `if (var1 = var2)` instead of `if (var1 == var2)`.\nThey also can be an indicator of overly clever code which decreases maintainability.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-consecutive-blank-lines",
    "description": "Disallows one or more blank lines in a row.",
    "hasFix": true,
    "rationale": "\nHelps maintain a readable style in your codebase.\n\nExtra blank lines take up extra space and add little to a semantic understanding of the code.\nIt can be harder to read through files when fewer components can fit into the screen.\nIf you find a file is so large you feel a need to split them up with extra blank lines or comments,\nconsider splitting your file into smaller files.\n        ",
    "optionsDescription": "\nAn optional number of maximum allowed sequential blanks can be specified. If no value\nis provided, a default of 1 will be used.",
    "options": {
      "type": "number",
      "minimum": "1"
    },
    "optionExamples": [
      true,
      [
        true,
        2
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-console",
    "description": "Bans the use of specified `console` methods.",
    "rationale": "In general, `console` methods aren't appropriate for production code.",
    "optionsDescription": "A list of method names to ban. If no method names are provided, all console methods are banned.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "optionExamples": [
      [
        true,
        "log",
        "error"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-construct",
    "description": "Disallows access to the constructors of `String`, `Number`, and `Boolean`.",
    "descriptionDetails": "Disallows constructor use such as `new Number(foo)` but does not disallow `Number(foo)`.",
    "rationale": "\nThere is little reason to use `String`, `Number`, or `Boolean` as constructors.\nIn almost all cases, the regular function-call version is more appropriate.\n[More details](http://stackoverflow.com/q/4719320/3124288) are available on StackOverflow.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-debugger",
    "description": "Disallows `debugger` statements.",
    "rationale": "In general, `debugger` statements aren't appropriate for production code.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-default-export",
    "description": "Disallows default exports in ES6-style modules.",
    "descriptionDetails": "Use named exports instead.",
    "rationale": "\nNamed imports/exports [promote clarity](https://github.com/palantir/tslint/issues/1182#issue-151780453).\nIn addition, current tooling differs on the correct way to handle default imports/exports.\nAvoiding them all together can help avoid tooling bugs and conflicts.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-imports",
    "description": "\nDisallows multiple import statements from the same module.",
    "rationale": "\nUsing a single import statement per module will make the code clearer because you can see everything being imported\nfrom that module on one line.",
    "optionsDescription": "Not configurable",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-super",
    "description": "Warns if 'super()' appears twice in a constructor.",
    "rationale": "The second call to 'super()' will fail at runtime.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Prevents duplicate cases in switch statements.",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "",
    "ruleName": "no-duplicate-switch-case",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-variable",
    "description": "Disallows duplicate variable declarations in the same block scope.",
    "descriptionDetails": "\nThis rule is only useful when using the `var` keyword -\nthe compiler will detect redeclarations of `let` and `const` variables.",
    "rationale": "\nA variable can be reassigned if necessary -\nthere's no good reason to have a duplicate variable declaration.",
    "optionsDescription": "You can specify `\"check-parameters\"` to check for variables with the same name as a parameter.",
    "options": {
      "type": "string",
      "enum": [
        "check-parameters"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "check-parameters"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Bans usage of the delete operator with computed key expressions.",
    "optionExamples": [
      true
    ],
    "options": null,
    "optionsDescription": "Not configurable.",
    "rationale": "\nDeleting dynamically computed keys is dangerous and not well optimized.\n\nAlso consider using a [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\nor [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\nif you're storing collections of objects.\nUsing `Object`s can cause occasional edge case bugs, such as if a key is named \"hasOwnProperty\".\n        ",
    "ruleName": "no-dynamic-delete",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-empty-interface",
    "description": "Forbids empty interfaces.",
    "rationale": "An empty interface is equivalent to its supertype (or `{}`).",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-empty",
    "description": "Disallows empty blocks.",
    "descriptionDetails": "Blocks with a comment inside are not considered empty.",
    "rationale": "Empty blocks are often indicators of missing code.",
    "optionsDescription": "\nIf `allow-empty-catch` is specified, then catch blocks are allowed to be empty.\nIf `allow-empty-functions` is specified, then function definitions are allowed to be empty.",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "allow-empty-catch"
            ]
          },
          {
            "type": "string",
            "enum": [
              "allow-empty-functions"
            ]
          }
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-empty-catch"
      ],
      [
        true,
        "allow-empty-functions"
      ],
      [
        true,
        "allow-empty-catch",
        "allow-empty-functions"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-eval",
    "description": "Disallows `eval` function invocations.",
    "rationale": "\n`eval()` is dangerous as it allows arbitrary code execution with full privileges. There are\n[alternatives](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)\nfor most of the use cases for `eval()`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-floating-promises",
    "description": "Promises returned by functions must be handled appropriately.",
    "descriptionDetails": "Unhandled Promises can cause unexpected behavior, such as resolving at unexpected times.",
    "optionsDescription": "\nA list of 'string' names of any additional classes that should also be handled as Promises.\n        ",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "JQueryPromise"
      ]
    ],
    "rationale": "\nCreating a Promise and not storing or returning it may let other code run independently of its result.\nThis can cause unexpected and/or non-deterministic behavior depending on external timing factors.\n\nIt's typically better to return Promises from functions that start them, then handle them in calling code.\n\nUse `no-unused-expression` in addition to this rule to reveal even more floating promises.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-for-in-array",
    "description": "Disallows iterating over an array with a for-in loop.",
    "descriptionDetails": "\nA for-in loop (`for (var k in o)`) iterates over the properties of an Object.\n\nWhile it is legal to use for-in loops with array types, it is not common.\nfor-in will iterate over the indices of the array as strings, omitting any \"holes\" in\nthe array.\n\nMore common is to use for-of, which iterates over the values of an array.\nIf you want to iterate over the indices, alternatives include:\n\narray.forEach((value, index) => { ... });\nfor (const [index, value] of array.entries()) { ... }\nfor (let i = 0; i < array.length; i++) { ... }\n",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "requiresTypeInfo": true,
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-implicit-dependencies",
    "description": "Disallows importing modules that are not listed as dependency in the project's package.json",
    "descriptionDetails": "\nDisallows importing transient dependencies and modules installed above your package's root directory.\n        ",
    "optionsDescription": "\nBy default the rule looks at `\"dependencies\"` and `\"peerDependencies\"`.\nBy adding the `\"dev\"` option the rule also looks at `\"devDependencies\"`.\nBy adding the `\"optional\"` option the rule also looks at `\"optionalDependencies\"`.\nAn array of whitelisted modules can be added to skip checking their existence in package.json.\n        ",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "dev",
            "optional"
          ]
        },
        {
          "type": "array"
        }
      ],
      "minItems": 0,
      "maxItems": 3
    },
    "optionExamples": [
      true,
      [
        true,
        "dev"
      ],
      [
        true,
        "optional"
      ],
      [
        true,
        [
          "src",
          "app"
        ]
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Avoid import statements with side-effect.",
    "optionExamples": [
      true,
      [
        true,
        {
          "ignore-module": "(\\.html|\\.css)$"
        }
      ]
    ],
    "options": {
      "items": {
        "properties": {
          "ignore-module": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "maxLength": 1,
      "minLength": 0,
      "type": "array"
    },
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `ignore-module` allows to specify a regex and ignore modules which it matches.",
    "rationale": "Imports with side effects may have behavior which is hard for static verification.",
    "ruleName": "no-import-side-effect",
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-inferrable-types",
    "description": "Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean.",
    "rationale": "Explicit types where they can be easily inferred by the compiler make code more verbose.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `ignore-params` allows specifying an inferrable type annotation for function params.\nThis can be useful when combining with the `typedef` rule.\n* `ignore-properties` allows specifying an inferrable type annotation for class properties.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-params",
          "ignore-properties"
        ]
      },
      "minLength": 0,
      "maxLength": 2
    },
    "hasFix": true,
    "optionExamples": [
      true,
      [
        true,
        "ignore-params"
      ],
      [
        true,
        "ignore-params",
        "ignore-properties"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-inferred-empty-object-type",
    "description": "Disallow type inference of {} (empty object type) at function and constructor call sites",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nWhen function or constructor may be called with a type parameter but one isn't supplied or inferrable,\nTypeScript defaults to `{}`.\nThis is often undesirable as the call is meant to be of a more specific type.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-internal-module",
    "description": "Disallows internal `module`",
    "rationale": "Using `module` leads to a confusion of concepts with external modules. Use the newer `namespace` keyword instead.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "no-invalid-template-strings",
    "description": "Warns on use of `${` in non-template strings.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "Interpolation will only work for template strings.",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-invalid-this",
    "description": "Disallows using the `this` keyword outside of classes.",
    "rationale": "See [the rule's author's rationale here.](https://github.com/palantir/tslint/pull/1105#issue-147549402)",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `check-function-in-method` disallows using the `this` keyword in functions within class methods.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-function-in-method"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "check-function-in-method"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-irregular-whitespace",
    "description": "Disallow irregular whitespace within a file, including strings and comments.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-magic-numbers",
    "description": "\nDisallows the use constant number values outside of variable assignments.\nWhen no list of allowed values is specified, -1, 0 and 1 are allowed by default.",
    "rationale": "\nMagic numbers should be avoided as they often lack documentation.\nForcing them to be stored in variables gives them implicit documentation.\n        ",
    "optionsDescription": "A list of allowed numbers.",
    "options": {
      "type": "array",
      "items": {
        "type": "number"
      },
      "minLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        1,
        2,
        3
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-mergeable-namespace",
    "description": "Disallows mergeable namespaces in the same file.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-misused-new",
    "description": "Warns on apparent attempts to define constructors for interfaces or `new` for classes.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nInterfaces in TypeScript aren't meant to describe constructors on their implementations.\nThe `new` descriptor is primarily for describing JavaScript libraries.\nIf you're trying to describe a function known to be a class, it's typically better to `declare class`.\n        ",
    "type": "functionality",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-namespace",
    "description": "Disallows use of internal `module`s and `namespace`s.",
    "descriptionDetails": "This rule still allows the use of `declare module ... {}`",
    "rationale": "\nES6-style external modules are the standard way to modularize code.\nUsing `module {}` and `namespace {}` are outdated ways to organize TypeScript code.",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `allow-declarations` allows `declare namespace ... {}` to describe external APIs.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-declarations"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-declarations"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-non-null-assertion",
    "description": "Disallows non-null assertions using the `!` postfix operator.",
    "rationale": "\nUsing non-null assertion cancels the benefits of the strict null checking mode.\n\nInstead of assuming objects exist:\n\n```\nfunction foo(instance: MyClass | undefined) {\n    instance!.doWork();\n}\n```\n\nEither inform the strict type system that the object must exist:\n\n```\nfunction foo(instance: MyClass) {\n    instance.doWork();\n}\n```\n\nOr verify that the instance exists, which will inform the type checker:\n\n```\nfunction foo(instance: MyClass | undefined) {\n    if (instance !== undefined) {\n        instance.doWork();\n    }\n}\n```\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-null-keyword",
    "description": "Disallows use of the `null` keyword literal.",
    "rationale": "\nInstead of having the dual concepts of `null` and`undefined` in a codebase,\nthis rule ensures that only `undefined` is used.\n\nJavaScript originally intended `undefined` to refer to a value that doesn't yet exist,\nwhile `null` was meant to refer to a value that does exist but points to nothing.\nThat's confusing.\n`undefined` is the default value when object members don't exist, and is the return value\nfor newer native collection APIs such as `Map.get` when collection values don't exist.\n\n```\nconst myObject = {};\nmyObject.doesNotExist; // undefined\n```\n\n```\nconst myMap = new Map<string, number>();\nmyMap.get(\"doesNotExist\"); // undefined\n```\n\nTo remove confusion over the two similar values, it's better to stick with just `undefined`.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-object-literal-type-assertion",
    "description": "\nForbids an object literal to appear in a type assertion expression.\nCasting to `any` is still allowed.",
    "rationale": "\nAlways prefer `const x: T = { ... };` to `const x = { ... } as T;`.\nThe type assertion in the latter case is either unnecessary or hides an error.\nThe compiler will warn for excess properties with this syntax, but not missing required fields.\nFor example: `const x: { foo: number } = {}` will fail to compile, but\n`const x = {} as { foo: number }` will succeed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-parameter-properties",
    "description": "Disallows parameter properties in class constructors.",
    "rationale": "\nParameter properties can be confusing to those new to TS as they are less explicit\nthan other ways of declaring and initializing class members.\n\nIt can be cleaner to keep member variable declarations in one list directly only the class\n(instead of mixed between direct class members and constructor parameter properties).\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-parameter-reassignment",
    "description": "Disallows reassigning parameters.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-redundant-jsdoc",
    "description": "Forbids JSDoc which duplicates TypeScript functionality.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-reference-import",
    "description": "Don't `<reference types=\"foo\" />` if you import `foo` anyway.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-reference",
    "description": "Disallows `/// <reference path=>` imports (use ES6-style imports instead).",
    "rationale": "\nUsing `/// <reference path=>` comments to load other files is outdated.\nUse ES6-style imports to reference other files.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-require-imports",
    "description": "Disallows invocation of `require()`.",
    "rationale": "Prefer the newer ES6-style imports over `require()`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-return-await",
    "description": "Disallows unnecessary `return await`.",
    "rationale": "\nAn async function always wraps the return value in a Promise.\nUsing `return await` just adds extra time before the overreaching promise is resolved without changing the semantics.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-shadowed-variable",
    "description": "Disallows shadowing variable declarations.",
    "rationale": "\nShadowing a variable masks access to it and obscures to what value an identifier actually refers.\nFor example, in the following code, it can be confusing why the filter is likely never true:\n\n```\nconst findNeighborsWithin = (instance: MyClass, instances: MyClass[]): MyClass[] => {\n    return instances.filter((instance) => instance.neighbors.includes(instance));\n};\n```\n        ",
    "optionsDescription": "\nYou can optionally pass an object to disable checking for certain kinds of declarations.\nPossible keys are `\"class\"`, `\"enum\"`, `\"function\"`, `\"import\"`, `\"interface\"`, `\"namespace\"`, `\"typeAlias\"`\nand `\"typeParameter\"`. Just set the value to `false` for the check you want to disable.\nAll checks default to `true`, i.e. are enabled by default.\nNote that you cannot disable variables and parameters.\n\nThe option `\"temporalDeadZone\"` defaults to `true` which shows errors when shadowing block scoped declarations in their\ntemporal dead zone. When set to `false` parameters, classes, enums and variables declared\nwith `let` or `const` are not considered shadowed if the shadowing occurs within their\n[temporal dead zone](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified).\n\nThe following example shows how the `\"temporalDeadZone\"` option changes the linting result:\n\n```ts\nfunction fn(value) {\n    if (value) {\n        const tmp = value; // no error on this line if \"temporalDeadZone\" is false\n        return tmp;\n    }\n    let tmp = undefined;\n    if (!value) {\n        const tmp = value; // this line always contains an error\n        return tmp;\n    }\n}\n```\n        ",
    "options": {
      "type": "object",
      "properties": {
        "class": {
          "type": "boolean"
        },
        "enum": {
          "type": "boolean"
        },
        "function": {
          "type": "boolean"
        },
        "import": {
          "type": "boolean"
        },
        "interface": {
          "type": "boolean"
        },
        "namespace": {
          "type": "boolean"
        },
        "typeAlias": {
          "type": "boolean"
        },
        "typeParameter": {
          "type": "boolean"
        },
        "temporalDeadZone": {
          "type": "boolean"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "class": true,
          "enum": true,
          "function": true,
          "interface": false,
          "namespace": true,
          "typeAlias": false,
          "typeParameter": false
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-sparse-arrays",
    "description": "Forbids array literals to contain missing elements.",
    "rationale": "Missing elements are probably an accidentally duplicated comma.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-string-literal",
    "description": "\nForbids unnecessary string literal property access.\nAllows `obj[\"prop-erty\"]` (can't be a regular property access).\nDisallows `obj[\"property\"]` (should be `obj.property`).",
    "rationale": "\nIf `--noImplicitAny` is turned off,\nproperty access via a string literal will be 'any' if the property does not exist.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-string-throw",
    "description": "Flags throwing plain strings or concatenations of strings.",
    "hasFix": true,
    "options": null,
    "optionExamples": [
      true
    ],
    "optionsDescription": "Not configurable.",
    "rationale": "\nExample  Doing it right\n\n```ts\n// throwing an Error from typical function, whether sync or async\nif (!productToAdd) {\n    throw new Error(\"How can I add new product when no value provided?\");\n}\n```\n\nExample  Anti Pattern\n\n```ts\n// throwing a string lacks any stack trace information and other important data properties\nif (!productToAdd) {\n    throw (\"How can I add new product when no value provided?\");\n}\n```\n\nOnly Error objects contain a `.stack` member equivalent to the current stack trace.\nPrimitives such as strings do not.\n        ",
    "codeExamples": [
      {
        "description": "Flags throwing plain strings or concatenations of strings.",
        "config": "```json\n\"rules\": { \"no-string-throw\": true }\n```",
        "pass": "```ts\ntry {\n    // ...\n} catch (e) {\n    throw e;\n}\n```",
        "fail": "```ts\ntry {\n    // ...\n} catch {\n    throw 'There was a problem.';\n}\n```"
      }
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-submodule-imports",
    "description": "\nDisallows importing any submodule.",
    "rationale": "\nSubmodules of some packages are treated as private APIs and the import\npaths may change without deprecation periods. It's best to stick with\ntop-level package exports.",
    "optionsDescription": "A list of whitelisted package or submodule names.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "rxjs",
        "@angular/platform-browser",
        "@angular/core/testing"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-switch-case-fall-through",
    "description": "Disallows falling through case statements.",
    "descriptionDetails": "\nFor example, the following is not allowed:\n\n```ts\nswitch(foo) {\n    case 1:\n        someFunc(foo);\n    case 2:\n        someOtherFunc(foo);\n}\n```\n\nHowever, fall through is allowed when case statements are consecutive or\na magic `/* falls through */` comment is present. The following is valid:\n\n```ts\nswitch(foo) {\n    case 1:\n        someFunc(foo);\n        /* falls through */\n    case 2:\n    case 3:\n        someOtherFunc(foo);\n}\n```",
    "rationale": "Fall though in switch statements is often unintentional and a bug.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Disallows unnecessary references to `this`.",
    "optionExamples": [
      true,
      [
        true,
        {
          "allowed-names": [
            "^self$"
          ],
          "allow-destructuring": true
        }
      ]
    ],
    "options": {
      "additionalProperties": false,
      "properties": {
        "allow-destructuring": {
          "type": "boolean"
        },
        "allowed-names": {
          "listType": "string",
          "type": "list"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nTwo options may be provided on an object:\n\n* `allow-destructuring` allows using destructuring to access members of `this` (e.g. `{ foo, bar } = this;`).\n* `allowed-names` may be specified as a list of regular expressions to match allowed variable names.",
    "rationale": "\nAssigning a variable to `this` instead of properly using arrow lambdas may be a symptom of pre-ES6 practices\nor not managing scope well.\n\nInstead of storing a reference to `this` and using it inside a `function () {`:\n\n```\nconst self = this;\n\nsetTimeout(function () {\n    self.doWork();\n});\n```\n\nUse `() =>` arrow lambdas, as they preserve `this` scope for you:\n\n```\nsetTimeout(() => {\n    this.doWork();\n});\n```\n        ",
    "ruleName": "no-this-assignment",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-trailing-whitespace",
    "description": "Disallows trailing whitespace at the end of a line.",
    "rationale": "Keeps version control diffs clean as it prevents accidental whitespace from being committed.",
    "optionsDescription": "\nPossible settings are:\n\n* `\"ignore-template-strings\"`: Allows trailing whitespace in template strings.\n* `\"ignore-comments\"`: Allows trailing whitespace in comments.\n* `\"ignore-jsdoc\"`: Allows trailing whitespace only in JSDoc comments.\n* `\"ignore-blank-lines\"`: Allows trailing whitespace on empty lines.",
    "hasFix": true,
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-comments",
          "ignore-jsdoc",
          "ignore-template-strings",
          "ignore-blank-lines"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-comments"
      ],
      [
        true,
        "ignore-jsdoc"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unbound-method",
    "description": "Warns when a method is used outside of a method call.",
    "optionsDescription": "You may optionally pass \"ignore-static\" to ignore static methods.",
    "options": {
      "type": "string",
      "enum": [
        "ignore-static"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-static"
      ]
    ],
    "rationale": "\nClass functions don't preserve the class scope when passed as standalone variables.\nFor example, this code will log the global scope (`window`/`global`), not the class instance:\n\n```\nclass MyClass {\n    public log(): void {\n        console.log(this);\n    }\n}\n\nconst instance = new MyClass();\nconst log = instance.log;\n\nlog();\n```\n\nYou need to either use an arrow lambda (`() => {...}`) or call the function with the correct scope.\n\n```\nclass MyClass {\n    public logArrowBound = (): void => {\n        console.log(bound);\n    };\n\n    public logManualBind(): void {\n        console.log(this);\n    }\n}\n\nconst instance = new MyClass();\nconst logArrowBound = instance.logArrowBound;\nconst logManualBind = instance.logManualBind.bind(instance);\n\nlogArrowBound();\nlogManualBind();\n```\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unnecessary-callback-wrapper",
    "description": "\nReplaces `x => f(x)` with just `f`.\nTo catch more cases, enable `only-arrow-functions` and `arrow-return-shorthand` too.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nThere's generally no reason to wrap a function with a callback wrapper if it's directly called anyway.\nDoing so creates extra inline lambdas that slow the runtime down.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unnecessary-class",
    "description": "\nDisallows classes that are not strictly necessary.",
    "rationale": "\nUsers who come from a Java-style OO language may wrap\ntheir utility functions in an extra class, instead of\nputting them at the top level.",
    "optionsDescription": "\nThree arguments may be optionally provided:\n\n* `\"allow-constructor-only\"` ignores classes whose members are constructors.\n* `\"allow-empty-class\"` ignores `class DemoClass {}`.\n* `\"allow-static-only\"` ignores classes whose members are static.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        "allow-empty-class",
        "allow-constructor-only"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unnecessary-initializer",
    "description": "Forbids a 'var'/'let' statement or destructuring initializer to be initialized to 'undefined'.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nValues in JavaScript default to `undefined`.\nThere's no need to do so manually.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unnecessary-qualifier",
    "description": "Warns when a namespace qualifier (`A.x`) is unnecessary.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unnecessary-type-assertion",
    "description": "Warns if a type assertion does not change the type of an expression.",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionsDescription": "A list of whitelisted assertion types to ignore",
    "type": "typescript",
    "hasFix": true,
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unsafe-any",
    "description": "\nWarns when using an expression of type 'any' in a dynamic way.\nUses are only allowed if they would work for `{} | null | undefined`.\nType casts and tests are allowed.\nExpressions that work on all values (such as `\"\" + x`) are allowed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nIf you're dealing with data of unknown or \"any\" types, you shouldn't be accessing members of it.\nEither add type annotations for properties that may exist or change the data type to the empty object type `{}`.\n\nAlternately, if you're creating storage or handling for consistent but unknown types, such as in data structures\nor serialization, use `<T>` template types for generic type handling.\n\nAlso see the `no-any` rule.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unsafe-finally",
    "description": "\nDisallows control flow statements, such as `return`, `continue`,\n`break` and `throws` in finally blocks.",
    "descriptionDetails": "",
    "rationale": "\nWhen used inside `finally` blocks, control flow statements,\nsuch as `return`, `continue`, `break` and `throws`\noverride any other control flow statements in the same try/catch scope.\nThis is confusing and unexpected behavior.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unused-expression",
    "description": "Disallows unused expression statements.",
    "descriptionDetails": "\nUnused expressions are expression statements which are not assignments or function calls\n(and thus usually no-ops).",
    "rationale": "\nDetects potential errors where an assignment or function call was intended.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `allow-fast-null-checks` allows to use logical operators to perform fast null checks and perform\nmethod or function calls for side effects (e.g. `e && e.preventDefault()`).\n* `allow-new` allows 'new' expressions for side effects (e.g. `new ModifyGlobalState();`.\n* `allow-tagged-template` allows tagged templates for side effects (e.g. `this.add\\`foo\\`;`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-fast-null-checks",
          "allow-new",
          "allow-tagged-template"
        ]
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-fast-null-checks"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unused-variable",
    "description": "\nDisallows unused imports, variables, functions and\nprivate class members. Similar to tsc's --noUnusedParameters and --noUnusedLocals\noptions, but does not interrupt code compilation.",
    "descriptionDetails": "\nIn addition to avoiding compilation errors, this rule may still be useful if you\nwish to have `tslint` automatically remove unused imports, variables, functions,\nand private class members, when using TSLint's `--fix` option.",
    "hasFix": true,
    "optionsDescription": "\nThree optional arguments may be optionally provided:\n\n* `\"check-parameters\"` disallows unused function and constructor parameters.\n    * NOTE: this option is experimental and does not work with classes\n    that use abstract method declarations, among other things.\n* `{\"ignore-pattern\": \"pattern\"}` where pattern is a case-sensitive regexp.\nVariable names and imports that match the pattern will be ignored.",
    "options": {
      "type": "array",
      "items": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "check-parameters"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ignore-pattern": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "ignore-pattern": "^_"
        }
      ]
    ],
    "rationale": "\nVariables that are declared and not used anywhere in code are likely an error due to incomplete refactoring.\nSuch variables take up space in the code, are mild performance pains, and can lead to confusion by readers.\n        ",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true,
    "deprecationMessage": "Since TypeScript 2.9. Please use the built-in compiler checks instead."
  },
  {
    "ruleName": "no-use-before-declare",
    "description": "Disallows usage of variables before their declaration.",
    "descriptionDetails": "\nThis rule is primarily useful when using the `var` keyword since the compiler will\nautomatically detect if a block-scoped `let` and `const` variable is used before\ndeclaration. Since most modern TypeScript doesn't use `var`, this rule is generally\ndiscouraged and is kept around for legacy purposes. It is slow to compute, is not\nenabled in the built-in configuration presets, and should not be used to inform TSLint\ndesign decisions.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true,
    "codeExamples": [
      {
        "description": "Check that referenced variables are declared beforehand (default)",
        "config": "```json\n\"rules\": { \"no-use-before-declare\": true }\n```",
        "pass": "```ts\nvar hello = 'world';\nvar foo;\n\nconsole.log(hello, foo, capitalize(hello));\n// 'world', undefined, 'WORLD'\n\nfunction capitalize(val) {\n    return val.toUpperCase();\n}\n\nimport { default as foo1 } from \"./lib\";\nimport foo2 from \"./lib\";\nimport _, { map, foldl } from \"./underscore\";\nimport * as foo3 from \"./lib\";\nimport \"./lib\";\n\nfunction declaredImports() {\n    console.log(foo1);\n    console.log(foo2);\n    console.log(foo3);\n    map([], (x) => x);\n}\n```",
        "fail": "```ts\nconsole.log(hello, foo);\n\nvar hello = 'world';\nvar foo;\n\nfunction undeclaredImports() {\n    console.log(foo1);\n    console.log(foo2);\n    console.log(foo3);\n    map([], (x) => x);\n}\n\nimport { default as foo1 } from \"./lib\";\nimport foo2 from \"./lib\";\nimport _, { map, foldl } from \"./underscore\";\nimport * as foo3 from \"./lib\";\nimport \"./lib\";\n```"
      }
    ]
  },
  {
    "ruleName": "no-var-keyword",
    "description": "Disallows usage of the `var` keyword.",
    "descriptionDetails": "Use `let` or `const` instead.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nDeclaring variables using `var` has several edge case behaviors that make `var` unsuitable for modern code.\nVariables declared by `var` have their parent function block as their scope, ignoring other control flow statements.\n`var`s have declaration \"hoisting\" (similar to `function`s) and can appear to be used before declaration.\n\nVariables declared by `const` and `let` instead have as their scope the block in which they are defined,\nand are not allowed to used before declaration or be re-declared with another `const` or `let`.\n        ",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-var-requires",
    "description": "Disallows the use of require statements except in import statements.",
    "descriptionDetails": "\nIn other words, the use of forms such as `var module = require(\"module\")` are banned.\nInstead use ES2015-style imports or `import foo = require('foo')` imports.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nAMD-style `require([])` and CommonJS-style `require(\"\")` statements are environment-specific\nand more difficult to statically analyze.\n\nES2015-style `import`s are part of the JavaScript language specfication and recommended as the path going forward.\nTypeScript will compile them to environment-specific forms as needed.\n        ",
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-void-expression",
    "description": "Requires expressions of type `void` to appear in statement position.",
    "optionsDescription": "\nIf `ignore-arrow-function-shorthand` is provided, `() => returnsVoid()` will be allowed.\nOtherwise, it must be written as `() => { returnsVoid(); }`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-arrow-function-shorthand"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "rationale": "\nIt's misleading returning the results of an expression whose type is `void`.\nAttempting to do so is likely a symptom of expecting a different return type from a function.\nFor example, the following code will log `undefined` but looks like it logs a value:\n\n```\nconst performWork = (): void => {\n    workFirst();\n    workSecond();\n};\n\nconsole.log(performWork());\n```\n        ",
    "requiresTypeInfo": true,
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "number-literal-format",
    "description": "Checks that decimal literals should begin with '0.' instead of just '.', and should not end with a trailing '0'.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "\nHelps keep a consistent style with numeric literals.\nNon-standard literals are more difficult to scan through and can be a symptom of typos.\n        ",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-key-quotes",
    "description": "Enforces consistent object literal property quote style.",
    "descriptionDetails": "\nObject literal property names can be defined in two ways: using literals or using strings.\nFor example, these two objects are equivalent:\n\nvar object1 = {\n    property: true\n};\n\nvar object2 = {\n    \"property\": true\n};\n\nIn many cases, it doesnt matter if you choose to use an identifier instead of a string\nor vice-versa. Even so, you might decide to enforce a consistent style in your code.\n\nThis rules lets you enforce consistent quoting of property names. Either they should always\nbe quoted (default behavior) or quoted only as needed (\"as-needed\").",
    "hasFix": true,
    "optionsDescription": "\nPossible settings are:\n\n* `\"always\"`: Property names should always be quoted. (This is the default.)\n* `\"as-needed\"`: Only property names which require quotes may be quoted (e.g. those with spaces in them).\n* `\"consistent\"`: Property names should either all be quoted or unquoted.\n* `\"consistent-as-needed\"`: If any property name requires quotes, then all properties must be quoted. Otherwise, no\nproperty names may be quoted.\n\nFor ES6, computed property names (`{[name]: value}`) and methods (`{foo() {}}`) never need\nto be quoted.",
    "options": {
      "type": "string",
      "enum": [
        "always",
        "as-needed",
        "consistent",
        "consistent-as-needed"
      ]
    },
    "optionExamples": [
      [
        true,
        "as-needed"
      ],
      [
        true,
        "always"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-shorthand",
    "description": "Enforces/disallows use of ES6 object literal shorthand.",
    "hasFix": true,
    "optionsDescription": "\nIf the 'never' option is provided, any shorthand object literal syntax will cause a failure.",
    "options": {
      "type": "string",
      "enum": [
        "never"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "never"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-sort-keys",
    "description": "\nChecks ordering of keys in object literals.\n\nWhen using the default alphabetical ordering, additional blank lines may be used to group\nobject properties together while keeping the elements within each group in alphabetical order.\n        ",
    "rationale": "Useful in preventing merge conflicts",
    "optionsDescription": "\nBy default, this rule checks that keys are in alphabetical order.\nThe following may optionally be passed:\n\n* \"ignore-case\" will compare keys in a case insensitive way.\n* \"match-declaration-order\" will prefer to use the key ordering of the contextual type of the object literal, as in:\n\n    interface I { foo: number; bar: number; }\n    const obj: I = { foo: 1, bar: 2 };\n\nIf a contextual type is not found, alphabetical ordering will be used instead.\n* \"shorthand-first\" will enforce shorthand properties to appear first, as in:\n\n    const obj = { a, c, b: true };\n",
    "options": {
      "type": "string",
      "enum": [
        "ignore-case",
        "match-declaration-order",
        "shorthand-first"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-case",
        "match-declaration-order",
        "shorthand-first"
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "one-line",
    "description": "Requires the specified tokens to be on the same line as the expression preceding them.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"check-catch\"` checks that `catch` is on the same line as the closing brace for `try`.\n* `\"check-finally\"` checks that `finally` is on the same line as the closing brace for `catch`.\n* `\"check-else\"` checks that `else` is on the same line as the closing brace for `if`.\n* `\"check-open-brace\"` checks that an open brace falls on the same line as its preceding expression.\n* `\"check-whitespace\"` checks preceding whitespace for the specified tokens.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-catch",
          "check-finally",
          "check-else",
          "check-open-brace",
          "check-whitespace"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "check-catch",
        "check-finally",
        "check-else"
      ]
    ],
    "type": "style",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "one-variable-per-declaration",
    "description": "Disallows multiple variable definitions in the same declaration statement.",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `ignore-for-loop` allows multiple variable definitions in a for loop declaration.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-for-loop"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-for-loop"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "only-arrow-functions",
    "description": "Disallows traditional (non-arrow) function expressions.",
    "rationale": "Traditional functions don't bind lexical scope, which can lead to unexpected behavior when accessing 'this'.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `\"allow-declarations\"` allows standalone function declarations.\n* `\"allow-named-functions\"` allows the expression `function foo() {}` but not `function() {}`.\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-declarations",
          "allow-named-functions"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-declarations",
        "allow-named-functions"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "ordered-imports",
    "description": "Requires that import statements be alphabetized and grouped.",
    "descriptionDetails": "\nEnforce a consistent ordering for ES6 imports:\n- Named imports must be alphabetized (i.e. \"import {A, B, C} from \"foo\";\")\n    - The exact ordering can be controlled by the named-imports-order option.\n    - \"longName as name\" imports are ordered by \"longName\".\n- Import sources must be alphabetized within groups, i.e.:\n        import * as foo from \"a\";\n        import * as bar from \"b\";\n- Groups of imports are delineated by blank lines. You can use these to group imports\n    however you like, e.g. by first- vs. third-party or thematically or can you can\n    enforce a grouping of third-party, parent directories and the current directory.",
    "hasFix": true,
    "optionsDescription": "\nYou may set the `\"import-sources-order\"` option to control the ordering of source\nimports (the `\"foo\"` in `import {A, B, C} from \"foo\"`).\n\nPossible values for `\"import-sources-order\"` are:\n\n* `\"case-insensitive'`: Correct order is `\"Bar\"`, `\"baz\"`, `\"Foo\"`. (This is the default.)\n* `\"lowercase-first\"`: Correct order is `\"baz\"`, `\"Bar\"`, `\"Foo\"`.\n* `\"lowercase-last\"`: Correct order is `\"Bar\"`, `\"Foo\"`, `\"baz\"`.\n* `\"any\"`: Allow any order.\n\nYou may set the `\"grouped-imports\"` option to control the grouping of source\nimports (the `\"foo\"` in `import {A, B, C} from \"foo\"`).\n\nPossible values for `\"grouped-imports\"` are:\n\n* `false`: Do not enforce grouping. (This is the default.)\n* `true`: Group source imports by `\"bar\"`, `\"../baz\"`, `\"./foo\"`.\n\nYou may set the `\"named-imports-order\"` option to control the ordering of named\nimports (the `{A, B, C}` in `import {A, B, C} from \"foo\"`).\n\nPossible values for `\"named-imports-order\"` are:\n\n* `\"case-insensitive'`: Correct order is `{A, b, C}`. (This is the default.)\n* `\"lowercase-first\"`: Correct order is `{b, A, C}`.\n* `\"lowercase-last\"`: Correct order is `{A, C, b}`.\n* `\"any\"`: Allow any order.\n\nYou may set the `\"module-source-path\"` option to control the ordering of imports based full path\nor just the module name\n\nPossible values for `\"module-source-path\"` are:\n\n* `\"full'`: Correct order is  `\"./a/Foo\"`, `\"./b/baz\"`, `\"./c/Bar\"`. (This is the default.)\n* `\"basename\"`: Correct order is `\"./c/Bar\"`, `\"./b/baz\"`, `\"./a/Foo\"`.\n\n        ",
    "options": {
      "type": "object",
      "properties": {
        "grouped-imports": {
          "type": "boolean"
        },
        "import-sources-order": {
          "type": "string",
          "enum": [
            "case-insensitive",
            "lowercase-first",
            "lowercase-last",
            "any"
          ]
        },
        "named-imports-order": {
          "type": "string",
          "enum": [
            "case-insensitive",
            "lowercase-first",
            "lowercase-last",
            "any"
          ]
        },
        "module-source-path": {
          "type": "string",
          "enum": [
            "full",
            "basename"
          ]
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "import-sources-order": "lowercase-last",
          "named-imports-order": "lowercase-first"
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-conditional-expression",
    "description": "\nRecommends to use a conditional expression instead of assigning to the same thing in each branch of an if statement.",
    "rationale": "\nThis reduces duplication and can eliminate an unnecessary variable declaration.",
    "optionsDescription": "If `check-else-if` is specified, the rule also checks nested if-else-if statements.",
    "options": {
      "type": "string",
      "enum": [
        "check-else-if"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "check-else-if"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-const",
    "description": "Requires that variable declarations use `const` instead of `let` and `var` if possible.",
    "descriptionDetails": "\nIf a variable is only assigned to once when it is declared, it should be declared using 'const'",
    "hasFix": true,
    "optionsDescription": "\nAn optional object containing the property \"destructuring\" with two possible values:\n\n* \"any\" (default) - If any variable in destructuring can be const, this rule warns for those variables.\n* \"all\" - Only warns if all variables in destructuring can be const.",
    "options": {
      "type": "object",
      "properties": {
        "destructuring": {
          "type": "string",
          "enum": [
            "all",
            "any"
          ]
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "destructuring": "all"
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-for-of",
    "description": "Recommends a 'for-of' loop over a standard 'for' loop if the index is only used to access the array being iterated.",
    "rationale": "A for(... of ...) loop is easier to implement and read when the index is not needed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-function-over-method",
    "description": "Warns for class methods that do not use 'this'.",
    "optionsDescription": "\n\"allow-public\" excludes checking of public methods.\n\"allow-protected\" excludes checking of protected methods.",
    "options": {
      "type": "string",
      "enum": [
        "allow-public",
        "allow-protected"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-public",
        "allow-protected"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-method-signature",
    "description": "Prefer `foo(): void` over `foo: () => void` in interfaces and types.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-object-spread",
    "description": "Enforces the use of the ES2015 object spread operator over `Object.assign()` where appropriate.",
    "rationale": "Object spread allows for better type checking and inference.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "description": "Requires that private variables are marked as `readonly` if they're never modified outside of the constructor.",
    "descriptionDetails": "\nIf a private variable is only assigned to in the constructor, it should be declared as `readonly`.\n        ",
    "optionExamples": [
      true,
      [
        true,
        "only-inline-lambdas"
      ]
    ],
    "options": {
      "enum": [
        "only-inline-lambdas"
      ],
      "type": "string"
    },
    "optionsDescription": "\nIf `only-inline-lambdas` is specified, only immediately-declared arrow functions are checked.",
    "rationale": "\nMarking never-modified variables as readonly helps enforce the code's intent of keeping them as never-modified.\nIt can also help prevent accidental changes of members not meant to be changed.",
    "requiresTypeInfo": true,
    "ruleName": "prefer-readonly",
    "type": "maintainability",
    "typescriptOnly": true
  },
  {
    "ruleName": "prefer-switch",
    "description": "Prefer a `switch` statement to an `if` statement with simple `===` comparisons.",
    "optionsDescription": "\nAn optional object with the property 'min-cases'.\nThis is the number cases needed before a switch statement is recommended.\nDefaults to 3.",
    "options": {
      "type": "object",
      "properties": {
        "min-cases": {
          "type": "number"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "min-cases": 2
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-template",
    "description": "Prefer a template expression over string literal concatenation.",
    "optionsDescription": "\nIf `allow-single-concat` is specified, then a single concatenation (`x + y`) is allowed, but not more (`x + y + z`).",
    "options": {
      "type": "string",
      "enum": [
        "allow-single-concat"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-single-concat"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-while",
    "description": "Prefer `while` loops instead of `for` loops without an initializer and incrementor.",
    "rationale": "Simplifies the readability of the loop statement, while maintaining the same functionality.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "hasFix": true,
    "type": "style",
    "typescriptOnly": false,
    "codeExamples": [
      {
        "description": "Prefer `while` loops instead of `for` loops without an initializer and incrementor.",
        "config": "```json\n\"rules\": { \"prefer-while\": true }\n```",
        "pass": "```ts\nfor(let i = 1; i < 10; i++) {\n    console.log(i);\n}\n\nfor (let i = 0; i < 10; i+=1) {\n    console.log(i);\n}\n\nfor (let i = 0; i < 10;) {\n    i += 1;\n}\n```",
        "fail": "```ts\nfor(;;) {\n    console.log('Hello World');\n}\n\nfor(;true===true;) {\n    console.log('Hello World');\n}\n```"
      }
    ]
  },
  {
    "ruleName": "promise-function-async",
    "description": "Requires any function or method that returns a promise to be marked async.",
    "rationale": "\nEnsures that each function is only capable of 1) returning a rejected promise, or 2)\nthrowing an Error object. In contrast, non-`async` `Promise`-returning functions\nare technically capable of either. This practice removes a requirement for consuming\ncode to handle both cases.\n\nIf no optional arguments are provided then all function types are checked,\notherwise the specific function types are checked:\n\n* `\"check-function-declaration\"` check function declarations.\n* `\"check-function-expression\"` check function expressions.\n* `\"check-arrow-function\"` check arrow functions.\n* `\"check-method-declaration\"` check method declarations.\n        ",
    "optionsDescription": "Not configurable.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-function-declaration",
          "check-function-expression",
          "check-arrow-function",
          "check-method-declaration"
        ]
      },
      "minLength": 0,
      "maxLength": 4
    },
    "optionExamples": [
      true,
      [
        true,
        "check-function-declaration",
        "check-method-declaration"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "quotemark",
    "description": "Requires single or double quotes for string literals.",
    "hasFix": true,
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"single\"` enforces single quotes.\n* `\"double\"` enforces double quotes.\n* `\"jsx-single\"` enforces single quotes for JSX attributes.\n* `\"jsx-double\"` enforces double quotes for JSX attributes.\n* `\"avoid-template\"` forbids single-line untagged template strings that do not contain string interpolations.\n* `\"avoid-escape\"` allows you to use the \"other\" quotemark in cases where escaping would normally be required.\nFor example, `[true, \"double\", \"avoid-escape\"]` would not report a failure on the string literal\n`'Hello \"World\"'`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "single",
          "double",
          "jsx-single",
          "jsx-double",
          "avoid-escape",
          "avoid-template"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "single",
        "avoid-escape",
        "avoid-template"
      ],
      [
        true,
        "single",
        "jsx-double"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "radix",
    "description": "Requires the radix parameter to be specified when calling `parseInt`.",
    "rationale": "\nFrom [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt):\n> Always specify this parameter to eliminate reader confusion and to guarantee predictable behavior.\n> Different implementations produce different results when a radix is not specified, usually defaulting the value to 10.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "restrict-plus-operands",
    "description": "When adding two variables, operands must both be of type number or of type string.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "return-undefined",
    "description": "Prefer `return;` in void functions and `return undefined;` in value-returning functions.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "semicolon",
    "description": "Enforces consistent semicolon usage at the end of every statement.",
    "hasFix": true,
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `\"always\"` enforces semicolons at the end of every statement.\n* `\"never\"` disallows semicolons at the end of every statement except for when they are necessary.\n\nThe following arguments may be optionally provided:\n\n* `\"ignore-interfaces\"` skips checking semicolons at the end of interface members.\n* `\"ignore-bound-class-methods\"` skips checking semicolons at the end of bound class methods.\n* `\"strict-bound-class-methods\"` disables any special handling of bound class methods and treats them as any\nother assignment. This option overrides `\"ignore-bound-class-methods\"`.\n        ",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "always",
            "never"
          ]
        },
        {
          "type": "string",
          "enum": [
            "ignore-interfaces"
          ]
        }
      ],
      "additionalItems": false
    },
    "optionExamples": [
      [
        true,
        "always"
      ],
      [
        true,
        "never"
      ],
      [
        true,
        "always",
        "ignore-interfaces"
      ],
      [
        true,
        "always",
        "ignore-bound-class-methods"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "description": "Require or disallow a space before function parenthesis",
    "hasFix": true,
    "optionExamples": [
      true,
      [
        true,
        "always"
      ],
      [
        true,
        "never"
      ],
      [
        true,
        {
          "anonymous": "always",
          "named": "never",
          "asyncArrow": "always"
        }
      ]
    ],
    "options": {
      "properties": {
        "anonymous": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "asyncArrow": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "constructor": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "method": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "named": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nOne argument which is an object which may contain the keys `anonymous`, `named`, and `asyncArrow`\nThese should be set to either `\"always\"` or `\"never\"`.\n\n* `\"anonymous\"` checks before the opening paren in anonymous functions\n* `\"named\"` checks before the opening paren in named functions\n* `\"asyncArrow\"` checks before the opening paren in async arrow functions\n* `\"method\"` checks before the opening paren in class methods\n* `\"constructor\"` checks before the opening paren in class constructors\n        ",
    "ruleName": "space-before-function-paren",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "space-within-parens",
    "description": "Enforces spaces within parentheses or disallow them.  Empty parentheses () are always allowed.",
    "hasFix": true,
    "optionsDescription": "\nYou may enforce the amount of whitespace within parentheses.\n        ",
    "options": {
      "type": "number",
      "min": 0
    },
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "strict-boolean-expressions",
    "description": "\nRestricts the types allowed in boolean expressions. By default only booleans are allowed.\n\nThe following nodes are checked:\n\n* Arguments to the `!`, `&&`, and `||` operators\n* The condition in a conditional expression (`cond ? x : y`)\n* Conditions for `if`, `for`, `while`, and `do-while` statements.",
    "optionsDescription": "\nThese options may be provided:\n\n* `allow-null-union` allows union types containing `null`.\n  - It does *not* allow `null` itself.\n  - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\n* `allow-undefined-union` allows union types containing `undefined`.\n  - It does *not* allow `undefined` itself.\n  - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\n* `allow-string` allows strings.\n  - It does *not* allow unions containing `string`.\n  - It does *not* allow string literal types.\n* `allow-number` allows numbers.\n  - It does *not* allow unions containing `number`.\n  - It does *not* allow enums or number literal types.\n* `allow-mix` allows multiple of the above to appear together.\n  - For example, `string | number` or `RegExp | null | undefined` would normally not be allowed.\n  - A type like `\"foo\" | \"bar\" | undefined` is always allowed, because it has only one way to be false.\n* `allow-boolean-or-undefined` allows `boolean | undefined`.\n  - Also allows `true | false | undefined`.\n  - Does not allow `false | undefined`.\n  - This option is a subset of `allow-undefined-union`, so you don't need to enable both options at the same time.\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-null-union",
          "allow-undefined-union",
          "allow-string",
          "allow-number",
          "allow-boolean-or-undefined"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-null-union",
        "allow-undefined-union",
        "allow-string",
        "allow-number"
      ],
      [
        true,
        "allow-boolean-or-undefined"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "strict-type-predicates",
    "description": "\nWarns for type predicates that are always true or always false.\nWorks for 'typeof' comparisons to constants (e.g. 'typeof foo === \"string\"'), and equality comparison to 'null'/'undefined'.\n(TypeScript won't let you compare '1 === 2', but it has an exception for '1 === undefined'.)\nDoes not yet work for 'instanceof'.\nDoes *not* warn for 'if (x.y)' where 'x.y' is always truthy. For that, see strict-boolean-expressions.\n\nThis rule requires `strictNullChecks` to work properly.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "switch-default",
    "description": "Require a `default` case in all `switch` statements.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "switch-final-break",
    "description": "Checks whether the final clause of a switch statement ends in `break;`.",
    "hasFix": true,
    "optionsDescription": "\nIf no options are passed, a final 'break;' is forbidden.\nIf the \"always\" option is passed this will require a 'break;' to always be present\nunless control flow is escaped in some other way.",
    "options": {
      "type": "string",
      "enum": [
        "always"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "always"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "trailing-comma",
    "description": "\nRequires or disallows trailing commas in array and object literals, destructuring assignments, function typings,\nnamed imports and exports and function parameters.",
    "hasFix": true,
    "optionsDescription": "\nOne argument which is an object with the keys `multiline` and `singleline`.\nBoth can be set to a string (`\"always\"` or `\"never\"`) or an object.\n\nThe object can contain any of the following keys: `\"arrays\"`, `\"objects\"`, `\"functions\"`,\n`\"imports\"`, `\"exports\"`, and `\"typeLiterals\"`; each key can have one of the following\nvalues: `\"always\"`, `\"never\"`, and `\"ignore\"`. Any missing keys will default to `\"ignore\"`.\n\n* `\"multiline\"` checks multi-line object literals.\n* `\"singleline\"` checks single-line object literals.\n\nAn array is considered \"multiline\" if its closing bracket is on a line\nafter the last array element. The same general logic is followed for\nobject literals, function typings, named import statements\nand function parameters.\n\nTo align this rule with the ECMAScript specification that is implemented in modern JavaScript VMs,\nthere is a third option `esSpecCompliant`. Set this option to `true` to disallow trailing comma on\nobject and array rest and rest parameters.\n        ",
    "options": {
      "type": "object",
      "properties": {
        "multiline": {
          "anyOf": [
            {
              "type": "string",
              "enum": [
                "always",
                "never"
              ]
            },
            {
              "type": "object",
              "properties": {
                "arrays": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "exports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "functions": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "imports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "objects": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "typeLiterals": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                }
              }
            }
          ]
        },
        "singleline": {
          "anyOf": [
            {
              "type": "string",
              "enum": [
                "always",
                "never"
              ]
            },
            {
              "type": "object",
              "properties": {
                "arrays": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "exports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "functions": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "imports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "objects": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "typeLiterals": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                }
              }
            }
          ]
        },
        "esSpecCompliant": {
          "type": "boolean"
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      [
        true,
        {
          "multiline": "always",
          "singleline": "never"
        }
      ],
      [
        true,
        {
          "multiline": {
            "objects": "always",
            "arrays": "always",
            "functions": "never",
            "typeLiterals": "ignore"
          },
          "esSpecCompliant": true
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "triple-equals",
    "description": "Requires `===` and `!==` in place of `==` and `!=`.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `\"allow-null-check\"` allows `==` and `!=` when comparing to `null`.\n* `\"allow-undefined-check\"` allows `==` and `!=` when comparing to `undefined`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-null-check",
          "allow-undefined-check"
        ]
      },
      "minLength": 0,
      "maxLength": 2
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-null-check"
      ],
      [
        true,
        "allow-undefined-check"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "typedef",
    "description": "Requires type definitions to exist.",
    "optionsDescription": "\nSeveral arguments may be optionally provided:\n\n* `\"call-signature\"` checks return type of functions.\n* `\"arrow-call-signature\"` checks return type of arrow functions.\n* `\"parameter\"` checks type specifier of function parameters for non-arrow functions.\n* `\"arrow-parameter\"` checks type specifier of function parameters for arrow functions.\n* `\"property-declaration\"` checks return types of interface properties.\n* `\"variable-declaration\"` checks non-binding variable declarations.\n* `\"member-variable-declaration\"` checks member variable declarations.\n* `\"object-destructuring\"` checks object destructuring declarations.\n* `\"array-destructuring\"` checks array destructuring declarations.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "call-signature",
          "arrow-call-signature",
          "parameter",
          "arrow-parameter",
          "property-declaration",
          "variable-declaration",
          "member-variable-declaration",
          "object-destructuring",
          "array-destructuring"
        ]
      },
      "minLength": 0,
      "maxLength": 7
    },
    "optionExamples": [
      [
        true,
        "call-signature",
        "parameter",
        "member-variable-declaration"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "typedef-whitespace",
    "description": "Requires or disallows whitespace for type definitions.",
    "descriptionDetails": "Determines if a space is required or not before the colon in a type specifier.",
    "optionsDescription": "\nTwo arguments which are both objects.\nThe first argument specifies how much space should be to the _left_ of a typedef colon.\nThe second argument specifies how much space should be to the _right_ of a typedef colon.\nEach key should have a value of `\"onespace\"`, `\"space\"` or `\"nospace\"`.\nPossible keys are:\n\n* `\"call-signature\"` checks return type of functions.\n* `\"index-signature\"` checks index type specifier of indexers.\n* `\"parameter\"` checks function parameters.\n* `\"property-declaration\"` checks object property declarations.\n* `\"variable-declaration\"` checks variable declaration.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "object",
          "properties": {
            "call-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "index-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "parameter": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "property-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "variable-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "call-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "index-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "parameter": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "property-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "variable-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            }
          },
          "additionalProperties": false
        }
      ],
      "additionalItems": false
    },
    "optionExamples": [
      [
        true,
        {
          "call-signature": "nospace",
          "index-signature": "nospace",
          "parameter": "nospace",
          "property-declaration": "nospace",
          "variable-declaration": "nospace"
        },
        {
          "call-signature": "onespace",
          "index-signature": "onespace",
          "parameter": "onespace",
          "property-declaration": "onespace",
          "variable-declaration": "onespace"
        }
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "type-literal-delimiter",
    "description": "\nChecks that type literal members are separated by semicolons.\nEnforces a trailing semicolon for multiline type literals.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "typeof-compare",
    "description": "Makes sure result of `typeof` is compared to correct string values",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "deprecationMessage": "Starting from TypeScript 2.2 the compiler includes this check which makes this rule redundant."
  },
  {
    "ruleName": "unified-signatures",
    "description": "Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "use-default-type-parameter",
    "description": "Warns if an explicitly specified type argument is the default for that type parameter.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      "true"
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "use-isnan",
    "description": "Enforces use of the `isNaN()` function to check for NaN references instead of a comparison to the `NaN` constant.",
    "rationale": "\nSince `NaN !== NaN`, comparisons with regular operators will produce unexpected results.\nSo, instead of `if (myVar === NaN)`, do `if (isNaN(myVar))`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "variable-name",
    "description": "Checks variable names for various errors.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"check-format\"`: allows only lowerCamelCased or UPPER_CASED variable names\n  * `\"allow-leading-underscore\"` allows underscores at the beginning (only has an effect if \"check-format\" specified)\n  * `\"allow-trailing-underscore\"` allows underscores at the end. (only has an effect if \"check-format\" specified)\n  * `\"allow-pascal-case\"` allows PascalCase in addition to lowerCamelCase.\n  * `\"allow-snake-case\"` allows snake_case in addition to lowerCamelCase.\n* `\"ban-keywords\"`: disallows the use of certain TypeScript keywords as variable or parameter names.\n  * These are: `any`, `Number`, `number`, `String`, `string`, `Boolean`, `boolean`, `Undefined`, `undefined`",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-format",
          "allow-leading-underscore",
          "allow-trailing-underscore",
          "allow-pascal-case",
          "allow-snake-case",
          "ban-keywords"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "ban-keywords",
        "check-format",
        "allow-leading-underscore"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "whitespace",
    "description": "Enforces whitespace style conventions.",
    "rationale": "Helps maintain a readable, consistent style in your codebase.",
    "optionsDescription": "\nTen arguments may be optionally provided:\n\n* `\"check-branch\"` checks branching statements (`if`/`else`/`for`/`while`) are followed by whitespace.\n* `\"check-decl\"`checks that variable declarations have whitespace around the equals token.\n* `\"check-operator\"` checks for whitespace around operator tokens.\n* `\"check-module\"` checks for whitespace in import & export statements.\n* `\"check-separator\"` checks for whitespace after separator tokens (`,`/`;`).\n* `\"check-rest-spread\"` checks that there is no whitespace after rest/spread operator (`...`).\n* `\"check-type\"` checks for whitespace before a variable type specification.\n* `\"check-typecast\"` checks for whitespace between a typecast and its target.\n* `\"check-type-operator\"` checks for whitespace between type operators `|` and `&`.\n* `\"check-preblock\"` checks for whitespace before the opening brace of a block",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-branch",
          "check-decl",
          "check-operator",
          "check-module",
          "check-separator",
          "check-rest-spread",
          "check-type",
          "check-typecast",
          "check-type-operator",
          "check-preblock"
        ]
      },
      "minLength": 0,
      "maxLength": 10
    },
    "optionExamples": [
      [
        true,
        "check-branch",
        "check-operator",
        "check-typecast"
      ]
    ],
    "type": "style",
    "typescriptOnly": false,
    "hasFix": true
  }
]