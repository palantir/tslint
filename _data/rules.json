[
  {
    "ruleName": "adjacent-overload-signatures",
    "description": "Enforces function overloads to be consecutive.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "rationale": "Improves readability and organization by grouping naturally related items together.",
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "align",
    "description": "Enforces vertical alignment.",
    "hasFix": true,
    "rationale": "Helps maintain a readable, consistent style in your codebase.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"parameters\"` checks alignment of function parameters.\n* `\"arguments\"` checks alignment of function call arguments.\n* `\"statements\"` checks alignment of statements.\n* `\"members\"` checks alignment of members of classes, interfaces, type literal, object literals and\nobject destructuring.\n* `\"elements\"` checks alignment of elements of array iterals, array destructuring and tuple types.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "arguments",
          "elements",
          "members",
          "parameters",
          "statements"
        ]
      },
      "minLength": 1,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "parameters",
        "statements"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "array-type",
    "description": "Requires using either 'T[]' or 'Array<T>' for arrays.",
    "hasFix": true,
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `\"array\"` enforces use of `T[]` for all types T.\n* `\"generic\"` enforces use of `Array<T>` for all types T.\n* `\"array-simple\"` enforces use of `T[]` if `T` is a simple type (primitive or type reference).",
    "options": {
      "type": "string",
      "enum": [
        "array",
        "generic",
        "array-simple"
      ]
    },
    "optionExamples": [
      [
        true,
        "array"
      ],
      [
        true,
        "generic"
      ],
      [
        true,
        "array-simple"
      ]
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "arrow-parens",
    "description": "Requires parentheses around the parameters of arrow function definitions.",
    "hasFix": true,
    "rationale": "Maintains stylistic consistency with other arrow function definitions.",
    "optionsDescription": "\nIf `ban-single-arg-parens` is specified, then arrow functions with one parameter\nmust not have parentheses if removing them is allowed by TypeScript.",
    "options": {
      "type": "string",
      "enum": [
        "ban-single-arg-parens"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ban-single-arg-parens"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "arrow-return-shorthand",
    "description": "Suggests to convert `() => { return x; }` to `() => x`.",
    "hasFix": true,
    "optionsDescription": "\nIf `multiline` is specified, then this will warn even if the function spans multiple lines.",
    "options": {
      "type": "string",
      "enum": [
        "multiline"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "multiline"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "await-promise",
    "description": "Warns for an awaited value that is not a Promise.",
    "optionsDescription": "\nA list of 'string' names of any additional classes that should also be handled as Promises.\n        ",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "Thenable"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "ban",
    "description": "Bans the use of specific functions or global methods.",
    "optionsDescription": "\nA list of banned functions or methods in the following format:\n\n* banning functions:\n  * just the name of the function: `\"functionName\"`\n  * the name of the function in an array with one element: `[\"functionName\"]`\n  * an object in the following format: `{\"name\": \"functionName\", \"message\": \"optional explanation message\"}`\n* banning methods:\n  * an array with the object name, method name and optional message: `[\"functionName\", \"methodName\", \"optional message\"]`\n  * an object in the following format: `{\"name\": [\"objectName\", \"methodName\"], \"message\": \"optional message\"}`\n    * you can also ban deeply nested methods: `{\"name\": [\"foo\", \"bar\", \"baz\"]}` bans `foo.bar.baz()`\n    * the first element can contain a wildcard (`*`) that matches everything. `{\"name\": [\"*\", \"forEach\"]}` bans                  `[].forEach(...)`, `$(...).forEach(...)`, `arr.forEach(...)`, etc.\n",
    "options": {
      "type": "list",
      "listType": {
        "anyOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            },
            "minLength": 1,
            "maxLength": 3
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "anyOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    },
                    "minLength": 1
                  }
                ]
              },
              "message": {
                "type": "string"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      }
    },
    "optionExamples": [
      [
        true,
        "eval",
        {
          "name": "$",
          "message": "please don't"
        },
        [
          "describe",
          "only"
        ],
        {
          "name": [
            "it",
            "only"
          ],
          "message": "don't focus tests"
        },
        {
          "name": [
            "chai",
            "assert",
            "equal"
          ],
          "message": "Use 'strictEqual' instead."
        },
        {
          "name": [
            "*",
            "forEach"
          ],
          "message": "Use a regular for loop instead."
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "ban-types",
    "description": "\nBans specific types from being used. Does not ban the\ncorresponding runtime objects from being used.",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "minLength": 1,
        "maxLength": 2
      }
    },
    "optionsDescription": "\nA list of `[\"regex\", \"optional explanation here\"]`, which bans\ntypes that match `regex`",
    "optionExamples": [
      [
        true,
        [
          "Object",
          "Use {} instead."
        ],
        [
          "String"
        ]
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "binary-expression-operand-order",
    "description": "\nIn a binary expression, a literal should always be on the right-hand side if possible.\nFor example, prefer 'x + 1' over '1 + x'.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "callable-types",
    "description": "An interface or literal type with just a call signature can be written as a function type.",
    "rationale": "style",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "style",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "class-name",
    "description": "Enforces PascalCased class and interface names.",
    "rationale": "Makes it easy to differentiate classes from regular variables at a glance.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "comment-format",
    "description": "Enforces formatting rules for single-line comments.",
    "rationale": "Helps maintain a consistent, readable style in your codebase.",
    "optionsDescription": "\nThree arguments may be optionally provided:\n\n* `\"check-space\"` requires that all single-line comments must begin with a space, as in `// comment`\n    * note that for comments starting with multiple slashes, e.g. `///`, leading slashes are ignored\n    * TypeScript reference comments are ignored completely\n* `\"check-lowercase\"` requires that the first non-whitespace character of a comment must be lowercase, if applicable.\n* `\"check-uppercase\"` requires that the first non-whitespace character of a comment must be uppercase, if applicable.\n\nExceptions to `\"check-lowercase\"` or `\"check-uppercase\"` can be managed with object that may be passed as last argument.\n\nOne of two options can be provided in this object:\n\n    * `\"ignore-words\"`  - array of strings - words that will be ignored at the beginning of the comment.\n    * `\"ignore-pattern\"` - string - RegExp pattern that will be ignored at the beginning of the comment.\n",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "check-space",
              "check-lowercase",
              "check-uppercase"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ignore-words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "ignore-pattern": {
                "type": "string"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "minLength": 1,
      "maxLength": 4
    },
    "optionExamples": [
      [
        true,
        "check-space",
        "check-uppercase"
      ],
      [
        true,
        "check-lowercase",
        {
          "ignore-words": [
            "TODO",
            "HACK"
          ]
        }
      ],
      [
        true,
        "check-lowercase",
        {
          "ignore-pattern": "STD\\w{2,3}\\b"
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "completed-docs",
    "description": "Enforces documentation for important items be filled out.",
    "optionsDescription": "\n`true` to enable for [\"classes\", \"functions\", \"methods\", \"properties\"],\nor an array with each item in one of two formats:\n\n* `string` to enable for that type\n* `object` keying types to when their documentation is required:\n    * `\"methods\"` and `\"properties\"` may specify:\n        * `\"privacies\"`:\n            * `\"all\"`\n            * `\"private\"`\n            * `\"protected\"`\n            * `\"public\"`\n        * `\"locations\"`:\n            * `\"all\"`\n            * `\"instance\"`\n            * `\"static\"`\n    * All other types may specify `\"visibilities\"`:\n        * `\"all\"`\n        * `\"exported\"`\n        * `\"internal\"`\n\nTypes that may be enabled are:\n\n* `\"classes\"`\n* `\"enums\"`\n* `\"enum-members\"`\n* `\"functions\"`\n* `\"interfaces\"`\n* `\"methods\"`\n* `\"namespaces\"`\n* `\"properties\"`\n* `\"types\"`\n* `\"variables\"`",
    "options": {
      "type": "array",
      "items": {
        "anyOf": [
          {
            "enum": [
              "classes",
              "functions",
              "methods",
              "properties"
            ],
            "type": "string"
          },
          {
            "type": "object",
            "properties": {
              "classes": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "enums": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "enum-members": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "functions": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "interfaces": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "methods": {
                "properties": {
                  "locations": {
                    "enum": [
                      "all",
                      "instance",
                      "static"
                    ],
                    "type": "string"
                  },
                  "privacies": {
                    "enum": [
                      "all",
                      "private",
                      "protected",
                      "public"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "namespaces": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "properties": {
                "properties": {
                  "locations": {
                    "enum": [
                      "all",
                      "instance",
                      "static"
                    ],
                    "type": "string"
                  },
                  "privacies": {
                    "enum": [
                      "all",
                      "private",
                      "protected",
                      "public"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "types": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              },
              "variables": {
                "properties": {
                  "visibilities": {
                    "enum": [
                      "all",
                      "exported",
                      "internal"
                    ],
                    "type": "string"
                  }
                },
                "type": "object"
              }
            }
          }
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "enums",
        "functions",
        "methods"
      ],
      [
        true,
        {
          "enums": true,
          "functions": {
            "visibilities": [
              "exported"
            ]
          },
          "methods": {
            "locations": "instance",
            "privacies": [
              "public",
              "protected"
            ]
          }
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "curly",
    "description": "Enforces braces for `if`/`for`/`do`/`while` statements.",
    "rationale": "\n```ts\nif (foo === bar)\n    foo++;\n    bar++;\n```\n\nIn the code above, the author almost certainly meant for both `foo++` and `bar++`\nto be executed only if `foo === bar`. However, he forgot braces and `bar++` will be executed\nno matter what. This rule could prevent such a mistake.",
    "optionsDescription": "\nOne of the following options may be provided:\n\n* `\"as-needed\"` forbids any unnecessary curly braces.\n* `\"ignore-same-line\"` skips checking braces for control-flow statements\nthat are on one line and start on the same line as their control-flow keyword\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "as-needed",
          "ignore-same-line"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-same-line"
      ],
      [
        true,
        "as-needed"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "cyclomatic-complexity",
    "description": "Enforces a threshold of cyclomatic complexity.",
    "descriptionDetails": "\nCyclomatic complexity is assessed for each function of any type. A starting value of 0\nis assigned and this value is then incremented for every statement which can branch the\ncontrol flow within the function. The following statements and expressions contribute\nto cyclomatic complexity:\n* `catch`\n* `if` and `? :`\n* `||` and `&&` due to short-circuit evaluation\n* `for`, `for in` and `for of` loops\n* `while` and `do while` loops\n* `case` clauses that contain statements",
    "rationale": "\nCyclomatic complexity is a code metric which indicates the level of complexity in a\nfunction. High cyclomatic complexity indicates confusing code which may be prone to\nerrors or difficult to modify.",
    "optionsDescription": "\nAn optional upper limit for cyclomatic complexity can be specified. If no limit option\nis provided a default value of 20 will be used.",
    "options": {
      "type": "number",
      "minimum": 2
    },
    "optionExamples": [
      true,
      [
        true,
        20
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "deprecation",
    "description": "Warns when deprecated APIs are used.",
    "descriptionDetails": "Any usage of an identifier\n            with the @deprecated JSDoc annotation will trigger a warning.\n            See http://usejsdoc.org/tags-deprecated.html",
    "rationale": "Deprecated APIs should be avoided, and usage updated.",
    "optionsDescription": "",
    "options": null,
    "optionExamples": [],
    "type": "maintainability",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "encoding",
    "description": "Enforces UTF-8 file encoding.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      "true"
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "eofline",
    "description": "Ensures the file ends with a newline.",
    "descriptionDetails": "Fix for single-line files is not supported.",
    "rationale": "It is a [standard convention](http://stackoverflow.com/q/729692/3124288) to end files with a newline.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "hasFix": true,
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "file-header",
    "description": "Enforces a certain header comment for all files, matched by a regular expression.",
    "optionsDescription": "Regular expression to match the header.",
    "options": {
      "type": "string"
    },
    "optionExamples": [
      [
        true,
        "Copyright \\d{4}"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "forin",
    "description": "Requires a `for ... in` statement to be filtered with an `if` statement.",
    "rationale": "\n```ts\nfor (let key in someObject) {\n    if (someObject.hasOwnProperty(key)) {\n        // code here\n    }\n}\n```\nPrevents accidental iteration over properties inherited from an object's prototype.\nSee [MDN's `for...in`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in)\ndocumentation for more information about `for...in` loops.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "import-blacklist",
    "description": "\nDisallows importing the specified modules directly via `import` and `require`.\nInstead only sub modules may be imported from that module.",
    "rationale": "\nSome libraries allow importing their submodules instead of the entire module.\nThis is good practise as it avoids loading unused modules.",
    "optionsDescription": "A list of blacklisted modules.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      },
      "minLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "rxjs",
        "lodash"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "import-spacing",
    "description": "Ensures proper spacing between import statement keywords",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "indent",
    "description": "Enforces indentation with tabs or spaces.",
    "rationale": "\nUsing only one of tabs or spaces for indentation leads to more consistent editor behavior,\ncleaner diffs in version control, and easier programmatic manipulation.",
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `spaces` enforces consistent spaces.\n* `tabs` enforces consistent tabs.\n\nA second optional argument specifies indentation size:\n\n* `2` enforces 2 space indentation.\n* `4` enforces 4 space indentation.\n\nIndentation size is required for auto-fixing, but not for rule checking.\n",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "tabs",
            "spaces"
          ]
        },
        {
          "type": "number",
          "enum": [
            2,
            4
          ]
        }
      ],
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "spaces"
      ],
      [
        true,
        "spaces",
        4
      ],
      [
        true,
        "tabs",
        2
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "interface-name",
    "description": "Requires interface names to begin with a capital 'I'",
    "rationale": "Makes it easy to differentiate interfaces from regular classes at a glance.",
    "optionsDescription": "\nOne of the following two options must be provided:\n\n* `\"always-prefix\"` requires interface names to start with an \"I\"\n* `\"never-prefix\"` requires interface names to not have an \"I\" prefix",
    "options": {
      "type": "string",
      "enum": [
        "always-prefix",
        "never-prefix"
      ]
    },
    "optionExamples": [
      [
        true,
        "always-prefix"
      ],
      [
        true,
        "never-prefix"
      ]
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "interface-over-type-literal",
    "description": "Prefer an interface declaration over a type literal (`type T = { ... }`)",
    "rationale": "Interfaces are generally preferred over type literals because interfaces can be implemented, extended and merged.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "jsdoc-format",
    "description": "Enforces basic format rules for JSDoc comments.",
    "descriptionDetails": "\nThe following rules are enforced for JSDoc comments (comments starting with `/**`):\n\n* each line contains an asterisk and asterisks must be aligned\n* each asterisk must be followed by either a space or a newline (except for the first and the last)\n* the only characters before the asterisk on each line must be whitespace characters\n* one line comments must start with `/** ` and end with `*/`",
    "rationale": "Helps maintain a consistent, readable style for JSDoc comments.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "label-position",
    "description": "Only allows labels in sensible locations.",
    "descriptionDetails": "This rule only allows labels to be on `do/for/while/switch` statements.",
    "rationale": "\nLabels in JavaScript only can be used in conjunction with `break` or `continue`,\nconstructs meant to be used for loop flow control. While you can theoretically use\nlabels on any block statement in JS, it is considered poor code structure to do so.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "linebreak-style",
    "description": "Enforces a consistent linebreak style.",
    "optionsDescription": "\nOne of the following options must be provided:\n\n* `\"LF\"` requires LF (`\\n`) linebreaks\n* `\"CRLF\"` requires CRLF (`\\r\\n`) linebreaks",
    "options": {
      "type": "string",
      "enum": [
        "LF",
        "CRLF"
      ]
    },
    "optionExamples": [
      [
        true,
        "LF"
      ],
      [
        true,
        "CRLF"
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "match-default-export-name",
    "description": "\nRequires that a default import have the same name as the declaration it imports.\nDoes nothing for anonymous default exports.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "max-classes-per-file",
    "description": "\nA file may not contain more than the specified number of classes",
    "rationale": "\nEnsures that files have a single responsibility so that that classes each exist in their own files",
    "optionsDescription": "\nThe one required argument is an integer indicating the maximum number of classes that can appear in a file.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "number",
          "minimum": 1
        }
      ],
      "additionalItems": false,
      "minLength": 1,
      "maxLength": 2
    },
    "optionExamples": [
      [
        true,
        1
      ],
      [
        true,
        5
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "max-file-line-count",
    "description": "Requires files to remain under a certain number of lines",
    "rationale": "\nLimiting the number of lines allowed in a file allows files to remain small,\nsingle purpose, and maintainable.",
    "optionsDescription": "An integer indicating the maximum number of lines.",
    "options": {
      "type": "number",
      "minimum": "1"
    },
    "optionExamples": [
      [
        true,
        300
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "max-line-length",
    "description": "Requires lines to be under a certain max length.",
    "rationale": "\nLimiting the length of a line of code improves code readability.\nIt also makes comparing code side-by-side easier and improves compatibility with\nvarious editors, IDEs, and diff viewers.",
    "optionsDescription": "An integer indicating the max length of lines.",
    "options": {
      "type": "number",
      "minimum": "1"
    },
    "optionExamples": [
      [
        true,
        120
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "member-access",
    "description": "Requires explicit visibility declarations for class members.",
    "rationale": "Explicit visibility declarations can make code more readable and accessible for those new to TS.",
    "optionsDescription": "\nThese arguments may be optionally provided:\n\n* `\"no-public\"` forbids public accessibility to be specified, because this is the default.\n* `\"check-accessor\"` enforces explicit visibility on get/set accessors\n* `\"check-constructor\"`  enforces explicit visibility on constructors",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "no-public",
          "check-accessor",
          "check-constructor"
        ]
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        true,
        "no-public"
      ],
      [
        true,
        "check-accessor"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "member-ordering",
    "description": "Enforces member ordering.",
    "rationale": "A consistent ordering for class members can make classes easier to read, navigate, and edit.",
    "optionsDescription": "\nOne argument, which is an object, must be provided. It should contain an `order` property.\nThe `order` property should have a value of one of the following strings:\n\n* `fields-first`\n* `instance-sandwich`\n* `statics-first`\n\nAlternatively, the value for `order` maybe be an array consisting of the following strings:\n\n* `public-static-field`\n* `public-static-method`\n* `protected-static-field`\n* `protected-static-method`\n* `private-static-field`\n* `private-static-method`\n* `public-instance-field`\n* `protected-instance-field`\n* `private-instance-field`\n* `public-constructor`\n* `protected-constructor`\n* `private-constructor`\n* `public-instance-method`\n* `protected-instance-method`\n* `private-instance-method`\n\nYou can also omit the access modifier to refer to \"public-\", \"protected-\", and \"private-\" all at once; for example, \"static-field\".\n\nYou can also make your own categories by using an object instead of a string:\n\n    {\n        \"name\": \"static non-private\",\n        \"kinds\": [\n            \"public-static-field\",\n            \"protected-static-field\",\n            \"public-static-method\",\n            \"protected-static-method\"\n        ]\n    }\n\nThe 'alphabetize' option will enforce that members within the same category should be alphabetically sorted by name.",
    "options": {
      "type": "object",
      "properties": {
        "order": {
          "oneOf": [
            {
              "type": "string",
              "enum": [
                "fields-first",
                "instance-sandwich",
                "statics-first"
              ]
            },
            {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "public-static-field",
                  "public-static-method",
                  "protected-static-field",
                  "protected-static-method",
                  "private-static-field",
                  "private-static-method",
                  "public-instance-field",
                  "protected-instance-field",
                  "private-instance-field",
                  "public-constructor",
                  "protected-constructor",
                  "private-constructor",
                  "public-instance-method",
                  "protected-instance-method",
                  "private-instance-method"
                ]
              },
              "maxLength": 13
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      [
        true,
        {
          "order": "fields-first"
        }
      ],
      [
        true,
        {
          "order": [
            "static-field",
            "instance-field",
            "constructor",
            "public-instance-method",
            "protected-instance-method",
            "private-instance-method"
          ]
        }
      ],
      [
        true,
        {
          "order": [
            {
              "name": "static non-private",
              "kinds": [
                "public-static-field",
                "protected-static-field",
                "public-static-method",
                "protected-static-method"
              ]
            },
            "constructor"
          ]
        }
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "newline-before-return",
    "description": "Enforces blank line before return when not the only line in the block.",
    "rationale": "Helps maintain a readable style in your codebase.",
    "optionsDescription": "Not configurable.",
    "options": {},
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "new-parens",
    "description": "Requires parentheses when invoking a constructor via the `new` keyword.",
    "rationale": "Maintains stylistic consistency with other function calls.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-angle-bracket-type-assertion",
    "description": "Requires the use of `as Type` for type assertions instead of `<Type>`.",
    "hasFix": true,
    "rationale": "\nBoth formats of type assertions have the same effect, but only `as` type assertions\nwork in `.tsx` files. This rule ensures that you have a consistent type assertion style\nacross your codebase.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-any",
    "description": "Disallows usages of `any` as a type declaration.",
    "hasFix": false,
    "rationale": "Using `any` as a type declaration nullifies the compile-time benefits of the type system.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-arg",
    "description": "Disallows use of `arguments.callee`.",
    "rationale": "\nUsing `arguments.callee` makes various performance optimizations impossible.\nSee [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments/callee)\nfor more details on why to avoid `arguments.callee`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-bitwise",
    "description": "Disallows bitwise operators.",
    "descriptionDetails": "\nSpecifically, the following bitwise operators are banned:\n`&`, `&=`, `|`, `|=`,\n`^`, `^=`, `<<`, `<<=`,\n`>>`, `>>=`, `>>>`, `>>>=`, and `~`.\nThis rule does not ban the use of `&` and `|` for intersection and union types.",
    "rationale": "\nBitwise operators are often typos - for example `bool1 & bool2` instead of `bool1 && bool2`.\nThey also can be an indicator of overly clever code which decreases maintainability.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-boolean-literal-compare",
    "description": "Warns on comparison to a boolean literal, as in `x === true`.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-conditional-assignment",
    "description": "Disallows any type of assignment in conditionals.",
    "descriptionDetails": "This applies to `do-while`, `for`, `if`, and `while` statements.",
    "rationale": "\nAssignments in conditionals are often typos:\nfor example `if (var1 = var2)` instead of `if (var1 == var2)`.\nThey also can be an indicator of overly clever code which decreases maintainability.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-consecutive-blank-lines",
    "description": "Disallows one or more blank lines in a row.",
    "hasFix": true,
    "rationale": "Helps maintain a readable style in your codebase.",
    "optionsDescription": "\nAn optional number of maximum allowed sequential blanks can be specified. If no value\nis provided, a default of 1 will be used.",
    "options": {
      "type": "number",
      "minimum": "1"
    },
    "optionExamples": [
      true,
      [
        true,
        2
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-console",
    "description": "Bans the use of specified `console` methods.",
    "rationale": "In general, `console` methods aren't appropriate for production code.",
    "optionsDescription": "A list of method names to ban. If no method names are provided, all console methods are banned.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "optionExamples": [
      [
        true,
        "log",
        "error"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-construct",
    "description": "Disallows access to the constructors of `String`, `Number`, and `Boolean`.",
    "descriptionDetails": "Disallows constructor use such as `new Number(foo)` but does not disallow `Number(foo)`.",
    "rationale": "\nThere is little reason to use `String`, `Number`, or `Boolean` as constructors.\nIn almost all cases, the regular function-call version is more appropriate.\n[More details](http://stackoverflow.com/q/4719320/3124288) are available on StackOverflow.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-debugger",
    "description": "Disallows `debugger` statements.",
    "rationale": "In general, `debugger` statements aren't appropriate for production code.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-default-export",
    "description": "Disallows default exports in ES6-style modules.",
    "descriptionDetails": "Use named exports instead.",
    "rationale": "\nNamed imports/exports [promote clarity](https://github.com/palantir/tslint/issues/1182#issue-151780453).\nIn addition, current tooling differs on the correct way to handle default imports/exports.\nAvoiding them all together can help avoid tooling bugs and conflicts.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-imports",
    "description": "\nDisallows multiple import statements from the same module.",
    "rationale": "\nUsing a single import statement per module will make the code clearer because you can see everything being imported\nfrom that module on one line.",
    "optionsDescription": "Not configurable",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-super",
    "description": "Warns if 'super()' appears twice in a constructor.",
    "rationale": "The second call to 'super()' will fail at runtime.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-duplicate-variable",
    "description": "Disallows duplicate variable declarations in the same block scope.",
    "descriptionDetails": "\nThis rule is only useful when using the `var` keyword -\nthe compiler will detect redeclarations of `let` and `const` variables.",
    "rationale": "\nA variable can be reassigned if necessary -\nthere's no good reason to have a duplicate variable declaration.",
    "optionsDescription": "You can specify `\"check-parameters\"` to check for variables with the same name as a paramter.",
    "options": {
      "type": "string",
      "enum": [
        "check-parameters"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "check-parameters"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-empty-interface",
    "description": "Forbids empty interfaces.",
    "rationale": "An empty interface is equivalent to its supertype (or `{}`).",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-empty",
    "description": "Disallows empty blocks.",
    "descriptionDetails": "Blocks with a comment inside are not considered empty.",
    "rationale": "Empty blocks are often indicators of missing code.",
    "optionsDescription": "\nIf `allow-empty-catch` is specified, then catch blocks are allowed to be empty.",
    "options": {
      "type": "string",
      "enum": [
        "allow-empty-catch"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-empty-catch"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-eval",
    "description": "Disallows `eval` function invocations.",
    "rationale": "\n`eval()` is dangerous as it allows arbitrary code execution with full privileges. There are\n[alternatives](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)\nfor most of the use cases for `eval()`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-floating-promises",
    "description": "Promises returned by functions must be handled appropriately.",
    "descriptionDetails": "Use `no-unused-expression` in addition to this rule to reveal even more floating promises.",
    "optionsDescription": "\nA list of 'string' names of any additional classes that should also be handled as Promises.\n        ",
    "options": {
      "type": "list",
      "listType": {
        "type": "array",
        "items": {
          "type": "string"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "JQueryPromise"
      ]
    ],
    "rationale": "Unhandled Promises can cause unexpected behavior, such as resolving at unexpected times.",
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-for-in-array",
    "description": "Disallows iterating over an array with a for-in loop.",
    "descriptionDetails": "\nA for-in loop (`for (var k in o)`) iterates over the properties of an Object.\n\nWhile it is legal to use for-in loops with array types, it is not common.\nfor-in will iterate over the indices of the array as strings, omitting any \"holes\" in\nthe array.\n\nMore common is to use for-of, which iterates over the values of an array.\nIf you want to iterate over the indices, alternatives include:\n\narray.forEach((value, index) => { ... });\nfor (const [index, value] of array.entries()) { ... }\nfor (let i = 0; i < array.length; i++) { ... }\n",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "requiresTypeInfo": true,
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Avoid import statements with side-effect.",
    "optionExamples": [
      true,
      [
        true,
        {
          "ignore-module": "(\\.html|\\.css)$"
        }
      ]
    ],
    "options": {
      "items": {
        "properties": {
          "ignore-module": {
            "type": "string"
          }
        },
        "type": "object"
      },
      "maxLength": 1,
      "minLength": 0,
      "type": "array"
    },
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `ignore-module` allows to specify a regex and ignore modules which it matches.",
    "rationale": "Imports with side effects may have behavior which is hard for static verification.",
    "ruleName": "no-import-side-effect",
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-inferrable-types",
    "description": "Disallows explicit type declarations for variables or parameters initialized to a number, string, or boolean.",
    "rationale": "Explicit types where they can be easily inferred by the compiler make code more verbose.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `ignore-params` allows specifying an inferrable type annotation for function params.\nThis can be useful when combining with the `typedef` rule.\n* `ignore-properties` allows specifying an inferrable type annotation for class properties.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-params",
          "ignore-properties"
        ]
      },
      "minLength": 0,
      "maxLength": 2
    },
    "hasFix": true,
    "optionExamples": [
      true,
      [
        true,
        "ignore-params"
      ],
      [
        true,
        "ignore-params",
        "ignore-properties"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-inferred-empty-object-type",
    "description": "Disallow type inference of {} (empty object type) at function and constructor call sites",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-internal-module",
    "description": "Disallows internal `module`",
    "rationale": "Using `module` leads to a confusion of concepts with external modules. Use the newer `namespace` keyword instead.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "no-invalid-template-strings",
    "description": "Warns on use of `${` in non-template strings.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-invalid-this",
    "description": "Disallows using the `this` keyword outside of classes.",
    "rationale": "See [the rule's author's rationale here.](https://github.com/palantir/tslint/pull/1105#issue-147549402)",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `check-function-in-method` disallows using the `this` keyword in functions within class methods.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-function-in-method"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "check-function-in-method"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-irregular-whitespace",
    "description": "Disallow irregular whitespace outside of strings and comments",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-magic-numbers",
    "description": "\nDisallows the use constant number values outside of variable assignments.\nWhen no list of allowed values is specified, -1, 0 and 1 are allowed by default.",
    "rationale": "\nMagic numbers should be avoided as they often lack documentation, forcing\nthem to be stored in variables gives them implicit documentation.",
    "optionsDescription": "A list of allowed numbers.",
    "options": {
      "type": "array",
      "items": {
        "type": "number"
      },
      "minLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        1,
        2,
        3
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-mergeable-namespace",
    "description": "Disallows mergeable namespaces in the same file.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-misused-new",
    "description": "Warns on apparent attempts to define constructors for interfaces or `new` for classes.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-namespace",
    "description": "Disallows use of internal `module`s and `namespace`s.",
    "descriptionDetails": "This rule still allows the use of `declare module ... {}`",
    "rationale": "\nES6-style external modules are the standard way to modularize code.\nUsing `module {}` and `namespace {}` are outdated ways to organize TypeScript code.",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `allow-declarations` allows `declare namespace ... {}` to describe external APIs.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-declarations"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-declarations"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-non-null-assertion",
    "description": "Disallows non-null assertions.",
    "rationale": "Using non-null assertion cancels the benefits of the strict null checking mode.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-null-keyword",
    "description": "Disallows use of the `null` keyword literal.",
    "rationale": "\nInstead of having the dual concepts of `null` and`undefined` in a codebase,\nthis rule ensures that only `undefined` is used.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-object-literal-type-assertion",
    "description": "\nForbids an object literal to appear in a type assertion expression.\nCasting to `any` is still allowed.",
    "rationale": "\nAlways prefer `const x: T = { ... };` to `const x = { ... } as T;`.\nThe type assertion in the latter case is either unnecessary or hides an error.\nThe compiler will warn for excess properties with this syntax, but not missing required fields.\nFor example: `const x: { foo: number } = {}` will fail to compile, but\n`const x = {} as { foo: number }` will succeed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-parameter-properties",
    "description": "Disallows parameter properties in class constructors.",
    "rationale": "\nParameter properties can be confusing to those new to TS as they are less explicit\nthan other ways of declaring and initializing class members.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-parameter-reassignment",
    "description": "Disallows reassigning parameters.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-reference-import",
    "description": "Don't `<reference types=\"foo\" />` if you import `foo` anyway.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-reference",
    "description": "Disallows `/// <reference path=>` imports (use ES6-style imports instead).",
    "rationale": "\nUsing `/// <reference path=>` comments to load other files is outdated.\nUse ES6-style imports to reference other files.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-require-imports",
    "description": "Disallows invocation of `require()`.",
    "rationale": "Prefer the newer ES6-style imports over `require()`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-shadowed-variable",
    "description": "Disallows shadowing variable declarations.",
    "rationale": "Shadowing a variable masks access to it and obscures to what value an identifier actually refers.",
    "optionsDescription": "\nYou can optionally pass an object to disable checking for certain kinds of declarations.\nPossible keys are `\"class\"`, `\"enum\"`, `\"function\"`, `\"import\"`, `\"interface\"`, `\"namespace\"`, `\"typeAlias\"`\nand `\"typeParameter\"`. Just set the value to `false` for the check you want to disable.\nAll checks default to `true`, i.e. are enabled by default.\nNot that you cannot disable variables and parameters.\n        ",
    "options": {
      "type": "object",
      "properties": {
        "class": {
          "type": "boolean"
        },
        "enum": {
          "type": "boolean"
        },
        "function": {
          "type": "boolean"
        },
        "import": {
          "type": "boolean"
        },
        "interface": {
          "type": "boolean"
        },
        "namespace": {
          "type": "boolean"
        },
        "typeAlias": {
          "type": "boolean"
        },
        "typeParameter": {
          "type": "boolean"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "class": true,
          "enum": true,
          "function": true,
          "interface": false,
          "namespace": true,
          "typeAlias": false,
          "typeParameter": false
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-sparse-arrays",
    "description": "Forbids array literals to contain missing elements.",
    "rationale": "Missing elements are probably an accidentally duplicated comma.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-string-literal",
    "description": "\nForbids unnecessary string literal property access.\nAllows `obj[\"prop-erty\"]` (can't be a regular property access).\nDisallows `obj[\"property\"]` (should be `obj.property`).",
    "rationale": "\nIf `--noImplicitAny` is turned off,\nproperty access via a string literal will be 'any' if the property does not exist.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "no-string-throw",
    "description": "Flags throwing plain strings or concatenations of strings because only Errors produce proper stack traces.",
    "hasFix": true,
    "options": null,
    "optionsDescription": "Not configurable.",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-submodule-imports",
    "description": "\nDisallows importing any submodule.",
    "rationale": "\nSubmodules of some packages are treated as private APIs and the import\npaths may change without deprecation periods. It's best to stick with\ntop-level package exports.",
    "optionsDescription": "A list of whitelisted package or submodule names.",
    "options": {
      "type": "array",
      "items": {
        "type": "string"
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "rxjs",
        "@angular/platform-browser",
        "@angular/core/testing"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-switch-case-fall-through",
    "description": "Disallows falling through case statements.",
    "descriptionDetails": "\nFor example, the following is not allowed:\n\n```ts\nswitch(foo) {\n    case 1:\n        someFunc(foo);\n    case 2:\n        someOtherFunc(foo);\n}\n```\n\nHowever, fall through is allowed when case statements are consecutive or\na magic `/* falls through */` comment is present. The following is valid:\n\n```ts\nswitch(foo) {\n    case 1:\n        someFunc(foo);\n        /* falls through */\n    case 2:\n    case 3:\n        someOtherFunc(foo);\n}\n```",
    "rationale": "Fall though in switch statements is often unintentional and a bug.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "description": "Disallows unnecessary references to `this`.",
    "optionExamples": [
      true,
      [
        true,
        {
          "allowed-names": [
            "^self$"
          ],
          "allow-destructuring": true
        }
      ]
    ],
    "options": {
      "additionalProperties": false,
      "properties": {
        "allow-destructuring": {
          "type": "boolean"
        },
        "allowed-names": {
          "listType": "string",
          "type": "list"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nTwo options may be provided on an object:\n\n* `allow-destructuring` allows using destructuring to access members of `this` (e.g. `{ foo, bar } = this;`).\n* `allowed-names` may be specified as a list of regular expressions to match allowed variable names.",
    "rationale": "Assigning a variable to `this` instead of properly using arrow lambdas may be a symptom of pre-ES6 practices or not manging scope well.",
    "ruleName": "no-this-assignment",
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-trailing-whitespace",
    "description": "Disallows trailing whitespace at the end of a line.",
    "rationale": "Keeps version control diffs clean as it prevents accidental whitespace from being committed.",
    "optionsDescription": "\nPossible settings are:\n\n* `\"ignore-template-strings\"`: Allows trailing whitespace in template strings.\n* `\"ignore-comments\"`: Allows trailing whitespace in comments.\n* `\"ignore-jsdoc\"`: Allows trailing whitespace only in JSDoc comments.",
    "hasFix": true,
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-comments",
          "ignore-jsdoc",
          "ignore-template-strings"
        ]
      }
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-comments"
      ],
      [
        true,
        "ignore-jsdoc"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unbound-method",
    "description": "Warns when a method is used as outside of a method call.",
    "optionsDescription": "You may optionally pass \"ignore-static\" to ignore static methods.",
    "options": {
      "type": "string",
      "enum": [
        "ignore-static"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-static"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unnecessary-callback-wrapper",
    "description": "\nReplaces `x => f(x)` with just `f`.\nTo catch more cases, enable `only-arrow-functions` and `arrow-return-shorthand` too.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unnecessary-initializer",
    "description": "Forbids a 'var'/'let' statement or destructuring initializer to be initialized to 'undefined'.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unnecessary-qualifier",
    "description": "Warns when a namespace qualifier (`A.x`) is unnecessary.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unnecessary-type-assertion",
    "description": "Warns if a type assertion does not change the type of an expression.",
    "options": null,
    "optionsDescription": "Not configurable",
    "type": "typescript",
    "hasFix": true,
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unsafe-any",
    "description": "\nWarns when using an expression of type 'any' in a dynamic way.\nUses are only allowed if they would work for `{} | null | undefined`.\nType casts and tests are allowed.\nExpressions that work on all values (such as `\"\" + x`) are allowed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-unsafe-finally",
    "description": "\nDisallows control flow statements, such as `return`, `continue`,\n`break` and `throws` in finally blocks.",
    "descriptionDetails": "",
    "rationale": "\nWhen used inside `finally` blocks, control flow statements,\nsuch as `return`, `continue`, `break` and `throws`\noverride any other control flow statements in the same try/catch scope.\nThis is confusing and unexpected behavior.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unused-expression",
    "description": "Disallows unused expression statements.",
    "descriptionDetails": "\nUnused expressions are expression statements which are not assignments or function calls\n(and thus usually no-ops).",
    "rationale": "\nDetects potential errors where an assignment or function call was intended.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `allow-fast-null-checks` allows to use logical operators to perform fast null checks and perform\nmethod or function calls for side effects (e.g. `e && e.preventDefault()`).\n* `allow-new` allows 'new' expressions for side effects (e.g. `new ModifyGlobalState();`.\n* `allow-tagged-template` allows tagged templates for side effects (e.g. `this.add\\`foo\\`;`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-fast-null-checks",
          "allow-new",
          "allow-tagged-template"
        ]
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-fast-null-checks"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-unused-variable",
    "description": "Disallows unused imports, variables, functions and\n            private class members. Similar to tsc's --noUnusedParameters and --noUnusedLocals\n            options, but does not interrupt code compilation.",
    "hasFix": true,
    "optionsDescription": "\nThree optional arguments may be optionally provided:\n\n* `\"check-parameters\"` disallows unused function and constructor parameters.\n    * NOTE: this option is experimental and does not work with classes\n    that use abstract method declarations, among other things.\n* `{\"ignore-pattern\": \"pattern\"}` where pattern is a case-sensitive regexp.\nVariable names that match the pattern will be ignored.",
    "options": {
      "type": "array",
      "items": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "check-parameters"
            ]
          },
          {
            "type": "object",
            "properties": {
              "ignore-pattern": {
                "type": "string"
              }
            },
            "additionalProperties": false
          }
        ]
      },
      "minLength": 0,
      "maxLength": 3
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "ignore-pattern": "^_"
        }
      ]
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-use-before-declare",
    "description": "Disallows usage of variables before their declaration.",
    "descriptionDetails": "\nThis rule is primarily useful when using the `var` keyword -\nthe compiler will detect if a `let` and `const` variable is used before it is declared.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "no-var-keyword",
    "description": "Disallows usage of the `var` keyword.",
    "descriptionDetails": "Use `let` or `const` instead.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "no-var-requires",
    "description": "Disallows the use of require statements except in import statements.",
    "descriptionDetails": "\nIn other words, the use of forms such as `var module = require(\"module\")` are banned.\nInstead use ES6 style imports or `import foo = require('foo')` imports.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "no-void-expression",
    "description": "Requires expressions of type `void` to appear in statement position.",
    "optionsDescription": "\nIf `ignore-arrow-function-shorthand` is provided, `() => returnsVoid()` will be allowed.\nOtherwise, it must be written as `() => { returnsVoid(); }`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-arrow-function-shorthand"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "requiresTypeInfo": true,
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "number-literal-format",
    "description": "Checks that decimal literals should begin with '0.' instead of just '.', and should not end with a trailing '0'.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-key-quotes",
    "description": "Enforces consistent object literal property quote style.",
    "descriptionDetails": "\nObject literal property names can be defined in two ways: using literals or using strings.\nFor example, these two objects are equivalent:\n\nvar object1 = {\n    property: true\n};\n\nvar object2 = {\n    \"property\": true\n};\n\nIn many cases, it doesnt matter if you choose to use an identifier instead of a string\nor vice-versa. Even so, you might decide to enforce a consistent style in your code.\n\nThis rules lets you enforce consistent quoting of property names. Either they should always\nbe quoted (default behavior) or quoted only as needed (\"as-needed\").",
    "hasFix": true,
    "optionsDescription": "\nPossible settings are:\n\n* `\"always\"`: Property names should always be quoted. (This is the default.)\n* `\"as-needed\"`: Only property names which require quotes may be quoted (e.g. those with spaces in them).\n* `\"consistent\"`: Property names should either all be quoted or unquoted.\n* `\"consistent-as-needed\"`: If any property name requires quotes, then all properties must be quoted. Otherwise, no\nproperty names may be quoted.\n\nFor ES6, computed property names (`{[name]: value}`) and methods (`{foo() {}}`) never need\nto be quoted.",
    "options": {
      "type": "string",
      "enum": [
        "always",
        "as-needed",
        "consistent",
        "consistent-as-needed"
      ]
    },
    "optionExamples": [
      [
        true,
        "as-needed"
      ],
      [
        true,
        "always"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-shorthand",
    "description": "Enforces use of ES6 object literal shorthand when possible.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "object-literal-sort-keys",
    "description": "Checks ordering of keys in object literals.",
    "rationale": "Useful in preventing merge conflicts",
    "optionsDescription": "\nBy default, this rule checks that keys are in alphabetical order.\nThe following may optionally be passed:\n\n* \"ignore-case\" will to compare keys in a case insensitive way.\n* \"match-declaration-order will prefer to use the key ordering of the contextual type of the object literal, as in:\n\n    interface I { foo: number; bar: number; }\n    const obj: I = { foo: 1, bar: 2 };\n\nIf a contextual type is not found, alphabetical ordering will be used instead.\n",
    "options": {
      "type": "string",
      "enum": [
        "ignore-case",
        "match-declaration-order"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-case",
        "match-declaration-order"
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "one-line",
    "description": "Requires the specified tokens to be on the same line as the expression preceding them.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"check-catch\"` checks that `catch` is on the same line as the closing brace for `try`.\n* `\"check-finally\"` checks that `finally` is on the same line as the closing brace for `catch`.\n* `\"check-else\"` checks that `else` is on the same line as the closing brace for `if`.\n* `\"check-open-brace\"` checks that an open brace falls on the same line as its preceding expression.\n* `\"check-whitespace\"` checks preceding whitespace for the specified tokens.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-catch",
          "check-finally",
          "check-else",
          "check-open-brace",
          "check-whitespace"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "check-catch",
        "check-finally",
        "check-else"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "one-variable-per-declaration",
    "description": "Disallows multiple variable definitions in the same declaration statement.",
    "optionsDescription": "\nOne argument may be optionally provided:\n\n* `ignore-for-loop` allows multiple variable definitions in a for loop declaration.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "ignore-for-loop"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "ignore-for-loop"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "only-arrow-functions",
    "description": "Disallows traditional (non-arrow) function expressions.",
    "rationale": "Traditional functions don't bind lexical scope, which can lead to unexpected behavior when accessing 'this'.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `\"allow-declarations\"` allows standalone function declarations.\n* `\"allow-named-functions\"` allows the expression `function foo() {}` but not `function() {}`.\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-declarations",
          "allow-named-functions"
        ]
      },
      "minLength": 0,
      "maxLength": 1
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-declarations",
        "allow-named-functions"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "ordered-imports",
    "description": "Requires that import statements be alphabetized.",
    "descriptionDetails": "\nEnforce a consistent ordering for ES6 imports:\n- Named imports must be alphabetized (i.e. \"import {A, B, C} from \"foo\";\")\n    - The exact ordering can be controlled by the named-imports-order option.\n    - \"longName as name\" imports are ordered by \"longName\".\n- Import sources must be alphabetized within groups, i.e.:\n        import * as foo from \"a\";\n        import * as bar from \"b\";\n- Groups of imports are delineated by blank lines. You can use these to group imports\n    however you like, e.g. by first- vs. third-party or thematically.",
    "hasFix": true,
    "optionsDescription": "\nYou may set the `\"import-sources-order\"` option to control the ordering of source\nimports (the `\"foo\"` in `import {A, B, C} from \"foo\"`).\n\nPossible values for `\"import-sources-order\"` are:\n\n* `\"case-insensitive'`: Correct order is `\"Bar\"`, `\"baz\"`, `\"Foo\"`. (This is the default.)\n* `\"lowercase-first\"`: Correct order is `\"baz\"`, `\"Bar\"`, `\"Foo\"`.\n* `\"lowercase-last\"`: Correct order is `\"Bar\"`, `\"Foo\"`, `\"baz\"`.\n* `\"any\"`: Allow any order.\n\nYou may set the `\"named-imports-order\"` option to control the ordering of named\nimports (the `{A, B, C}` in `import {A, B, C} from \"foo\"`).\n\nPossible values for `\"named-imports-order\"` are:\n\n* `\"case-insensitive'`: Correct order is `{A, b, C}`. (This is the default.)\n* `\"lowercase-first\"`: Correct order is `{b, A, C}`.\n* `\"lowercase-last\"`: Correct order is `{A, C, b}`.\n* `\"any\"`: Allow any order.\n\n        ",
    "options": {
      "type": "object",
      "properties": {
        "import-sources-order": {
          "type": "string",
          "enum": [
            "case-insensitive",
            "lowercase-first",
            "lowercase-last",
            "any"
          ]
        },
        "named-imports-order": {
          "type": "string",
          "enum": [
            "case-insensitive",
            "lowercase-first",
            "lowercase-last",
            "any"
          ]
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "import-sources-order": "lowercase-last",
          "named-imports-order": "lowercase-first"
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-conditional-expression",
    "description": "\nRecommends to use a conditional expression instead of assigning to the same thing in each branch of an if statement.",
    "rationale": "\nThis reduces duplication and can eliminate an unnecessary variable declaration.",
    "optionsDescription": "If `check-else-if` is specified, the rule also checks nested if-else-if statements.",
    "options": {
      "type": "string",
      "enum": [
        "check-else-if"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "check-else-if"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-const",
    "description": "Requires that variable declarations use `const` instead of `let` and `var` if possible.",
    "descriptionDetails": "\nIf a variable is only assigned to once when it is declared, it should be declared using 'const'",
    "hasFix": true,
    "optionsDescription": "\nAn optional object containing the property \"destructuring\" with two possible values:\n\n* \"any\" (default) - If any variable in destructuring can be const, this rule warns for those variables.\n* \"all\" - Only warns if all variables in destructuring can be const.",
    "options": {
      "type": "object",
      "properties": {
        "destructuring": {
          "type": "string",
          "enum": [
            "all",
            "any"
          ]
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "destructuring": "all"
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-for-of",
    "description": "Recommends a 'for-of' loop over a standard 'for' loop if the index is only used to access the array being iterated.",
    "rationale": "A for(... of ...) loop is easier to implement and read when the index is not needed.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-function-over-method",
    "description": "Warns for class methods that do not use 'this'.",
    "optionsDescription": "\n\"allow-public\" excludes checking of public methods.\n\"allow-protected\" excludes checking of protected methods.",
    "options": {
      "type": "string",
      "enum": [
        "allow-public",
        "allow-protected"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-public",
        "allow-protected"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-method-signature",
    "description": "Prefer `foo(): void` over `foo: () => void` in interfaces and types.",
    "hasFix": true,
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-object-spread",
    "description": "Enforces the use of the ES2015 object spread operator over `Object.assign()` where appropriate.",
    "rationale": "Object spread allows for better type checking and inference.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "hasFix": true
  },
  {
    "ruleName": "prefer-switch",
    "description": "Prefer a `switch` statement to an `if` statement with simple `===` comparisons.",
    "optionsDescription": "\nAn optional object with the property 'min-cases'.\nThis is the number cases needed before a switch statement is recommended.\nDefaults to 3.",
    "options": {
      "type": "object",
      "properties": {
        "min-cases": {
          "type": "number"
        }
      }
    },
    "optionExamples": [
      true,
      [
        true,
        {
          "min-cases": 2
        }
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "prefer-template",
    "description": "Prefer a template expression over string literal concatenation.",
    "optionsDescription": "\nIf `allow-single-concat` is specified, then a single concatenation (`x + y`) is allowed, but not more (`x + y + z`).",
    "options": {
      "type": "string",
      "enum": [
        "allow-single-concat"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-single-concat"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "promise-function-async",
    "description": "Requires any function or method that returns a promise to be marked async.",
    "rationale": "\nEnsures that each function is only capable of 1) returning a rejected promise, or 2)\nthrowing an Error object. In contrast, non-`async` `Promise`-returning functions\nare technically capable of either. This practice removes a requirement for consuming\ncode to handle both cases.\n        ",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "quotemark",
    "description": "Requires single or double quotes for string literals.",
    "hasFix": true,
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"single\"` enforces single quotes.\n* `\"double\"` enforces double quotes.\n* `\"jsx-single\"` enforces single quotes for JSX attributes.\n* `\"jsx-double\"` enforces double quotes for JSX attributes.\n* `\"avoid-template\"` forbids single-line untagged template strings that do not contain string interpolations.\n* `\"avoid-escape\"` allows you to use the \"other\" quotemark in cases where escaping would normally be required.\nFor example, `[true, \"double\", \"avoid-escape\"]` would not report a failure on the string literal\n`'Hello \"World\"'`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "single",
          "double",
          "jsx-single",
          "jsx-double",
          "avoid-escape",
          "avoid-template"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "single",
        "avoid-escape",
        "avoid-template"
      ],
      [
        true,
        "single",
        "jsx-double"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "radix",
    "description": "Requires the radix parameter to be specified when calling `parseInt`.",
    "rationale": "\nFrom [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt):\n> Always specify this parameter to eliminate reader confusion and to guarantee predictable behavior.\n> Different implementations produce different results when a radix is not specified, usually defaulting the value to 10.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "restrict-plus-operands",
    "description": "When adding two variables, operands must both be of type number or of type string.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "return-undefined",
    "description": "Prefer `return;` in void functions and `return undefined;` in value-returning functions.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": false,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "semicolon",
    "description": "Enforces consistent semicolon usage at the end of every statement.",
    "hasFix": true,
    "optionsDescription": "\nOne of the following arguments must be provided:\n\n* `\"always\"` enforces semicolons at the end of every statement.\n* `\"never\"` disallows semicolons at the end of every statement except for when they are necessary.\n\nThe following arguments may be optionally provided:\n\n* `\"ignore-interfaces\"` skips checking semicolons at the end of interface members.\n* `\"ignore-bound-class-methods\"` skips checking semicolons at the end of bound class methods.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "string",
          "enum": [
            "always",
            "never"
          ]
        },
        {
          "type": "string",
          "enum": [
            "ignore-interfaces"
          ]
        }
      ],
      "additionalItems": false
    },
    "optionExamples": [
      [
        true,
        "always"
      ],
      [
        true,
        "never"
      ],
      [
        true,
        "always",
        "ignore-interfaces"
      ],
      [
        true,
        "always",
        "ignore-bound-class-methods"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "description": "Require or disallow a space before function parenthesis",
    "hasFix": true,
    "optionExamples": [
      true,
      [
        true,
        "always"
      ],
      [
        true,
        "never"
      ],
      [
        true,
        {
          "anonymous": "always",
          "named": "never",
          "asyncArrow": "always"
        }
      ]
    ],
    "options": {
      "properties": {
        "anonymous": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "asyncArrow": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "constructor": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "method": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        },
        "named": {
          "enum": [
            "always",
            "never"
          ],
          "type": "string"
        }
      },
      "type": "object"
    },
    "optionsDescription": "\nOne argument which is an object which may contain the keys `anonymous`, `named`, and `asyncArrow`\nThese should be set to either `\"always\"` or `\"never\"`.\n\n* `\"anonymous\"` checks before the opening paren in anonymous functions\n* `\"named\"` checks before the opening paren in named functions\n* `\"asyncArrow\"` checks before the opening paren in async arrow functions\n* `\"method\"` checks before the opening paren in class methods\n* `\"constructor\"` checks before the opening paren in class constructors\n        ",
    "ruleName": "space-before-function-paren",
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "space-within-parens",
    "description": "Enforces spaces within parentheses or disallow them.",
    "hasFix": true,
    "optionsDescription": "\nYou may enforce the amount of whitespace within parentheses.\n        ",
    "options": {
      "type": "number",
      "min": 0
    },
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "strict-boolean-expressions",
    "description": "\nRestricts the types allowed in boolean expressions. By default only booleans are allowed.\n\nThe following nodes are checked:\n\n* Arguments to the `!`, `&&`, and `||` operators\n* The condition in a conditional expression (`cond ? x : y`)\n* Conditions for `if`, `for`, `while`, and `do-while` statements.",
    "optionsDescription": "\nThese options may be provided:\n\n* `allow-null-union` allows union types containing `null`.\n  - It does *not* allow `null` itself.\n  - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\n* `allow-undefined-union` allows union types containing `undefined`.\n  - It does *not* allow `undefined` itself.\n  - Without the '--strictNullChecks' compiler option, this will allow anything other than a string, number, or enum.\n* `allow-string` allows strings.\n  - It does *not* allow unions containing `string`.\n  - It does *not* allow string literal types.\n* `allow-number` allows numbers.\n  - It does *not* allow unions containing `number`.\n  - It does *not* allow enums or number literal types.\n* `allow-mix` allows multiple of the above to appear together.\n  - For example, `string | number` or `RegExp | null | undefined` would normally not be allowed.\n  - A type like `\"foo\" | \"bar\" | undefined` is always allowed, because it has only one way to be false.\n* `allow-boolean-or-undefined` allows `boolean | undefined`.\n  - Also allows `true | false | undefined`.\n  - Does not allow `false | undefined`.\n  - This option is a subset of `allow-undefined-union`, so you don't need to enable both options at the same time.\n        ",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-null-union",
          "allow-undefined-union",
          "allow-string",
          "allow-number",
          "allow-boolean-or-undefined"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-null-union",
        "allow-undefined-union",
        "allow-string",
        "allow-number"
      ],
      [
        true,
        "allow-boolean-or-undefined"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "strict-type-predicates",
    "description": "\nWarns for type predicates that are always true or always false.\nWorks for 'typeof' comparisons to constants (e.g. 'typeof foo === \"string\"'), and equality comparison to 'null'/'undefined'.\n(TypeScript won't let you compare '1 === 2', but it has an exception for '1 === undefined'.)\nDoes not yet work for 'instanceof'.\nDoes *not* warn for 'if (x.y)' where 'x.y' is always truthy. For that, see strict-boolean-expressions.\n\nThis rule requires `strictNullChecks` to work properly.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "switch-default",
    "description": "Require a `default` case in all `switch` statements.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "switch-final-break",
    "description": "Checks whether the final clause of a switch statement ends in `break;`.",
    "optionsDescription": "\nIf no options are passed, a final 'break;' is forbidden.\nIf the \"always\" option is passed this will require a 'break;' to always be present\nunless control flow is escaped in some other way.",
    "options": {
      "type": "string",
      "enum": [
        "always"
      ]
    },
    "optionExamples": [
      true,
      [
        true,
        "always"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "trailing-comma",
    "description": "\nRequires or disallows trailing commas in array and object literals, destructuring assignments, function typings,\nnamed imports and exports and function parameters.",
    "hasFix": true,
    "optionsDescription": "\nOne argument which is an object with the keys `multiline` and `singleline`.\nBoth can be set to a string (`\"always\"` or `\"never\"`) or an object.\n\nThe object can contain any of the following keys: `\"arrays\"`, `\"objects\"`, `\"functions\"`,\n`\"imports\"`, `\"exports\"`, and `\"typeLiterals\"`; each key can have one of the following\nvalues: `\"always\"`, `\"never\"`, and `\"ignore\"`. Any missing keys will default to `\"ignore\"`.\n\n* `\"multiline\"` checks multi-line object literals.\n* `\"singleline\"` checks single-line object literals.\n\nAn array is considered \"multiline\" if its closing bracket is on a line\nafter the last array element. The same general logic is followed for\nobject literals, function typings, named import statements\nand function parameters.",
    "options": {
      "type": "object",
      "properties": {
        "multiline": {
          "anyOf": [
            {
              "type": "string",
              "enum": [
                "always",
                "never"
              ]
            },
            {
              "type": "object",
              "properties": {
                "arrays": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "exports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "functions": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "imports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "objects": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "typeLiterals": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                }
              }
            }
          ]
        },
        "singleline": {
          "anyOf": [
            {
              "type": "string",
              "enum": [
                "always",
                "never"
              ]
            },
            {
              "type": "object",
              "properties": {
                "arrays": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "exports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "functions": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "imports": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "objects": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                },
                "typeLiterals": {
                  "type": "string",
                  "enum": [
                    "always",
                    "never",
                    "ignore"
                  ]
                }
              }
            }
          ]
        }
      },
      "additionalProperties": false
    },
    "optionExamples": [
      [
        true,
        {
          "multiline": "always",
          "singleline": "never"
        }
      ],
      [
        true,
        {
          "multiline": {
            "objects": "always",
            "arrays": "always",
            "functions": "never",
            "typeLiterals": "ignore"
          }
        }
      ]
    ],
    "type": "maintainability",
    "typescriptOnly": false
  },
  {
    "ruleName": "triple-equals",
    "description": "Requires `===` and `!==` in place of `==` and `!=`.",
    "optionsDescription": "\nTwo arguments may be optionally provided:\n\n* `\"allow-null-check\"` allows `==` and `!=` when comparing to `null`.\n* `\"allow-undefined-check\"` allows `==` and `!=` when comparing to `undefined`.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "allow-null-check",
          "allow-undefined-check"
        ]
      },
      "minLength": 0,
      "maxLength": 2
    },
    "optionExamples": [
      true,
      [
        true,
        "allow-null-check"
      ],
      [
        true,
        "allow-undefined-check"
      ]
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "typedef",
    "description": "Requires type definitions to exist.",
    "optionsDescription": "\nSeveral arguments may be optionally provided:\n\n* `\"call-signature\"` checks return type of functions.\n* `\"arrow-call-signature\"` checks return type of arrow functions.\n* `\"parameter\"` checks type specifier of function parameters for non-arrow functions.\n* `\"arrow-parameter\"` checks type specifier of function parameters for arrow functions.\n* `\"property-declaration\"` checks return types of interface properties.\n* `\"variable-declaration\"` checks non-binding variable declarations.\n* `\"member-variable-declaration\"` checks member variable declarations.\n* `\"object-destructuring\"` checks object destructuring declarations.\n* `\"array-destructuring\"` checks array destructuring declarations.",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "call-signature",
          "arrow-call-signature",
          "parameter",
          "arrow-parameter",
          "property-declaration",
          "variable-declaration",
          "member-variable-declaration",
          "object-destructuring",
          "array-destructuring"
        ]
      },
      "minLength": 0,
      "maxLength": 7
    },
    "optionExamples": [
      [
        true,
        "call-signature",
        "parameter",
        "member-variable-declaration"
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "typedef-whitespace",
    "description": "Requires or disallows whitespace for type definitions.",
    "descriptionDetails": "Determines if a space is required or not before the colon in a type specifier.",
    "optionsDescription": "\nTwo arguments which are both objects.\nThe first argument specifies how much space should be to the _left_ of a typedef colon.\nThe second argument specifies how much space should be to the _right_ of a typedef colon.\nEach key should have a value of `\"onespace\"`, `\"space\"` or `\"nospace\"`.\nPossible keys are:\n\n* `\"call-signature\"` checks return type of functions.\n* `\"index-signature\"` checks index type specifier of indexers.\n* `\"parameter\"` checks function parameters.\n* `\"property-declaration\"` checks object property declarations.\n* `\"variable-declaration\"` checks variable declaration.",
    "options": {
      "type": "array",
      "items": [
        {
          "type": "object",
          "properties": {
            "call-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "index-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "parameter": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "property-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "variable-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "properties": {
            "call-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "index-signature": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "parameter": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "property-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            },
            "variable-declaration": {
              "type": "string",
              "enum": [
                "nospace",
                "onespace",
                "space"
              ]
            }
          },
          "additionalProperties": false
        }
      ],
      "additionalItems": false
    },
    "optionExamples": [
      [
        true,
        {
          "call-signature": "nospace",
          "index-signature": "nospace",
          "parameter": "nospace",
          "property-declaration": "nospace",
          "variable-declaration": "nospace"
        },
        {
          "call-signature": "onespace",
          "index-signature": "onespace",
          "parameter": "onespace",
          "property-declaration": "onespace",
          "variable-declaration": "onespace"
        }
      ]
    ],
    "type": "typescript",
    "typescriptOnly": true,
    "hasFix": true
  },
  {
    "ruleName": "type-literal-delimiter",
    "description": "\nChecks that type literal members are separated by semicolons.\nEnforces a trailing semicolon for multiline type literals.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "style",
    "typescriptOnly": true
  },
  {
    "ruleName": "typeof-compare",
    "description": "Makes sure result of `typeof` is compared to correct string values",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "unified-signatures",
    "description": "Warns for any two overloads that could be unified into one by using a union or an optional/rest parameter.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "typescript",
    "typescriptOnly": true
  },
  {
    "ruleName": "use-default-type-parameter",
    "description": "Warns if an explicitly specified type argument is the default for that type parameter.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      "true"
    ],
    "type": "functionality",
    "typescriptOnly": true,
    "requiresTypeInfo": true
  },
  {
    "ruleName": "use-isnan",
    "description": "Enforces use of the `isNaN()` function to check for NaN references instead of a comparison to the `NaN` constant.",
    "rationale": "\nSince `NaN !== NaN`, comparisons with regular operators will produce unexpected results.\nSo, instead of `if (myVar === NaN)`, do `if (isNaN(myVar))`.",
    "optionsDescription": "Not configurable.",
    "options": null,
    "optionExamples": [
      true
    ],
    "type": "functionality",
    "typescriptOnly": false
  },
  {
    "ruleName": "variable-name",
    "description": "Checks variable names for various errors.",
    "optionsDescription": "\nFive arguments may be optionally provided:\n\n* `\"check-format\"`: allows only lowerCamelCased or UPPER_CASED variable names\n  * `\"allow-leading-underscore\"` allows underscores at the beginning (only has an effect if \"check-format\" specified)\n  * `\"allow-trailing-underscore\"` allows underscores at the end. (only has an effect if \"check-format\" specified)\n  * `\"allow-pascal-case\"` allows PascalCase in addition to lowerCamelCase.\n  * `\"allow-snake-case\"` allows snake_case in addition to lowerCamelCase.\n* `\"ban-keywords\"`: disallows the use of certain TypeScript keywords as variable or parameter names.\n  * These are: `any`, `Number`, `number`, `String`, `string`, `Boolean`, `boolean`, `Undefined`, `undefined`",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-format",
          "allow-leading-underscore",
          "allow-trailing-underscore",
          "allow-pascal-case",
          "allow-snake-case",
          "ban-keywords"
        ]
      },
      "minLength": 0,
      "maxLength": 5
    },
    "optionExamples": [
      [
        true,
        "ban-keywords",
        "check-format",
        "allow-leading-underscore"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  },
  {
    "ruleName": "whitespace",
    "description": "Enforces whitespace style conventions.",
    "rationale": "Helps maintain a readable, consistent style in your codebase.",
    "optionsDescription": "\nTen arguments may be optionally provided:\n\n* `\"check-branch\"` checks branching statements (`if`/`else`/`for`/`while`) are followed by whitespace.\n* `\"check-decl\"`checks that variable declarations have whitespace around the equals token.\n* `\"check-operator\"` checks for whitespace around operator tokens.\n* `\"check-module\"` checks for whitespace in import & export statements.\n* `\"check-separator\"` checks for whitespace after separator tokens (`,`/`;`).\n* `\"check-rest-spread\"` checks that there is no whitespace after rest/spread operator (`...`).\n* `\"check-type\"` checks for whitespace before a variable type specification.\n* `\"check-typecast\"` checks for whitespace between a typecast and its target.\n* `\"check-type-operator\"` checks for whitespace between type operators `|` and `&`.\n* `\"check-preblock\"` checks for whitespace before the opening brace of a block",
    "options": {
      "type": "array",
      "items": {
        "type": "string",
        "enum": [
          "check-branch",
          "check-decl",
          "check-operator",
          "check-module",
          "check-separator",
          "check-rest-spread",
          "check-type",
          "check-typecast",
          "check-type-operator",
          "check-preblock"
        ]
      },
      "minLength": 0,
      "maxLength": 10
    },
    "optionExamples": [
      [
        true,
        "check-branch",
        "check-operator",
        "check-typecast"
      ]
    ],
    "type": "style",
    "typescriptOnly": false
  }
]